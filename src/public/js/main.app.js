(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["main"],{

/***/ "./src/css/app.scss":
/*!**************************!*\
  !*** ./src/css/app.scss ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/css/app.scss?");

/***/ }),

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data/config */ \"./src/js/data/config.js\");\n/* harmony import */ var _utils_detector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/detector */ \"./src/js/utils/detector.js\");\n/* harmony import */ var _app_main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app/main */ \"./src/js/app/main.js\");\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../css/app.scss */ \"./src/css/app.scss\");\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_css_app_scss__WEBPACK_IMPORTED_MODULE_3__);\n\n\n // Styles\n\n // Check environment and set the Config helper\n\nif (true) {\n  console.log('----- RUNNING IN DEV ENVIRONMENT! -----');\n  _data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isDev = true;\n}\n\nfunction init() {\n  // Check for webGL capabilities\n  if (!_utils_detector__WEBPACK_IMPORTED_MODULE_1__[\"default\"].webgl) {\n    _utils_detector__WEBPACK_IMPORTED_MODULE_1__[\"default\"].addGetWebGLMessage();\n  } else {\n    var container = document.getElementById('appContainer');\n    new _app_main__WEBPACK_IMPORTED_MODULE_2__[\"default\"](container);\n  }\n}\n\ninit();\n\n//# sourceURL=webpack:///./src/js/app.js?");

/***/ }),

/***/ "./src/js/app/components/Enemy.js":
/*!****************************************!*\
  !*** ./src/js/app/components/Enemy.js ***!
  \****************************************/
/*! exports provided: Enemy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Enemy\", function() { return Enemy; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _lib_yuka__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/yuka */ \"./src/js/lib/yuka.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\nvar startPosition = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\nvar endPosition = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n\nvar Enemy =\n/*#__PURE__*/\nfunction (_YUKA$Vehicle) {\n  _inherits(Enemy, _YUKA$Vehicle);\n\n  function Enemy() {\n    var _this;\n\n    _classCallCheck(this, Enemy);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Enemy).call(this));\n    _this.maxSpeed = 4;\n    _this.updateOrientation = false;\n    _this.navMesh = null;\n    _this.currentRegion = null;\n    return _this;\n  }\n\n  _createClass(Enemy, [{\n    key: \"update\",\n    value: function update(delta) {\n      startPosition.copy(this.position);\n\n      _get(_getPrototypeOf(Enemy.prototype), \"update\", this).call(this, delta);\n\n      endPosition.copy(this.position); // ensure the entity stays inside its navmesh\n\n      this.currentRegion = this.navMesh.clampMovement(this.currentRegion, startPosition, endPosition, this.position); // adjust height of player according to the ground\n\n      var distance = this.currentRegion.distanceToPoint(this.position);\n      this.position.y -= distance * 0.2; // smooth transition\n    }\n  }]);\n\n  return Enemy;\n}(_lib_yuka__WEBPACK_IMPORTED_MODULE_1__[\"Vehicle\"]);\n\n\n\n//# sourceURL=webpack:///./src/js/app/components/Enemy.js?");

/***/ }),

/***/ "./src/js/app/components/camera.js":
/*!*****************************************!*\
  !*** ./src/js/app/components/camera.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Camera; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n // Class that creates and updates the main camera\n\nvar Camera =\n/*#__PURE__*/\nfunction () {\n  function Camera(renderer) {\n    var _this = this;\n\n    _classCallCheck(this, Camera);\n\n    var width = renderer.domElement.width;\n    var height = renderer.domElement.height; // Create and position a Perspective Camera\n\n    this.threeCamera = new three__WEBPACK_IMPORTED_MODULE_0__[\"PerspectiveCamera\"](_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].camera.fov, width / height, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].camera.near, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].camera.far);\n    this.threeCamera.position.set(_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].camera.posX, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].camera.posY, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].camera.posZ); // Initial sizing\n\n    this.updateSize(renderer); // Listeners\n\n    window.addEventListener('resize', function () {\n      return _this.updateSize(renderer);\n    }, false);\n  }\n\n  _createClass(Camera, [{\n    key: \"updateSize\",\n    value: function updateSize(renderer) {\n      // Update camera aspect ratio with window aspect ratio\n      this.threeCamera.aspect = renderer.domElement.width / renderer.domElement.height; // Always call updateProjectionMatrix on camera change\n\n      this.threeCamera.updateProjectionMatrix();\n    }\n  }]);\n\n  return Camera;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/components/camera.js?");

/***/ }),

/***/ "./src/js/app/components/controls.js":
/*!*******************************************!*\
  !*** ./src/js/app/components/controls.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Controls; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_orbitControls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/orbitControls */ \"./src/js/utils/orbitControls.js\");\n/* harmony import */ var _utils_orbitControls__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_utils_orbitControls__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n // Controls based on orbit controls\n\nvar Controls =\n/*#__PURE__*/\nfunction () {\n  function Controls(camera, container) {\n    _classCallCheck(this, Controls);\n\n    // Orbit controls first needs to pass in THREE to constructor\n    var orbitControls = new _utils_orbitControls__WEBPACK_IMPORTED_MODULE_1___default.a(three__WEBPACK_IMPORTED_MODULE_0__);\n    this.threeControls = new orbitControls(camera, container);\n    this.init();\n  }\n\n  _createClass(Controls, [{\n    key: \"init\",\n    value: function init() {\n      this.threeControls.target.set(_data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.target.x, _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.target.y, _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.target.z);\n      this.threeControls.autoRotate = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.autoRotate;\n      this.threeControls.autoRotateSpeed = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.autoRotateSpeed;\n      this.threeControls.rotateSpeed = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.rotateSpeed;\n      this.threeControls.zoomSpeed = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.zoomSpeed;\n      this.threeControls.minDistance = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.minDistance;\n      this.threeControls.maxDistance = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.maxDistance;\n      this.threeControls.minPolarAngle = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.minPolarAngle;\n      this.threeControls.maxPolarAngle = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.maxPolarAngle;\n      this.threeControls.enableDamping = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.enableDamping;\n      this.threeControls.enableZoom = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.enableZoom;\n      this.threeControls.dampingFactor = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.dampingFactor;\n    }\n  }]);\n\n  return Controls;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/components/controls.js?");

/***/ }),

/***/ "./src/js/app/components/light.js":
/*!****************************************!*\
  !*** ./src/js/app/components/light.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Light; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n // Sets up and places all lights in scene\n\nvar Light =\n/*#__PURE__*/\nfunction () {\n  function Light(scene) {\n    _classCallCheck(this, Light);\n\n    this.scene = scene;\n    this.init();\n  }\n\n  _createClass(Light, [{\n    key: \"init\",\n    value: function init() {\n      // Ambient\n      this.ambientLight = new three__WEBPACK_IMPORTED_MODULE_0__[\"AmbientLight\"](_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ambientLight.color);\n      this.ambientLight.visible = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ambientLight.enabled; // Point light\n\n      this.pointLight = new three__WEBPACK_IMPORTED_MODULE_0__[\"PointLight\"](_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pointLight.color, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pointLight.intensity, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pointLight.distance);\n      this.pointLight.position.set(_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pointLight.x, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pointLight.y, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pointLight.z);\n      this.pointLight.visible = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pointLight.enabled; // Directional light\n\n      this.directionalLight = new three__WEBPACK_IMPORTED_MODULE_0__[\"DirectionalLight\"](_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].directionalLight.color, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].directionalLight.intensity);\n      this.directionalLight.position.set(_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].directionalLight.x, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].directionalLight.y, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].directionalLight.z);\n      this.directionalLight.visible = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].directionalLight.enabled; // Shadow map\n\n      this.directionalLight.castShadow = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.enabled;\n      this.directionalLight.shadow.bias = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.bias;\n      this.directionalLight.shadow.camera.near = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.near;\n      this.directionalLight.shadow.camera.far = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.far;\n      this.directionalLight.shadow.camera.left = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.left;\n      this.directionalLight.shadow.camera.right = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.right;\n      this.directionalLight.shadow.camera.top = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.top;\n      this.directionalLight.shadow.camera.bottom = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.bottom;\n      this.directionalLight.shadow.mapSize.width = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.mapWidth;\n      this.directionalLight.shadow.mapSize.height = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.mapHeight; // Shadow camera helper\n\n      this.directionalLightHelper = new three__WEBPACK_IMPORTED_MODULE_0__[\"CameraHelper\"](this.directionalLight.shadow.camera);\n      this.directionalLightHelper.visible = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.helperEnabled; // Hemisphere light\n\n      this.hemiLight = new three__WEBPACK_IMPORTED_MODULE_0__[\"HemisphereLight\"](_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hemiLight.color, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hemiLight.groundColor, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hemiLight.intensity);\n      this.hemiLight.position.set(_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hemiLight.x, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hemiLight.y, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hemiLight.z);\n      this.hemiLight.visible = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hemiLight.enabled;\n    }\n  }, {\n    key: \"place\",\n    value: function place(lightName) {\n      switch (lightName) {\n        case 'ambient':\n          this.scene.add(this.ambientLight);\n          break;\n\n        case 'directional':\n          this.scene.add(this.directionalLight);\n          this.scene.add(this.directionalLightHelper);\n          break;\n\n        case 'point':\n          this.scene.add(this.pointLight);\n          break;\n\n        case 'hemi':\n          this.scene.add(this.hemiLight);\n          break;\n      }\n    }\n  }]);\n\n  return Light;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/components/light.js?");

/***/ }),

/***/ "./src/js/app/components/renderer.js":
/*!*******************************************!*\
  !*** ./src/js/app/components/renderer.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Renderer; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n // Main webGL renderer class\n\nvar Renderer =\n/*#__PURE__*/\nfunction () {\n  function Renderer(scene, container) {\n    var _this = this;\n\n    _classCallCheck(this, Renderer);\n\n    // Properties\n    this.scene = scene;\n    this.container = container; // Create WebGL renderer and set its antialias\n\n    this.threeRenderer = new three__WEBPACK_IMPORTED_MODULE_0__[\"WebGLRenderer\"]({\n      antialias: true\n    }); // Set clear color to fog to enable fog or to hex color for no fog\n\n    this.threeRenderer.setClearColor(scene.fog.color);\n    this.threeRenderer.setPixelRatio(window.devicePixelRatio); // For retina\n    // Appends canvas\n\n    container.appendChild(this.threeRenderer.domElement); // Shadow map options\n\n    this.threeRenderer.shadowMap.enabled = true;\n    this.threeRenderer.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_0__[\"PCFSoftShadowMap\"]; // Get anisotropy for textures\n\n    _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maxAnisotropy = this.threeRenderer.getMaxAnisotropy(); // Initial size update set to canvas container\n\n    this.updateSize(); // Listeners\n\n    document.addEventListener('DOMContentLoaded', function () {\n      return _this.updateSize();\n    }, false);\n    window.addEventListener('resize', function () {\n      return _this.updateSize();\n    }, false);\n  }\n\n  _createClass(Renderer, [{\n    key: \"updateSize\",\n    value: function updateSize() {\n      this.threeRenderer.setSize(this.container.offsetWidth, this.container.offsetHeight);\n    }\n  }, {\n    key: \"render\",\n    value: function render(scene, camera) {\n      // Renders scene to canvas target\n      this.threeRenderer.render(scene, camera);\n    }\n  }]);\n\n  return Renderer;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/components/renderer.js?");

/***/ }),

/***/ "./src/js/app/helpers/geometry.js":
/*!****************************************!*\
  !*** ./src/js/app/helpers/geometry.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Geometry; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./material */ \"./src/js/app/helpers/material.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n // This helper class can be used to create and then place geometry in the scene\n\nvar Geometry =\n/*#__PURE__*/\nfunction () {\n  function Geometry(scene) {\n    _classCallCheck(this, Geometry);\n\n    this.scene = scene;\n    this.geo = null;\n    this.mesh = null;\n  }\n\n  _createClass(Geometry, [{\n    key: \"make\",\n    value: function make(type) {\n      var _this = this;\n\n      if (type === 'plane') {\n        return function (width, height) {\n          var widthSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n          var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n          _this.geo = new three__WEBPACK_IMPORTED_MODULE_0__[\"PlaneGeometry\"](width, height, widthSegments, heightSegments);\n        };\n      }\n\n      if (type === 'sphere') {\n        return function (radius) {\n          var widthSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n          var heightSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;\n          _this.geo = new three__WEBPACK_IMPORTED_MODULE_0__[\"SphereGeometry\"](radius, widthSegments, heightSegments);\n        };\n      }\n\n      if (type === 'box') {\n        return function (width, height, depth) {\n          var widthSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 32;\n          var heightSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 32;\n          var depthSegments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 32;\n          _this.geo = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxGeometry\"](width, height, depth, widthSegments, heightSegments, depthSegments);\n        };\n      }\n    }\n  }, {\n    key: \"place\",\n    value: function place(position, rotation) {\n      var _mesh$position, _mesh$rotation;\n\n      var material = new _material__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0xeeeeee).standard;\n      var mesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](this.geo, material); // Use ES6 spread to set position and rotation from passed in array\n\n      (_mesh$position = mesh.position).set.apply(_mesh$position, _toConsumableArray(position));\n\n      (_mesh$rotation = mesh.rotation).set.apply(_mesh$rotation, _toConsumableArray(rotation));\n\n      if (_data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].shadow.enabled) {\n        mesh.receiveShadow = true;\n      }\n\n      this.mesh = mesh;\n      this.scene.add(mesh);\n    }\n  }]);\n\n  return Geometry;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/helpers/geometry.js?");

/***/ }),

/***/ "./src/js/app/helpers/material.js":
/*!****************************************!*\
  !*** ./src/js/app/helpers/material.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Material; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n // USe this class as a helper to set up some default materials\n\nvar Material = function Material(color) {\n  _classCallCheck(this, Material);\n\n  this.basic = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]({\n    color: color,\n    side: three__WEBPACK_IMPORTED_MODULE_0__[\"DoubleSide\"]\n  });\n  this.standard = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshStandardMaterial\"]({\n    color: color,\n    shading: three__WEBPACK_IMPORTED_MODULE_0__[\"FlatShading\"],\n    roughness: 1,\n    metalness: 0,\n    side: three__WEBPACK_IMPORTED_MODULE_0__[\"DoubleSide\"]\n  });\n  this.wire = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]({\n    wireframe: true\n  });\n};\n\n\n\n//# sourceURL=webpack:///./src/js/app/helpers/material.js?");

/***/ }),

/***/ "./src/js/app/helpers/meshHelper.js":
/*!******************************************!*\
  !*** ./src/js/app/helpers/meshHelper.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MeshHelper; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n // Simple mesh helper that shows edges, wireframes, and face and vertex normals\n\nvar MeshHelper = function MeshHelper(scene, mesh) {\n  _classCallCheck(this, MeshHelper);\n\n  var wireframe = new three__WEBPACK_IMPORTED_MODULE_0__[\"WireframeGeometry\"](mesh.geometry);\n  var wireLine = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineSegments\"](wireframe);\n  wireLine.material.depthTest = false;\n  wireLine.material.opacity = 0.25;\n  wireLine.material.transparent = true;\n  mesh.add(wireLine);\n  var edges = new three__WEBPACK_IMPORTED_MODULE_0__[\"EdgesGeometry\"](mesh.geometry);\n  var edgesLine = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineSegments\"](edges);\n  edgesLine.material.depthTest = false;\n  edgesLine.material.opacity = 0.25;\n  edgesLine.material.transparent = true;\n  mesh.add(edgesLine);\n  scene.add(new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxHelper\"](mesh));\n  scene.add(new three__WEBPACK_IMPORTED_MODULE_0__[\"FaceNormalsHelper\"](mesh, 2));\n  scene.add(new three__WEBPACK_IMPORTED_MODULE_0__[\"VertexNormalsHelper\"](mesh, 2));\n};\n\n\n\n//# sourceURL=webpack:///./src/js/app/helpers/meshHelper.js?");

/***/ }),

/***/ "./src/js/app/helpers/navmeshHelper.js":
/*!*********************************************!*\
  !*** ./src/js/app/helpers/navmeshHelper.js ***!
  \*********************************************/
/*! exports provided: createConvexRegionHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createConvexRegionHelper\", function() { return createConvexRegionHelper; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\nfunction createConvexRegionHelper(navMesh) {\n  var regions = navMesh.regions;\n  var geometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferGeometry\"]();\n  var material = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]({\n    vertexColors: three__WEBPACK_IMPORTED_MODULE_0__[\"VertexColors\"]\n  });\n  var mesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](geometry, material);\n  var positions = [];\n  var colors = [];\n  var color = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]();\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = regions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var region = _step.value;\n      // one color for each convex region\n      color.setHex(Math.random() * 0xffffff); // count edges\n\n      var edge = region.edge;\n      var edges = [];\n\n      do {\n        edges.push(edge);\n        edge = edge.next;\n      } while (edge !== region.edge); // triangulate\n\n\n      var triangleCount = edges.length - 2;\n\n      for (var i = 1, l = triangleCount; i <= l; i++) {\n        var v1 = edges[0].vertex;\n        var v2 = edges[i + 0].vertex;\n        var v3 = edges[i + 1].vertex;\n        positions.push(v1.x, v1.y, v1.z);\n        positions.push(v2.x, v2.y, v2.z);\n        positions.push(v3.x, v3.y, v3.z);\n        colors.push(color.r, color.g, color.b);\n        colors.push(color.r, color.g, color.b);\n        colors.push(color.r, color.g, color.b);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  geometry.addAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__[\"Float32BufferAttribute\"](positions, 3));\n  geometry.addAttribute('color', new three__WEBPACK_IMPORTED_MODULE_0__[\"Float32BufferAttribute\"](colors, 3));\n  return mesh;\n}\n\n\n\n//# sourceURL=webpack:///./src/js/app/helpers/navmeshHelper.js?");

/***/ }),

/***/ "./src/js/app/helpers/stats.js":
/*!*************************************!*\
  !*** ./src/js/app/helpers/stats.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Stats; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Local vars for rStats\nvar rS, bS, glS, tS;\n\nvar Stats =\n/*#__PURE__*/\nfunction () {\n  function Stats(renderer) {\n    _classCallCheck(this, Stats);\n\n    this.renderer = renderer;\n  }\n\n  _createClass(Stats, [{\n    key: \"setUp\",\n    value: function setUp() {\n      bS = new BrowserStats();\n      glS = new glStats();\n      tS = new threeStats(this.renderer.threeRenderer);\n      rS = new rStats({\n        CSSPath: './css/',\n        userTimingAPI: true,\n        values: {\n          frame: {\n            caption: 'Total frame time (ms)',\n            over: 16,\n            average: true,\n            avgMs: 100\n          },\n          fps: {\n            caption: 'Framerate (FPS)',\n            below: 30\n          },\n          calls: {\n            caption: 'Calls (three.js)',\n            over: 3000\n          },\n          raf: {\n            caption: 'Time since last rAF (ms)',\n            average: true,\n            avgMs: 100\n          },\n          rstats: {\n            caption: 'rStats update (ms)',\n            average: true,\n            avgMs: 100\n          },\n          texture: {\n            caption: 'GenTex',\n            average: true,\n            avgMs: 100\n          }\n        },\n        groups: [{\n          caption: 'Framerate',\n          values: ['fps', 'raf']\n        }, {\n          caption: 'Frame Budget',\n          values: ['frame', 'texture', 'setup', 'render']\n        }],\n        fractions: [{\n          base: 'frame',\n          steps: ['texture', 'setup', 'render']\n        }],\n        plugins: [bS, tS, glS]\n      });\n    }\n  }], [{\n    key: \"start\",\n    value: function start() {\n      rS('frame').start();\n      glS.start();\n      rS('rAF').tick();\n      rS('FPS').frame();\n      rS('render').start();\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      rS('render').end(); // render finished\n\n      rS('frame').end(); // frame finished\n      // Local rStats update\n\n      rS('rStats').start();\n      rS().update();\n      rS('rStats').end();\n    }\n  }]);\n\n  return Stats;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/helpers/stats.js?");

/***/ }),

/***/ "./src/js/app/main.js":
/*!****************************!*\
  !*** ./src/js/app/main.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Main; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var gsap_TweenMax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gsap/TweenMax */ \"./node_modules/gsap/TweenMax.js\");\n/* harmony import */ var _lib_yuka__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/yuka */ \"./src/js/lib/yuka.js\");\n/* harmony import */ var _components_renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/renderer */ \"./src/js/app/components/renderer.js\");\n/* harmony import */ var _components_camera__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/camera */ \"./src/js/app/components/camera.js\");\n/* harmony import */ var _components_light__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/light */ \"./src/js/app/components/light.js\");\n/* harmony import */ var _components_controls__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/controls */ \"./src/js/app/components/controls.js\");\n/* harmony import */ var _helpers_geometry__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helpers/geometry */ \"./src/js/app/helpers/geometry.js\");\n/* harmony import */ var _helpers_stats__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./helpers/stats */ \"./src/js/app/helpers/stats.js\");\n/* harmony import */ var _model_texture__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./model/texture */ \"./src/js/app/model/texture.js\");\n/* harmony import */ var _model_model__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./model/model */ \"./src/js/app/model/model.js\");\n/* harmony import */ var _managers_interaction__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./managers/interaction */ \"./src/js/app/managers/interaction.js\");\n/* harmony import */ var _managers_datGUI__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./managers/datGUI */ \"./src/js/app/managers/datGUI.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./../data/config */ \"./src/js/data/config.js\");\n/* harmony import */ var _helpers_navmeshHelper__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./helpers/navmeshHelper */ \"./src/js/app/helpers/navmeshHelper.js\");\n/* harmony import */ var _components_Enemy__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/Enemy */ \"./src/js/app/components/Enemy.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Global imports -\n\n\n // Local imports -\n// Components\n\n\n\n\n // Helpers\n\n\n // Model\n\n\n // Managers\n\n\n // data\n\n\n\n // -- End of imports\n// This class instantiates and ties all of the components together, starts the loading process and renders the main loop\n\nvar Main =\n/*#__PURE__*/\nfunction () {\n  function Main(container) {\n    var _this = this;\n\n    _classCallCheck(this, Main);\n\n    // Set container property to container element\n    this.container = container;\n    var loadingManager = new three__WEBPACK_IMPORTED_MODULE_0__[\"LoadingManager\"](function () {\n      // 3D assets are loaded, now load nav mesh\n      console.log('test loading manager');\n    }); // Start Three clock\n\n    this.clock = new three__WEBPACK_IMPORTED_MODULE_0__[\"Clock\"](); // Main scene creation\n\n    this.scene = new three__WEBPACK_IMPORTED_MODULE_0__[\"Scene\"]();\n    this.scene.fog = new three__WEBPACK_IMPORTED_MODULE_0__[\"FogExp2\"](_data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].fog.color, _data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].fog.near); // const boxGeometry = new THREE.BoxBufferGeometry( 10, 10, 10 );\n    // const boxMaterial = new THREE.MeshBasicMaterial( {color: 0x00ff00} );\n    // const cube = new THREE.Mesh( boxGeometry, boxMaterial );\n    // cube.matrixAutoUpdate = false;\n    // this.scene.add(cube);\n    // this.enemy = new Enemy();\n    // this.enemy.boundingRadius = 0.25;\n    // this.enemy.setRenderComponent(cube, this.syncEnemy);\n    // this.enemy.position.set( 0, 0, 0);\n\n    var loader = new _lib_yuka__WEBPACK_IMPORTED_MODULE_2__[\"NavMeshLoader\"]();\n    loader.load('./assets/models/navmesh3.glb', {\n      epsilonCoplanarTest: 0.25\n    }).then(function (navMesh) {\n      // visualize convex regions\n      var navMeshGroup = Object(_helpers_navmeshHelper__WEBPACK_IMPORTED_MODULE_14__[\"createConvexRegionHelper\"])(navMesh);\n      navMeshGroup.scale.multiplyScalar(10);\n\n      _this.scene.add(navMeshGroup); // player.navMesh = navMesh;\n\n\n      enemy.navMesh = navMesh;\n      console.log('loaded navmesh');\n    }); // Get Device Pixel Ratio first for retina\n\n    if (window.devicePixelRatio) {\n      _data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].dpr = window.devicePixelRatio;\n    } // Main renderer constructor\n\n\n    this.renderer = new _components_renderer__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.scene, container); // Components instantiations\n\n    this.camera = new _components_camera__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.renderer.threeRenderer);\n    this.controls = new _components_controls__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this.camera.threeCamera, container);\n    this.light = new _components_light__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this.scene); // Create and place lights in scene\n\n    var lights = ['ambient', 'directional', 'point', 'hemi'];\n    lights.forEach(function (light) {\n      return _this.light.place(light);\n    }); // Create and place geo in scene\n    // this.geometry = new Geometry(this.scene)\n    // this.geometry.make('plane')(150, 150, 10, 10)\n    // this.geometry.place([0, 1, 0], [Math.PI / 2, 0, 0])\n    // this.box = new Geometry(this.scene)\n    // this.box.make('box')(10, 10, 10, 8, 8, 8)\n    // this.box.place([0, 10, 20], [0, 0, 0])\n    // Set up rStats if dev environment\n\n    if (_data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isDev && _data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isShowingStats) {\n      this.stats = new _helpers_stats__WEBPACK_IMPORTED_MODULE_8__[\"default\"](this.renderer);\n      this.stats.setUp();\n    } // Instantiate texture class\n\n\n    this.texture = new _model_texture__WEBPACK_IMPORTED_MODULE_9__[\"default\"](); // Start loading the textures and then go on to load the model after the texture Promises have resolved\n\n    this.texture.load().then(function () {\n      _this.manager = new three__WEBPACK_IMPORTED_MODULE_0__[\"LoadingManager\"](); // Textures loaded, load model\n\n      _this.model = new _model_model__WEBPACK_IMPORTED_MODULE_10__[\"default\"](_this.scene, _this.manager, _this.texture.textures);\n\n      _this.model.load(); // onProgress callback\n\n\n      _this.manager.onProgress = function (item, loaded, total) {\n        console.log(\"\".concat(item, \": \").concat(loaded, \" \").concat(total));\n      }; // All loaders done now\n\n\n      _this.manager.onLoad = function () {\n        // Set up interaction manager with the app now that the model is finished loading\n        new _managers_interaction__WEBPACK_IMPORTED_MODULE_11__[\"default\"](_this.renderer.threeRenderer, _this.scene, _this.camera.threeCamera, _this.controls.threeControls); // Add dat.GUI controls if dev\n\n        if (_data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isDev) {\n          new _managers_datGUI__WEBPACK_IMPORTED_MODULE_12__[\"default\"](_this, _this.model.obj);\n        } // Everything is now fully loaded\n\n\n        _data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isLoaded = true;\n        _this.container.querySelector('#loading').style.display = 'none'; // TweenMax.to(this.lift.position, 2, {\n        //   y: 4,\n        //   repeat: -1,\n        //   yoyo: true,\n        //   ease: Power2.easeInOut\n        // })\n      };\n    }); // Start render which does not wait for model fully loaded\n\n    this.render();\n  }\n\n  _createClass(Main, [{\n    key: \"syncEnemy\",\n    value: function syncEnemy(entity, renderComponent) {\n      renderComponent.matrix.copy(entity.worldMatrix);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      // Render rStats if Dev\n      if (_data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isDev && _data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isShowingStats) {\n        _helpers_stats__WEBPACK_IMPORTED_MODULE_8__[\"default\"].start();\n      } // Call render function and pass in created scene and camera\n\n\n      this.renderer.render(this.scene, this.camera.threeCamera); // rStats has finished determining render call now\n\n      if (_data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isDev && _data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isShowingStats) {\n        _helpers_stats__WEBPACK_IMPORTED_MODULE_8__[\"default\"].end();\n      } // Delta time is sometimes needed for certain updates\n      //const delta = this.clock.getDelta();\n      // Call any vendor or module frame updates here\n\n\n      this.controls.threeControls.update(); // RAF\n\n      requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n    }\n  }]);\n\n  return Main;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/main.js?");

/***/ }),

/***/ "./src/js/app/managers/datGUI.js":
/*!***************************************!*\
  !*** ./src/js/app/managers/datGUI.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DatGUI; });\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n // Manages all dat.GUI interactions\n\nvar DatGUI = function DatGUI(main, mesh) {\n  var _this = this;\n\n  _classCallCheck(this, DatGUI);\n\n  var gui = new dat.GUI();\n  this.camera = main.camera.threeCamera;\n  this.controls = main.controls.threeControls;\n  this.light = main.light;\n  /* Global */\n  //gui.close();\n\n  /* Camera */\n\n  var cameraFolder = gui.addFolder('Camera');\n  var cameraFOVGui = cameraFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].camera, 'fov', 0, 180).name('Camera FOV');\n  cameraFOVGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.camera.fov = value;\n  });\n  cameraFOVGui.onFinishChange(function () {\n    _this.camera.updateProjectionMatrix();\n\n    _this.controls.enableRotate = true;\n  });\n  var cameraAspectGui = cameraFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].camera, 'aspect', 0, 4).name('Camera Aspect');\n  cameraAspectGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.camera.aspect = value;\n  });\n  cameraAspectGui.onFinishChange(function () {\n    _this.camera.updateProjectionMatrix();\n\n    _this.controls.enableRotate = true;\n  });\n  var cameraFogColorGui = cameraFolder.addColor(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fog, 'color').name('Fog Color');\n  cameraFogColorGui.onChange(function (value) {\n    main.scene.fog.color.setHex(value);\n  });\n  var cameraFogNearGui = cameraFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fog, 'near', 0.000, 0.010).name('Fog Near');\n  cameraFogNearGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    main.scene.fog.density = value;\n  });\n  cameraFogNearGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  });\n  /* Controls */\n\n  var controlsFolder = gui.addFolder('Controls');\n  controlsFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].controls, 'autoRotate').name('Auto Rotate').onChange(function (value) {\n    _this.controls.autoRotate = value;\n  });\n  var controlsAutoRotateSpeedGui = controlsFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].controls, 'autoRotateSpeed', -1, 1).name('Rotation Speed');\n  controlsAutoRotateSpeedGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.controls.autoRotateSpeed = value;\n  });\n  controlsAutoRotateSpeedGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  });\n  /* Mesh */\n\n  var meshFolder = gui.addFolder('Mesh');\n  meshFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh, 'translucent', true).name('Translucent').onChange(function (value) {\n    if (value) {\n      mesh.material.transparent = true;\n      mesh.material.opacity = 0.5;\n    } else {\n      mesh.material.opacity = 1.0;\n    }\n  });\n  meshFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh, 'wireframe', true).name('Wireframe').onChange(function (value) {\n    mesh.material.wireframe = value;\n  });\n  /* Lights */\n  // Ambient Light\n\n  var ambientLightFolder = gui.addFolder('Ambient Light');\n  ambientLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ambientLight, 'enabled').name('Enabled').onChange(function (value) {\n    _this.light.ambientLight.visible = value;\n  });\n  ambientLightFolder.addColor(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ambientLight, 'color').name('Color').onChange(function (value) {\n    _this.light.ambientLight.color.setHex(value);\n  }); // Directional Light\n\n  var directionalLightFolder = gui.addFolder('Directional Light');\n  directionalLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].directionalLight, 'enabled').name('Enabled').onChange(function (value) {\n    _this.light.directionalLight.visible = value;\n  });\n  directionalLightFolder.addColor(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].directionalLight, 'color').name('Color').onChange(function (value) {\n    _this.light.directionalLight.color.setHex(value);\n  });\n  var directionalLightIntensityGui = directionalLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].directionalLight, 'intensity', 0, 2).name('Intensity');\n  directionalLightIntensityGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.directionalLight.intensity = value;\n  });\n  directionalLightIntensityGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  });\n  var directionalLightPositionXGui = directionalLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].directionalLight, 'x', -1000, 1000).name('Position X');\n  directionalLightPositionXGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.directionalLight.position.x = value;\n  });\n  directionalLightPositionXGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  });\n  var directionalLightPositionYGui = directionalLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].directionalLight, 'y', -1000, 1000).name('Position Y');\n  directionalLightPositionYGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.directionalLight.position.y = value;\n  });\n  directionalLightPositionYGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  });\n  var directionalLightPositionZGui = directionalLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].directionalLight, 'z', -1000, 1000).name('Position Z');\n  directionalLightPositionZGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.directionalLight.position.z = value;\n  });\n  directionalLightPositionZGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  }); // Shadow Map\n\n  var shadowFolder = gui.addFolder('Shadow Map');\n  shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'enabled').name('Enabled').onChange(function (value) {\n    _this.light.directionalLight.castShadow = value;\n  });\n  shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'helperEnabled').name('Helper Enabled').onChange(function (value) {\n    _this.light.directionalLightHelper.visible = value;\n  });\n  var shadowNearGui = shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'near', 0, 400).name('Near');\n  shadowNearGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.directionalLight.shadow.camera.near = value;\n  });\n  shadowNearGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n\n    _this.light.directionalLight.shadow.map.dispose();\n\n    _this.light.directionalLight.shadow.map = null;\n\n    _this.light.directionalLightHelper.update();\n  });\n  var shadowFarGui = shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'far', 0, 1200).name('Far');\n  shadowFarGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.directionalLight.shadow.camera.far = value;\n  });\n  shadowFarGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n\n    _this.light.directionalLight.shadow.map.dispose();\n\n    _this.light.directionalLight.shadow.map = null;\n\n    _this.light.directionalLightHelper.update();\n  });\n  var shadowTopGui = shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'top', -400, 400).name('Top');\n  shadowTopGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.directionalLight.shadow.camera.top = value;\n  });\n  shadowTopGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n\n    _this.light.directionalLight.shadow.map.dispose();\n\n    _this.light.directionalLight.shadow.map = null;\n\n    _this.light.directionalLightHelper.update();\n  });\n  var shadowRightGui = shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'right', -400, 400).name('Right');\n  shadowRightGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.directionalLight.shadow.camera.right = value;\n  });\n  shadowRightGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n\n    _this.light.directionalLight.shadow.map.dispose();\n\n    _this.light.directionalLight.shadow.map = null;\n\n    _this.light.directionalLightHelper.update();\n  });\n  var shadowBottomGui = shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'bottom', -400, 400).name('Bottom');\n  shadowBottomGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.directionalLight.shadow.camera.bottom = value;\n  });\n  shadowBottomGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n\n    _this.light.directionalLight.shadow.map.dispose();\n\n    _this.light.directionalLight.shadow.map = null;\n\n    _this.light.directionalLightHelper.update();\n  });\n  var shadowLeftGui = shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'left', -400, 400).name('Left');\n  shadowLeftGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.directionalLight.shadow.camera.left = value;\n  });\n  shadowLeftGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n\n    _this.light.directionalLight.shadow.map.dispose();\n\n    _this.light.directionalLight.shadow.map = null;\n\n    _this.light.directionalLightHelper.update();\n  });\n  var shadowBiasGui = shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'bias', -0.000010, 1).name('Bias');\n  shadowBiasGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.directionalLight.shadow.bias = value;\n  });\n  shadowBiasGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n\n    _this.light.directionalLight.shadow.map.dispose();\n\n    _this.light.directionalLight.shadow.map = null;\n\n    _this.light.directionalLightHelper.update();\n  }); // Point Light\n\n  var pointLightFolder = gui.addFolder('Point Light');\n  pointLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointLight, 'enabled').name('Enabled').onChange(function (value) {\n    _this.light.pointLight.visible = value;\n  });\n  pointLightFolder.addColor(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointLight, 'color').name('Color').onChange(function (value) {\n    _this.light.pointLight.color.setHex(value);\n  });\n  var pointLightIntensityGui = pointLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointLight, 'intensity', 0, 2).name('Intensity');\n  pointLightIntensityGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.pointLight.intensity = value;\n  });\n  pointLightIntensityGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  });\n  var pointLightDistanceGui = pointLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointLight, 'distance', 0, 1000).name('Distance');\n  pointLightDistanceGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.pointLight.distance = value;\n  });\n  pointLightDistanceGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  });\n  var pointLightPositionXGui = pointLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointLight, 'x', -1000, 1000).name('Position X');\n  pointLightPositionXGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.pointLight.position.x = value;\n  });\n  pointLightPositionXGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  });\n  var pointLightPositionYGui = pointLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointLight, 'y', -1000, 1000).name('Position Y');\n  pointLightPositionYGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.pointLight.position.y = value;\n  });\n  pointLightPositionYGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  });\n  var pointLightPositionZGui = pointLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointLight, 'z', -1000, 1000).name('Position Z');\n  pointLightPositionZGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.pointLight.position.z = value;\n  });\n  pointLightPositionZGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  }); // Hemi Light\n\n  var hemiLightFolder = gui.addFolder('Hemi Light');\n  hemiLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hemiLight, 'enabled').name('Enabled').onChange(function (value) {\n    _this.light.hemiLight.visible = value;\n  });\n  hemiLightFolder.addColor(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hemiLight, 'color').name('Color').onChange(function (value) {\n    _this.light.hemiLight.color.setHex(value);\n  });\n  hemiLightFolder.addColor(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hemiLight, 'groundColor').name('ground Color').onChange(function (value) {\n    _this.light.hemiLight.groundColor.setHex(value);\n  });\n  var hemiLightIntensityGui = hemiLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hemiLight, 'intensity', 0, 2).name('Intensity');\n  hemiLightIntensityGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.hemiLight.intensity = value;\n  });\n  hemiLightIntensityGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  });\n  var hemiLightPositionXGui = hemiLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hemiLight, 'x', -1000, 1000).name('Position X');\n  hemiLightPositionXGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.hemiLight.position.x = value;\n  });\n  hemiLightPositionXGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  });\n  var hemiLightPositionYGui = hemiLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hemiLight, 'y', -500, 1000).name('Position Y');\n  hemiLightPositionYGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.hemiLight.position.y = value;\n  });\n  hemiLightPositionYGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  });\n  var hemiLightPositionZGui = hemiLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hemiLight, 'z', -1000, 1000).name('Position Z');\n  hemiLightPositionZGui.onChange(function (value) {\n    _this.controls.enableRotate = false;\n    _this.light.hemiLight.position.z = value;\n  });\n  hemiLightPositionZGui.onFinishChange(function () {\n    _this.controls.enableRotate = true;\n  });\n};\n\n\n\n//# sourceURL=webpack:///./src/js/app/managers/datGUI.js?");

/***/ }),

/***/ "./src/js/app/managers/interaction.js":
/*!********************************************!*\
  !*** ./src/js/app/managers/interaction.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Interaction; });\n/* harmony import */ var _utils_keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/keyboard */ \"./src/js/utils/keyboard.js\");\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/helpers */ \"./src/js/utils/helpers.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n // Manages all input interactions\n\nvar Interaction =\n/*#__PURE__*/\nfunction () {\n  function Interaction(renderer, scene, camera, controls) {\n    var _this = this;\n\n    _classCallCheck(this, Interaction);\n\n    // Properties\n    this.renderer = renderer;\n    this.scene = scene;\n    this.camera = camera;\n    this.controls = controls;\n    this.timeout = null; // Instantiate keyboard helper\n\n    this.keyboard = new _utils_keyboard__WEBPACK_IMPORTED_MODULE_0__[\"default\"](); // Listeners\n    // Mouse events\n\n    this.renderer.domElement.addEventListener('mousemove', function (event) {\n      return _utils_helpers__WEBPACK_IMPORTED_MODULE_1__[\"default\"].throttle(_this.onMouseMove(event), 250);\n    }, false);\n    this.renderer.domElement.addEventListener('mouseleave', function (event) {\n      return _this.onMouseLeave(event);\n    }, false);\n    this.renderer.domElement.addEventListener('mouseover', function (event) {\n      return _this.onMouseOver(event);\n    }, false); // Keyboard events\n\n    this.keyboard.domElement.addEventListener('keydown', function (event) {\n      // Only once\n      if (event.repeat) {\n        return;\n      }\n\n      if (_this.keyboard.eventMatches(event, 'escape')) {\n        console.log('Escape pressed');\n      }\n    });\n  }\n\n  _createClass(Interaction, [{\n    key: \"onMouseOver\",\n    value: function onMouseOver(event) {\n      event.preventDefault();\n      _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isMouseOver = true;\n    }\n  }, {\n    key: \"onMouseLeave\",\n    value: function onMouseLeave(event) {\n      event.preventDefault();\n      _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isMouseOver = false;\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      event.preventDefault();\n      clearTimeout(this.timeout);\n      this.timeout = setTimeout(function () {\n        _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isMouseMoving = false;\n      }, 200);\n      _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isMouseMoving = true;\n    }\n  }]);\n\n  return Interaction;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/managers/interaction.js?");

/***/ }),

/***/ "./src/js/app/model/model.js":
/*!***********************************!*\
  !*** ./src/js/app/model/model.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Model; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n/* harmony import */ var _helpers_material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/material */ \"./src/js/app/helpers/material.js\");\n/* harmony import */ var _helpers_meshHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/meshHelper */ \"./src/js/app/helpers/meshHelper.js\");\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/helpers */ \"./src/js/utils/helpers.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n // Loads in a single object from the config file\n\nvar Model =\n/*#__PURE__*/\nfunction () {\n  function Model(scene, manager, textures) {\n    _classCallCheck(this, Model);\n\n    this.scene = scene;\n    this.textures = textures; // Manager is passed in to loader to determine when loading done in main\n\n    this.loader = new three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_1__[\"GLTFLoader\"](manager);\n    this.obj = null;\n  }\n\n  _createClass(Model, [{\n    key: \"load\",\n    value: function load() {\n      var _this = this;\n\n      // Load model with ObjectLoader\n      this.loader.load(_data_config__WEBPACK_IMPORTED_MODULE_5__[\"default\"].model.path, function (gltf) {\n        // Add mesh helper if Dev\n        // if(Config.isDev && Config.mesh.enableHelper) {\n        //   new MeshHelper(this.scene, obj);\n        // }\n        // Set prop to obj so it can be accessed from outside the class\n        _this.obj = gltf.scene;\n\n        _this.obj.scale.multiplyScalar(_data_config__WEBPACK_IMPORTED_MODULE_5__[\"default\"].model.scale);\n\n        _this.scene.add(_this.obj);\n      }, _utils_helpers__WEBPACK_IMPORTED_MODULE_4__[\"default\"].logProgress(), _utils_helpers__WEBPACK_IMPORTED_MODULE_4__[\"default\"].logError());\n    }\n  }]);\n\n  return Model;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/model/model.js?");

/***/ }),

/***/ "./src/js/app/model/texture.js":
/*!*************************************!*\
  !*** ./src/js/app/model/texture.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Texture; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! es6-promise */ \"./node_modules/es6-promise/dist/es6-promise.js\");\n/* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(es6_promise__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/helpers */ \"./src/js/utils/helpers.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n // Promise polyfill for IE\n\n\n\n // This class preloads all textures in the imageFiles array in the Config via ES6 Promises.\n// Once all textures are done loading the model itself will be loaded after the Promise .then() callback.\n// Using promises to preload textures prevents issues when applying textures to materials\n// before the textures have loaded.\n\nvar Texture =\n/*#__PURE__*/\nfunction () {\n  function Texture() {\n    _classCallCheck(this, Texture);\n\n    // Prop that will contain all loaded textures\n    this.textures = {};\n  }\n\n  _createClass(Texture, [{\n    key: \"load\",\n    value: function load() {\n      var _this = this;\n\n      var loader = new three__WEBPACK_IMPORTED_MODULE_0__[\"TextureLoader\"]();\n      var maxAnisotropy = _data_config__WEBPACK_IMPORTED_MODULE_3__[\"default\"].maxAnisotropy;\n      var imageFiles = _data_config__WEBPACK_IMPORTED_MODULE_3__[\"default\"].texture.imageFiles;\n      var promiseArray = [];\n      loader.setPath(_data_config__WEBPACK_IMPORTED_MODULE_3__[\"default\"].texture.path);\n      imageFiles.forEach(function (imageFile) {\n        // Add an individual Promise for each image in array\n        promiseArray.push(new es6_promise__WEBPACK_IMPORTED_MODULE_1__[\"Promise\"](function (resolve, reject) {\n          // Each Promise will attempt to load the image file\n          loader.load(imageFile.image, // This gets called on load with the loaded texture\n          function (texture) {\n            texture.anisotropy = maxAnisotropy; // Resolve Promise with object of texture if it is instance of THREE.Texture\n\n            var modelOBJ = {};\n            modelOBJ[imageFile.name] = texture;\n            if (modelOBJ[imageFile.name] instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"]) resolve(modelOBJ);\n          }, _utils_helpers__WEBPACK_IMPORTED_MODULE_2__[\"default\"].logProgress(), function (xhr) {\n            return reject(new Error(xhr + 'An error occurred loading while loading ' + imageFile.image));\n          });\n        }));\n      }); // Iterate through all Promises in array and return another Promise when all have resolved or console log reason when any reject\n\n      return es6_promise__WEBPACK_IMPORTED_MODULE_1__[\"Promise\"].all(promiseArray).then(function (textures) {\n        // Set the textures prop object to have name be the resolved texture\n        for (var i = 0; i < textures.length; i++) {\n          _this.textures[Object.keys(textures[i])[0]] = textures[i][Object.keys(textures[i])[0]];\n        }\n      }, function (reason) {\n        return console.log(reason);\n      });\n    }\n  }]);\n\n  return Texture;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/model/texture.js?");

/***/ }),

/***/ "./src/js/data/config.js":
/*!*******************************!*\
  !*** ./src/js/data/config.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tween.js */ \"./node_modules/tween.js/src/Tween.js\");\n/* harmony import */ var tween_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tween_js__WEBPACK_IMPORTED_MODULE_0__);\n // This object contains the state of the app\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  isDev: false,\n  isShowingStats: false,\n  isLoaded: false,\n  isTweening: false,\n  isRotating: true,\n  isMouseMoving: false,\n  isMouseOver: false,\n  maxAnisotropy: 1,\n  dpr: 1,\n  easing: tween_js__WEBPACK_IMPORTED_MODULE_0___default.a.Easing.Quadratic.InOut,\n  duration: 500,\n  model: {\n    path: './assets/models/kings-place.glb',\n    scale: 10\n  },\n  texture: {\n    path: './assets/textures/',\n    imageFiles: [{\n      name: 'UV',\n      image: 'UV_Grid_Sm.jpg'\n    }]\n  },\n  mesh: {\n    enableHelper: false,\n    wireframe: false,\n    translucent: false,\n    material: {\n      color: 0xffffff,\n      emissive: 0xffffff\n    }\n  },\n  fog: {\n    color: 0xffffff,\n    near: 0.0008\n  },\n  camera: {\n    fov: 40,\n    near: 2,\n    far: 1000,\n    aspect: 1,\n    posX: 0,\n    posY: 30,\n    posZ: 40\n  },\n  controls: {\n    autoRotate: false,\n    autoRotateSpeed: -0.5,\n    rotateSpeed: 0.5,\n    zoomSpeed: 0.8,\n    minDistance: 200,\n    maxDistance: 600,\n    minPolarAngle: Math.PI / 5,\n    maxPolarAngle: Math.PI / 2,\n    minAzimuthAngle: -Infinity,\n    maxAzimuthAngle: Infinity,\n    enableDamping: true,\n    dampingFactor: 0.5,\n    enableZoom: true,\n    target: {\n      x: 0,\n      y: 0,\n      z: 0\n    }\n  },\n  ambientLight: {\n    enabled: true,\n    color: 0x141414\n  },\n  directionalLight: {\n    enabled: true,\n    color: 0xf0f0f0,\n    intensity: 0.4,\n    x: -75,\n    y: 280,\n    z: 150\n  },\n  shadow: {\n    enabled: true,\n    helperEnabled: false,\n    bias: 0,\n    mapWidth: 2048,\n    mapHeight: 2048,\n    near: 250,\n    far: 400,\n    top: 100,\n    right: 100,\n    bottom: -100,\n    left: -100\n  },\n  pointLight: {\n    enabled: true,\n    color: 0xffffff,\n    intensity: 0.34,\n    distance: 115,\n    x: 0,\n    y: 0,\n    z: 0\n  },\n  hemiLight: {\n    enabled: true,\n    color: 0xc8c8c8,\n    groundColor: 0xffffff,\n    intensity: 0.55,\n    x: 0,\n    y: 0,\n    z: 0\n  }\n});\n\n//# sourceURL=webpack:///./src/js/data/config.js?");

/***/ }),

/***/ "./src/js/lib/yuka.js":
/*!****************************!*\
  !*** ./src/js/lib/yuka.js ***!
  \****************************/
/*! exports provided: AABB, AStar, AlignmentBehavior, ArriveBehavior, BFS, BVH, BVHNode, BoundingSphere, CHFace, CHVertex, CHVertexList, Cell, CellSpacePartitioning, CohesionBehavior, CompositeGoal, ConvexHull, Corridor, CostTable, DFS, Dijkstra, Edge, EntityManager, EvadeBehavior, EventDispatcher, FleeBehavior, FollowPathBehavior, FuzzyAND, FuzzyCompositeTerm, FuzzyFAIRLY, FuzzyModule, FuzzyOR, FuzzyRule, FuzzySet, FuzzyTerm, FuzzyVERY, FuzzyVariable, GameEntity, Goal, GoalEvaluator, Graph, GraphUtils, HalfEdge, HeuristicPolicyDijkstra, HeuristicPolicyEuclid, HeuristicPolicyEuclidSquared, HeuristicPolicyManhattan, InterposeBehavior, LeftSCurveFuzzySet, LeftShoulderFuzzySet, LineSegment, Logger, MathUtils, Matrix3, Matrix4, MemoryRecord, MemorySystem, MeshGeometry, MessageDispatcher, MovingEntity, NavEdge, NavMesh, NavMeshLoader, NavNode, Node, NormalDistFuzzySet, OBB, ObstacleAvoidanceBehavior, OffsetPursuitBehavior, OnPathBehavior, Path, Plane, Polygon, Polyhedron, PriorityQueue, PursuitBehavior, Quaternion, Ray, RectangularTriggerRegion, Regulator, RightSCurveFuzzySet, RightShoulderFuzzySet, SAT, SeekBehavior, SeparationBehavior, SingletonFuzzySet, Smoother, SphericalTriggerRegion, State, StateMachine, SteeringBehavior, SteeringManager, Task, TaskQueue, Telegram, Think, Time, TriangularFuzzySet, Trigger, TriggerRegion, Vector3, Vehicle, Vision, WanderBehavior, WorldUp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AABB\", function() { return AABB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AStar\", function() { return AStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AlignmentBehavior\", function() { return AlignmentBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArriveBehavior\", function() { return ArriveBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BFS\", function() { return BFS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BVH\", function() { return BVH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BVHNode\", function() { return BVHNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundingSphere\", function() { return BoundingSphere; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CHFace\", function() { return Face; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CHVertex\", function() { return Vertex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CHVertexList\", function() { return VertexList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cell\", function() { return Cell; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CellSpacePartitioning\", function() { return CellSpacePartitioning; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CohesionBehavior\", function() { return CohesionBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompositeGoal\", function() { return CompositeGoal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConvexHull\", function() { return ConvexHull; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Corridor\", function() { return Corridor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CostTable\", function() { return CostTable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DFS\", function() { return DFS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dijkstra\", function() { return Dijkstra; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Edge\", function() { return Edge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EntityManager\", function() { return EntityManager; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EvadeBehavior\", function() { return EvadeBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventDispatcher\", function() { return EventDispatcher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FleeBehavior\", function() { return FleeBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FollowPathBehavior\", function() { return FollowPathBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FuzzyAND\", function() { return FuzzyAND; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FuzzyCompositeTerm\", function() { return FuzzyCompositeTerm; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FuzzyFAIRLY\", function() { return FuzzyFAIRLY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FuzzyModule\", function() { return FuzzyModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FuzzyOR\", function() { return FuzzyOR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FuzzyRule\", function() { return FuzzyRule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FuzzySet\", function() { return FuzzySet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FuzzyTerm\", function() { return FuzzyTerm; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FuzzyVERY\", function() { return FuzzyVERY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FuzzyVariable\", function() { return FuzzyVariable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GameEntity\", function() { return GameEntity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Goal\", function() { return Goal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GoalEvaluator\", function() { return GoalEvaluator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Graph\", function() { return Graph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GraphUtils\", function() { return GraphUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HalfEdge\", function() { return HalfEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HeuristicPolicyDijkstra\", function() { return HeuristicPolicyDijkstra; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HeuristicPolicyEuclid\", function() { return HeuristicPolicyEuclid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HeuristicPolicyEuclidSquared\", function() { return HeuristicPolicyEuclidSquared; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HeuristicPolicyManhattan\", function() { return HeuristicPolicyManhattan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterposeBehavior\", function() { return InterposeBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LeftSCurveFuzzySet\", function() { return LeftSCurveFuzzySet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LeftShoulderFuzzySet\", function() { return LeftShoulderFuzzySet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineSegment\", function() { return LineSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Logger\", function() { return Logger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MathUtils\", function() { return MathUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Matrix3\", function() { return Matrix3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Matrix4\", function() { return Matrix4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MemoryRecord\", function() { return MemoryRecord; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MemorySystem\", function() { return MemorySystem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshGeometry\", function() { return MeshGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageDispatcher\", function() { return MessageDispatcher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MovingEntity\", function() { return MovingEntity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavEdge\", function() { return NavEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavMesh\", function() { return NavMesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavMeshLoader\", function() { return NavMeshLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavNode\", function() { return NavNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Node\", function() { return Node; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NormalDistFuzzySet\", function() { return NormalDistFuzzySet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OBB\", function() { return OBB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObstacleAvoidanceBehavior\", function() { return ObstacleAvoidanceBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OffsetPursuitBehavior\", function() { return OffsetPursuitBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OnPathBehavior\", function() { return OnPathBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Path\", function() { return Path; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plane\", function() { return Plane; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Polygon\", function() { return Polygon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Polyhedron\", function() { return Polyhedron; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PriorityQueue\", function() { return PriorityQueue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PursuitBehavior\", function() { return PursuitBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Quaternion\", function() { return Quaternion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ray\", function() { return Ray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RectangularTriggerRegion\", function() { return RectangularTriggerRegion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Regulator\", function() { return Regulator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RightSCurveFuzzySet\", function() { return RightSCurveFuzzySet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RightShoulderFuzzySet\", function() { return RightShoulderFuzzySet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SAT\", function() { return SAT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SeekBehavior\", function() { return SeekBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SeparationBehavior\", function() { return SeparationBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SingletonFuzzySet\", function() { return SingletonFuzzySet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Smoother\", function() { return Smoother; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SphericalTriggerRegion\", function() { return SphericalTriggerRegion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"State\", function() { return State; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StateMachine\", function() { return StateMachine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SteeringBehavior\", function() { return SteeringBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SteeringManager\", function() { return SteeringManager; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Task\", function() { return Task; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TaskQueue\", function() { return TaskQueue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Telegram\", function() { return Telegram; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Think\", function() { return Think; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Time\", function() { return Time; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TriangularFuzzySet\", function() { return TriangularFuzzySet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Trigger\", function() { return Trigger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TriggerRegion\", function() { return TriggerRegion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector3\", function() { return Vector3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vehicle\", function() { return Vehicle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vision\", function() { return Vision; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WanderBehavior\", function() { return WanderBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WorldUp\", function() { return WorldUp; });\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * The MIT License\n * \n * Copyright  2019 Yuka authors\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n */\n\n/**\r\n* Class for representing a telegram, an envelope which contains a message\r\n* and certain metadata like sender and receiver. Part of the messaging system\r\n* for game entities.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\nvar Telegram =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new telegram object.\r\n  *\r\n  * @param {GameEntity} sender - The sender.\r\n  * @param {GameEntity} receiver - The receiver.\r\n  * @param {String} message - The actual message.\r\n  * @param {Number} delay - A time value in millisecond used to delay the message dispatching.\r\n  * @param {Object} data - An object for custom data.\r\n  */\n  function Telegram(sender, receiver, message, delay, data) {\n    _classCallCheck(this, Telegram);\n\n    /**\r\n    * The sender.\r\n    * @type GameEntity\r\n    */\n    this.sender = sender;\n    /**\r\n    * The receiver.\r\n    * @type GameEntity\r\n    */\n\n    this.receiver = receiver;\n    /**\r\n    * The actual message.\r\n    * @type String\r\n    */\n\n    this.message = message;\n    /**\r\n    * A time value in millisecond used to delay the message dispatching.\r\n    * @type Number\r\n    */\n\n    this.delay = delay;\n    /**\r\n    * An object for custom data.\r\n    * @type Object\r\n    */\n\n    this.data = data;\n  }\n  /**\r\n  * Transforms this instance into a JSON object.\r\n  *\r\n  * @return {Object} The JSON object.\r\n  */\n\n\n  _createClass(Telegram, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.constructor.name,\n        sender: this.sender ? this.sender.uuid : null,\n        receiver: this.receiver ? this.receiver.uuid : null,\n        message: this.message,\n        delay: this.delay,\n        data: this.data\n      };\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {Telegram} A reference to this telegram.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.sender = json.sender;\n      this.receiver = json.receiver;\n      this.message = json.message;\n      this.delay = json.delay;\n      this.data = json.data;\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {Telegram} A reference to this telegram.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      this.sender = entities.get(this.sender);\n      this.receiver = entities.get(this.receiver);\n      return this;\n    }\n  }]);\n\n  return Telegram;\n}();\n/* istanbul ignore next */\n\n/**\r\n* Class with a logger interface. Messages are only logged to console if\r\n* their log level is smaller or equal than the current log level.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar Logger =\n/*#__PURE__*/\nfunction () {\n  function Logger() {\n    _classCallCheck(this, Logger);\n  }\n\n  _createClass(Logger, null, [{\n    key: \"setLevel\",\n\n    /**\r\n    * Sets the log level for the logger. Allow values are: *LOG*,\r\n    * *WARN*, *ERROR*, *SILENT*. The default level is *WARN*. The constants\r\n    * are accessible over the *Logger.LEVEL* namespace.\r\n    *\r\n    * @param {Number} level - The log level.\r\n    */\n    value: function setLevel(level) {\n      currentLevel = level;\n    }\n    /**\r\n    * Logs a message with the level *LOG*.\r\n    *\r\n    * @param {...Any} args - The arguments to log.\r\n    */\n\n  }, {\n    key: \"log\",\n    value: function log() {\n      var _console;\n\n      if (currentLevel <= Logger.LEVEL.LOG) (_console = console).log.apply(_console, arguments);\n    }\n    /**\r\n    * Logs a message with the level *WARN*.\r\n    *\r\n    * @param {...Any} args - The arguments to log.\r\n    */\n\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      var _console2;\n\n      if (currentLevel <= Logger.LEVEL.WARN) (_console2 = console).warn.apply(_console2, arguments);\n    }\n    /**\r\n    * Logs a message with the level *ERROR*.\r\n    *\r\n    * @param {...Any} args - The arguments to log.\r\n    */\n\n  }, {\n    key: \"error\",\n    value: function error() {\n      var _console3;\n\n      if (currentLevel <= Logger.LEVEL.ERROR) (_console3 = console).error.apply(_console3, arguments);\n    }\n  }]);\n\n  return Logger;\n}();\n\nLogger.LEVEL = Object.freeze({\n  LOG: 0,\n  WARN: 1,\n  ERROR: 2,\n  SILENT: 3\n});\nvar currentLevel = Logger.LEVEL.WARN;\n/**\r\n* This class is the core of the messaging system for game entities and used by the\r\n* {@link EntityManager}. The implementation can directly dispatch messages or use a\r\n* delayed delivery for deferred communication. This can be useful if a game entity\r\n* wants to inform itself about a particular event in the future.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar MessageDispatcher =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new message dispatcher.\r\n  */\n  function MessageDispatcher() {\n    _classCallCheck(this, MessageDispatcher);\n\n    /**\r\n    * A list of delayed telegrams.\r\n    * @type Array\r\n    */\n    this.delayedTelegrams = new Array();\n  }\n  /**\r\n  * Delivers the message to the receiver.\r\n  *\r\n  * @param {Telegram} telegram - The telegram to deliver.\r\n  * @return {MessageDispatcher} A reference to this message dispatcher.\r\n  */\n\n\n  _createClass(MessageDispatcher, [{\n    key: \"deliver\",\n    value: function deliver(telegram) {\n      var receiver = telegram.receiver;\n\n      if (receiver.handleMessage(telegram) === false) {\n        Logger.warn('YUKA.MessageDispatcher: Message not handled by receiver: %o', receiver);\n      }\n\n      return this;\n    }\n    /**\r\n    * Receives the raw telegram data and decides how to dispatch the telegram (with or without delay).\r\n    *\r\n    * @param {GameEntity} sender - The sender.\r\n    * @param {GameEntity} receiver - The receiver.\r\n    * @param {String} message - The actual message.\r\n    * @param {Number} delay - A time value in millisecond used to delay the message dispatching.\r\n    * @param {Object} data - An object for custom data.\r\n    * @return {MessageDispatcher} A reference to this message dispatcher.\r\n    */\n\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(sender, receiver, message, delay, data) {\n      var telegram = new Telegram(sender, receiver, message, delay, data);\n\n      if (delay <= 0) {\n        this.deliver(telegram);\n      } else {\n        this.delayedTelegrams.push(telegram);\n      }\n\n      return this;\n    }\n    /**\r\n    * Used to process delayed messages.\r\n    *\r\n    * @param {Number} delta - The time delta.\r\n    * @return {MessageDispatcher} A reference to this message dispatcher.\r\n    */\n\n  }, {\n    key: \"dispatchDelayedMessages\",\n    value: function dispatchDelayedMessages(delta) {\n      var i = this.delayedTelegrams.length;\n\n      while (i--) {\n        var telegram = this.delayedTelegrams[i];\n        telegram.delay -= delta;\n\n        if (telegram.delay <= 0) {\n          this.deliver(telegram);\n          this.delayedTelegrams.pop();\n        }\n      }\n\n      return this;\n    }\n    /**\r\n    * Clears the internal state of this message dispatcher.\r\n    *\r\n    * @return {MessageDispatcher} A reference to this message dispatcher.\r\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.delayedTelegrams.length = 0;\n      return this;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var data = {\n        type: this.constructor.name,\n        delayedTelegrams: new Array()\n      }; // delayed telegrams\n\n      for (var i = 0, l = this.delayedTelegrams.length; i < l; i++) {\n        var delayedTelegram = this.delayedTelegrams[i];\n        data.delayedTelegrams.push(delayedTelegram.toJSON());\n      }\n\n      return data;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {MessageDispatcher} A reference to this message dispatcher.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.clear();\n      var telegramsJSON = json.delayedTelegrams;\n\n      for (var i = 0, l = telegramsJSON.length; i < l; i++) {\n        var telegramJSON = telegramsJSON[i];\n        var telegram = new Telegram().fromJSON(telegramJSON);\n        this.delayedTelegrams.push(telegram);\n      }\n\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {MessageDispatcher} A reference to this message dispatcher.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      var delayedTelegrams = this.delayedTelegrams;\n\n      for (var i = 0, l = delayedTelegrams.length; i < l; i++) {\n        var delayedTelegram = delayedTelegrams[i];\n        delayedTelegram.resolveReferences(entities);\n      }\n\n      return this;\n    }\n  }]);\n\n  return MessageDispatcher;\n}();\n\nvar lut = new Array();\n\nfor (var i = 0; i < 256; i++) {\n  lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n}\n/**\r\n* Class with various math helpers.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar MathUtils =\n/*#__PURE__*/\nfunction () {\n  function MathUtils() {\n    _classCallCheck(this, MathUtils);\n  }\n\n  _createClass(MathUtils, null, [{\n    key: \"clamp\",\n\n    /**\r\n    * Ensures the given scalar value is within a given min/max range.\r\n    *\r\n    * @param {Number} value - The value to clamp.\r\n    * @param {min} value - The min value.\r\n    * @param {max} value - The max value.\r\n    * @return {Number} The clamped value.\r\n    */\n    value: function clamp(value, min, max) {\n      return Math.max(min, Math.min(max, value));\n    }\n    /**\r\n    * Computes a random integer value within a given min/max range.\r\n    *\r\n    * @param {min} value - The min value.\r\n    * @param {max} value - The max value.\r\n    * @return {Number} The random integer value.\r\n    */\n\n  }, {\n    key: \"randInt\",\n    value: function randInt(min, max) {\n      return min + Math.floor(Math.random() * (max - min + 1));\n    }\n    /**\r\n    * Computes a random float value within a given min/max range.\r\n    *\r\n    * @param {min} value - The min value.\r\n    * @param {max} value - The max value.\r\n    * @return {Number} The random float value.\r\n    */\n\n  }, {\n    key: \"randFloat\",\n    value: function randFloat(min, max) {\n      return min + Math.random() * (max - min);\n    }\n    /**\r\n    * Computes the signed area of a rectangle defined by three points.\r\n    * This method can also be used to calculate the area of a triangle.\r\n    *\r\n    * @param {Vector3} a - The first point in 3D space.\r\n    * @param {Vector3} b - The second point in 3D space.\r\n    * @param {Vector3} c - The third point in 3D space.\r\n    * @return {Number} The signed area.\r\n    */\n\n  }, {\n    key: \"area\",\n    value: function area(a, b, c) {\n      return (c.x - a.x) * (b.z - a.z) - (b.x - a.x) * (c.z - a.z);\n    }\n    /**\r\n    * Computes a RFC4122 Version 4 complied Universally Unique Identifier (UUID).\r\n    *\r\n    * @return {String} The UUID.\r\n    */\n\n  }, {\n    key: \"generateUUID\",\n    value: function generateUUID() {\n      // https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/21963136#21963136\n      var d0 = Math.random() * 0xffffffff | 0;\n      var d1 = Math.random() * 0xffffffff | 0;\n      var d2 = Math.random() * 0xffffffff | 0;\n      var d3 = Math.random() * 0xffffffff | 0;\n      var uuid = lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];\n      return uuid.toUpperCase();\n    }\n  }]);\n\n  return MathUtils;\n}();\n/**\r\n* Class representing a 3D vector.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar Vector3 =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new 3D vector with the given values.\r\n  *\r\n  * @param {Number} x - The x component.\r\n  * @param {Number} y - The y component.\r\n  * @param {Number} z - The z component.\r\n  */\n  function Vector3() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, Vector3);\n\n    /**\r\n    * The x component.\r\n    * @type Number\r\n    */\n    this.x = x;\n    /**\r\n    * The y component.\r\n    * @type Number\r\n    */\n\n    this.y = y;\n    /**\r\n    * The z component.\r\n    * @type Number\r\n    */\n\n    this.z = z;\n  }\n  /**\r\n  * Sets the given values to this 3D vector.\r\n  *\r\n  * @param {Number} x - The x component.\r\n  * @param {Number} y - The y component.\r\n  * @param {Number} z - The z component.\r\n  * @return {Vector3} A reference to this vector.\r\n  */\n\n\n  _createClass(Vector3, [{\n    key: \"set\",\n    value: function set(x, y, z) {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      return this;\n    }\n    /**\r\n    * Copies all values from the given 3D vector to this 3D vector.\r\n    *\r\n    * @param {Vector3} v - The vector to copy.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"copy\",\n    value: function copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      return this;\n    }\n    /**\r\n    * Creates a new 3D vector and copies all values from this 3D vector.\r\n    *\r\n    * @return {Vector3} A new 3D vector.\r\n    */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\r\n    * Adds the given 3D vector to this 3D vector.\r\n    *\r\n    * @param {Vector3} v - The vector to add.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"add\",\n    value: function add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      return this;\n    }\n    /**\r\n    * Adds the given scalar to this 3D vector.\r\n    *\r\n    * @param {Number} s - The scalar to add.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"addScalar\",\n    value: function addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      return this;\n    }\n    /**\r\n    * Adds two given 3D vectors and stores the result in this 3D vector.\r\n    *\r\n    * @param {Vector3} a - The first vector of the operation.\r\n    * @param {Vector3} b - The second vector of the operation.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"addVectors\",\n    value: function addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      return this;\n    }\n    /**\r\n    * Subtracts the given 3D vector from this 3D vector.\r\n    *\r\n    * @param {Vector3} v - The vector to substract.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"sub\",\n    value: function sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      return this;\n    }\n    /**\r\n    * Subtracts the given scalar from this 3D vector.\r\n    *\r\n    * @param {Number} s - The scalar to substract.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"subScalar\",\n    value: function subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      return this;\n    }\n    /**\r\n    * Subtracts two given 3D vectors and stores the result in this 3D vector.\r\n    *\r\n    * @param {Vector3} a - The first vector of the operation.\r\n    * @param {Vector3} b - The second vector of the operation.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"subVectors\",\n    value: function subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      return this;\n    }\n    /**\r\n    * Multiplies the given 3D vector with this 3D vector.\r\n    *\r\n    * @param {Vector3} v - The vector to multiply.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"multiply\",\n    value: function multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      return this;\n    }\n    /**\r\n    * Multiplies the given scalar with this 3D vector.\r\n    *\r\n    * @param {Number} s - The scalar to multiply.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"multiplyScalar\",\n    value: function multiplyScalar(s) {\n      this.x *= s;\n      this.y *= s;\n      this.z *= s;\n      return this;\n    }\n    /**\r\n    * Multiplies two given 3D vectors and stores the result in this 3D vector.\r\n    *\r\n    * @param {Vector3} a - The first vector of the operation.\r\n    * @param {Vector3} b - The second vector of the operation.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"multiplyVectors\",\n    value: function multiplyVectors(a, b) {\n      this.x = a.x * b.x;\n      this.y = a.y * b.y;\n      this.z = a.z * b.z;\n      return this;\n    }\n    /**\r\n    * Divides the given 3D vector through this 3D vector.\r\n    *\r\n    * @param {Vector3} v - The vector to divide.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"divide\",\n    value: function divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      return this;\n    }\n    /**\r\n    * Divides the given scalar through this 3D vector.\r\n    *\r\n    * @param {Number} s - The scalar to multiply.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"divideScalar\",\n    value: function divideScalar(s) {\n      this.x /= s;\n      this.y /= s;\n      this.z /= s;\n      return this;\n    }\n    /**\r\n    * Divides two given 3D vectors and stores the result in this 3D vector.\r\n    *\r\n    * @param {Vector3} a - The first vector of the operation.\r\n    * @param {Vector3} b - The second vector of the operation.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"divideVectors\",\n    value: function divideVectors(a, b) {\n      this.x = a.x / b.x;\n      this.y = a.y / b.y;\n      this.z = a.z / b.z;\n      return this;\n    }\n    /**\r\n    * Reflects this vector along the given normal.\r\n    *\r\n    * @param {Vector3} normal - The normal vector.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"reflect\",\n    value: function reflect(normal) {\n      // solve r = v - 2( v * n ) * n\n      return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));\n    }\n    /**\r\n    * Ensures this 3D vector lies in the given min/max range.\r\n    *\r\n    * @param {Vector3} min - The min range.\r\n    * @param {Vector3} max - The max range.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"clamp\",\n    value: function clamp(min, max) {\n      this.x = Math.max(min.x, Math.min(max.x, this.x));\n      this.y = Math.max(min.y, Math.min(max.y, this.y));\n      this.z = Math.max(min.z, Math.min(max.z, this.z));\n      return this;\n    }\n    /**\r\n    * Compares each vector component of this 3D vector and the\r\n    * given one and stores the minimum value in this instance.\r\n    *\r\n    * @param {Vector3} v - The 3D vector to check.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"min\",\n    value: function min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      return this;\n    }\n    /**\r\n    * Compares each vector component of this 3D vector and the\r\n    * given one and stores the maximum value in this instance.\r\n    *\r\n    * @param {Vector3} v - The 3D vector to check.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"max\",\n    value: function max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      return this;\n    }\n    /**\r\n    * Computes the dot product of this and the given 3D vector.\r\n    *\r\n    * @param {Vector3} v - The given 3D vector.\r\n    * @return {Number} The results of the dor product.\r\n    */\n\n  }, {\n    key: \"dot\",\n    value: function dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    /**\r\n    * Computes the cross product of this and the given 3D vector and\r\n    * stores the result in this 3D vector.\r\n    *\r\n    * @param {Vector3} v - A 3D vector.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"cross\",\n    value: function cross(v) {\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      this.x = y * v.z - z * v.y;\n      this.y = z * v.x - x * v.z;\n      this.z = x * v.y - y * v.x;\n      return this;\n    }\n    /**\r\n    * Computes the cross product of the two given 3D vectors and\r\n    * stores the result in this 3D vector.\r\n    *\r\n    * @param {Vector3} a - The first 3D vector.\r\n    * @param {Vector3} b - The second 3D vector.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"crossVectors\",\n    value: function crossVectors(a, b) {\n      var ax = a.x,\n          ay = a.y,\n          az = a.z;\n      var bx = b.x,\n          by = b.y,\n          bz = b.z;\n      this.x = ay * bz - az * by;\n      this.y = az * bx - ax * bz;\n      this.z = ax * by - ay * bx;\n      return this;\n    }\n    /**\r\n    * Computes the angle between this and the given vector.\r\n    *\r\n    * @param {Vector3} v - A 3D vector.\r\n    * @return {Number} The angle in radians.\r\n    */\n\n  }, {\n    key: \"angleTo\",\n    value: function angleTo(v) {\n      var denominator = Math.sqrt(this.squaredLength() * v.squaredLength());\n      if (denominator === 0) return 0;\n      var theta = this.dot(v) / denominator; // clamp, to handle numerical problems\n\n      return Math.acos(MathUtils.clamp(theta, -1, 1));\n    }\n    /**\r\n    * Computes the length of this 3D vector.\r\n    *\r\n    * @return {Number} The length of this 3D vector.\r\n    */\n\n  }, {\n    key: \"length\",\n    value: function length() {\n      return Math.sqrt(this.squaredLength());\n    }\n    /**\r\n    * Computes the squared length of this 3D vector.\r\n    * Calling this method is faster than calling {@link Vector3#length},\r\n    * since it avoids computing a square root.\r\n    *\r\n    * @return {Number} The squared length of this 3D vector.\r\n    */\n\n  }, {\n    key: \"squaredLength\",\n    value: function squaredLength() {\n      return this.dot(this);\n    }\n    /**\r\n    * Computes the manhattan length of this 3D vector.\r\n    *\r\n    * @return {Number} The manhattan length of this 3D vector.\r\n    */\n\n  }, {\n    key: \"manhattanLength\",\n    value: function manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n    }\n    /**\r\n    * Computes the euclidean distance between this 3D vector and the given one.\r\n    *\r\n    * @param {Vector3} v - A 3D vector.\r\n    * @return {Number} The euclidean distance between two 3D vectors.\r\n    */\n\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(v) {\n      return Math.sqrt(this.squaredDistanceTo(v));\n    }\n    /**\r\n    * Computes the squared euclidean distance between this 3D vector and the given one.\r\n    * Calling this method is faster than calling {@link Vector3#distanceTo},\r\n    * since it avoids computing a square root.\r\n    *\r\n    * @param {Vector3} v - A 3D vector.\r\n    * @return {Number} The squared euclidean distance between two 3D vectors.\r\n    */\n\n  }, {\n    key: \"squaredDistanceTo\",\n    value: function squaredDistanceTo(v) {\n      var dx = this.x - v.x,\n          dy = this.y - v.y,\n          dz = this.z - v.z;\n      return dx * dx + dy * dy + dz * dz;\n    }\n    /**\r\n    * Computes the manhattan distance between this 3D vector and the given one.\r\n    *\r\n    * @param {Vector3} v - A 3D vector.\r\n    * @return {Number} The manhattan distance between two 3D vectors.\r\n    */\n\n  }, {\n    key: \"manhattanDistanceTo\",\n    value: function manhattanDistanceTo(v) {\n      var dx = this.x - v.x,\n          dy = this.y - v.y,\n          dz = this.z - v.z;\n      return Math.abs(dx) + Math.abs(dy) + Math.abs(dz);\n    }\n    /**\r\n    * Normalizes this 3D vector.\r\n    *\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    /**\r\n    * Multiplies the given 4x4 matrix with this 3D vector\r\n    *\r\n    * @param {Matrix4} m - A 4x4 matrix.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"applyMatrix4\",\n    value: function applyMatrix4(m) {\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      var e = m.elements;\n      var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n      return this;\n    }\n    /**\r\n    * Multiplies the given quaternion with this 3D vector.\r\n    *\r\n    * @param {Quaternion} q - A quaternion.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"applyRotation\",\n    value: function applyRotation(q) {\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      var qx = q.x,\n          qy = q.y,\n          qz = q.z,\n          qw = q.w; // calculate quat * vector\n\n      var ix = qw * x + qy * z - qz * y;\n      var iy = qw * y + qz * x - qx * z;\n      var iz = qw * z + qx * y - qy * x;\n      var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n      return this;\n    }\n    /**\r\n    * Extracts the position portion of the given 4x4 matrix and stores it in this 3D vector.\r\n    *\r\n    * @param {Matrix4} m - A 4x4 matrix.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"extractPositionFromMatrix\",\n    value: function extractPositionFromMatrix(m) {\n      var e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      return this;\n    }\n    /**\r\n    * Transform this direction vector by the given 4x4 matrix.\r\n    *\r\n    * @param {Matrix4} m - A 4x4 matrix.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"transformDirection\",\n    value: function transformDirection(m) {\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      var e = m.elements;\n      this.x = e[0] * x + e[4] * y + e[8] * z;\n      this.y = e[1] * x + e[5] * y + e[9] * z;\n      this.z = e[2] * x + e[6] * y + e[10] * z;\n      return this.normalize();\n    }\n    /**\r\n    * Sets the components of this 3D vector from a column of a 3x3 matrix.\r\n    *\r\n    * @param {Matrix3} m - A 3x3 matrix.\r\n    * @param {Number} i - The index of the column.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"fromMatrix3Column\",\n    value: function fromMatrix3Column(m, i) {\n      return this.fromArray(m.elements, i * 3);\n    }\n    /**\r\n    * Sets the components of this 3D vector from a column of a 4x4 matrix.\r\n    *\r\n    * @param {Matrix3} m - A 4x4 matrix.\r\n    * @param {Number} i - The index of the column.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"fromMatrix4Column\",\n    value: function fromMatrix4Column(m, i) {\n      return this.fromArray(m.elements, i * 4);\n    }\n    /**\r\n    * Sets the components of this 3D vector from a spherical coordinate.\r\n    *\r\n    * @param {Number} radius - The radius.\r\n    * @param {Number} phi - The polar or inclination angle in radians. Should be in the range of (/2, +/2].\r\n    * @param {Number} theta - The azimuthal angle in radians. Should be in the range of (, +].\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"fromSpherical\",\n    value: function fromSpherical(radius, phi, theta) {\n      var sinPhiRadius = Math.sin(phi) * radius;\n      this.x = sinPhiRadius * Math.sin(theta);\n      this.y = Math.cos(phi) * radius;\n      this.z = sinPhiRadius * Math.cos(theta);\n      return this;\n    }\n    /**\r\n    * Sets the components of this 3D vector from an array.\r\n    *\r\n    * @param {Array} array - An array.\r\n    * @param {Number} offset - An optional offset.\r\n    * @return {Vector3} A reference to this vector.\r\n    */\n\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.x = array[offset + 0];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      return this;\n    }\n    /**\r\n    * Copies all values of this 3D vector to the given array.\r\n    *\r\n    * @param {Array} array - An array.\r\n    * @param {Number} offset - An optional offset.\r\n    * @return {Array} The array with the 3D vector components.\r\n    */\n\n  }, {\n    key: \"toArray\",\n    value: function toArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      array[offset + 0] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      return array;\n    }\n    /**\r\n    * Returns true if the given 3D vector is deep equal with this 3D vector.\r\n    *\r\n    * @param {Vector3} v - The 3D vector to test.\r\n    * @return {Boolean} The result of the equality test.\r\n    */\n\n  }, {\n    key: \"equals\",\n    value: function equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z;\n    }\n  }]);\n\n  return Vector3;\n}();\n\nvar v1 = new Vector3();\nvar WorldUp = new Vector3(0, 1, 0);\nvar localRight = new Vector3();\nvar worldRight = new Vector3();\nvar perpWorldUp = new Vector3();\nvar temp = new Vector3();\nvar colVal = [2, 2, 1];\nvar rowVal = [1, 0, 0];\n/**\r\n* Class representing a 3x3 matrix. The elements of the matrix\r\n* are stored in column-major order.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar Matrix3 =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new 3x3 identity matrix.\r\n  */\n  function Matrix3() {\n    _classCallCheck(this, Matrix3);\n\n    /**\r\n    * The elements of the matrix in column-major order.\r\n    * @type Array\r\n    */\n    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n  /**\r\n  * Sets the given values to this matrix. The arguments are in row-major order.\r\n  *\r\n  * @param {Number} n11 - An element of the matrix.\r\n  * @param {Number} n12 - An element of the matrix.\r\n  * @param {Number} n13 - An element of the matrix.\r\n  * @param {Number} n21 - An element of the matrix.\r\n  * @param {Number} n22 - An element of the matrix.\r\n  * @param {Number} n23 - An element of the matrix.\r\n  * @param {Number} n31 - An element of the matrix.\r\n  * @param {Number} n32 - An element of the matrix.\r\n  * @param {Number} n33 - An element of the matrix.\r\n  * @return {Matrix3} A reference to this matrix.\r\n  */\n\n\n  _createClass(Matrix3, [{\n    key: \"set\",\n    value: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      var e = this.elements;\n      e[0] = n11;\n      e[3] = n12;\n      e[6] = n13;\n      e[1] = n21;\n      e[4] = n22;\n      e[7] = n23;\n      e[2] = n31;\n      e[5] = n32;\n      e[8] = n33;\n      return this;\n    }\n    /**\r\n    * Copies all values from the given matrix to this matrix.\r\n    *\r\n    * @param {Matrix3} m - The matrix to copy.\r\n    * @return {Matrix3} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"copy\",\n    value: function copy(m) {\n      var e = this.elements;\n      var me = m.elements;\n      e[0] = me[0];\n      e[1] = me[1];\n      e[2] = me[2];\n      e[3] = me[3];\n      e[4] = me[4];\n      e[5] = me[5];\n      e[6] = me[6];\n      e[7] = me[7];\n      e[8] = me[8];\n      return this;\n    }\n    /**\r\n    * Creates a new matrix and copies all values from this matrix.\r\n    *\r\n    * @return {Matrix3} A new matrix.\r\n    */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\r\n    * Transforms this matrix to an identity matrix.\r\n    *\r\n    * @return {Matrix3} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"identity\",\n    value: function identity() {\n      this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n      return this;\n    }\n    /**\r\n    * Multiplies this matrix with the given matrix.\r\n    *\r\n    * @param {Matrix3} m - The matrix to multiply.\r\n    * @return {Matrix3} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"multiply\",\n    value: function multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    /**\r\n    * Multiplies this matrix with the given matrix.\r\n    * So the order of the multiplication is switched compared to {@link Matrix3#multiply}.\r\n    *\r\n    * @param {Matrix3} m - The matrix to multiply.\r\n    * @return {Matrix3} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"premultiply\",\n    value: function premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    /**\r\n    * Multiplies two given matrices and stores the result in this matrix.\r\n    *\r\n    * @param {Matrix3} a - The first matrix of the operation.\r\n    * @param {Matrix3} b - The second matrix of the operation.\r\n    * @return {Matrix3} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"multiplyMatrices\",\n    value: function multiplyMatrices(a, b) {\n      var ae = a.elements;\n      var be = b.elements;\n      var e = this.elements;\n      var a11 = ae[0],\n          a12 = ae[3],\n          a13 = ae[6];\n      var a21 = ae[1],\n          a22 = ae[4],\n          a23 = ae[7];\n      var a31 = ae[2],\n          a32 = ae[5],\n          a33 = ae[8];\n      var b11 = be[0],\n          b12 = be[3],\n          b13 = be[6];\n      var b21 = be[1],\n          b22 = be[4],\n          b23 = be[7];\n      var b31 = be[2],\n          b32 = be[5],\n          b33 = be[8];\n      e[0] = a11 * b11 + a12 * b21 + a13 * b31;\n      e[3] = a11 * b12 + a12 * b22 + a13 * b32;\n      e[6] = a11 * b13 + a12 * b23 + a13 * b33;\n      e[1] = a21 * b11 + a22 * b21 + a23 * b31;\n      e[4] = a21 * b12 + a22 * b22 + a23 * b32;\n      e[7] = a21 * b13 + a22 * b23 + a23 * b33;\n      e[2] = a31 * b11 + a32 * b21 + a33 * b31;\n      e[5] = a31 * b12 + a32 * b22 + a33 * b32;\n      e[8] = a31 * b13 + a32 * b23 + a33 * b33;\n      return this;\n    }\n    /**\r\n    * Multiplies the given scalar with this matrix.\r\n    *\r\n    * @param {Number} s - The scalar to multiply.\r\n    * @return {Matrix3} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"multiplyScalar\",\n    value: function multiplyScalar(s) {\n      var e = this.elements;\n      e[0] *= s;\n      e[3] *= s;\n      e[6] *= s;\n      e[1] *= s;\n      e[4] *= s;\n      e[7] *= s;\n      e[2] *= s;\n      e[5] *= s;\n      e[8] *= s;\n      return this;\n    }\n    /**\r\n    * Extracts the basis vectors and stores them to the given vectors.\r\n    *\r\n    * @param {Vector3} xAxis - The first result vector for the x-axis.\r\n    * @param {Vector3} yAxis - The second result vector for the y-axis.\r\n    * @param {Vector3} zAxis - The third result vector for the z-axis.\r\n    * @return {Matrix3} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"extractBasis\",\n    value: function extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.fromMatrix3Column(this, 0);\n      yAxis.fromMatrix3Column(this, 1);\n      zAxis.fromMatrix3Column(this, 2);\n      return this;\n    }\n    /**\r\n    * Makes a basis from the given vectors.\r\n    *\r\n    * @param {Vector3} xAxis - The first basis vector for the x-axis.\r\n    * @param {Vector3} yAxis - The second basis vector for the y-axis.\r\n    * @param {Vector3} zAxis - The third basis vector for the z-axis.\r\n    * @return {Matrix3} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"makeBasis\",\n    value: function makeBasis(xAxis, yAxis, zAxis) {\n      this.set(xAxis.x, yAxis.x, zAxis.x, xAxis.y, yAxis.y, zAxis.y, xAxis.z, yAxis.z, zAxis.z);\n      return this;\n    }\n    /**\r\n    * Creates a rotation matrix that orients an object to face towards a specified target direction.\r\n    *\r\n    * @param {Vector3} localForward - Specifies the forward direction in the local space of the object.\r\n    * @param {Vector3} targetDirection - Specifies the desired world space direction the object should look at.\r\n    * @param {Vector3} localUp - Specifies the up direction in the local space of the object.\r\n    * @return {Matrix3} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"lookAt\",\n    value: function lookAt(localForward, targetDirection, localUp) {\n      localRight.crossVectors(localUp, localForward).normalize(); // orthonormal linear basis A { localRight, localUp, localForward } for the object local space\n\n      worldRight.crossVectors(WorldUp, targetDirection).normalize();\n\n      if (worldRight.squaredLength() === 0) {\n        // handle case when it's not possible to build a basis from targetDirection and worldUp\n        // slightly shift targetDirection in order to avoid collinearity\n        temp.copy(targetDirection).addScalar(Number.EPSILON);\n        worldRight.crossVectors(WorldUp, temp).normalize();\n      }\n\n      perpWorldUp.crossVectors(targetDirection, worldRight).normalize(); // orthonormal linear basis B { worldRight, perpWorldUp, targetDirection } for the desired target orientation\n\n      m1.makeBasis(worldRight, perpWorldUp, targetDirection);\n      m2.makeBasis(localRight, localUp, localForward); // construct a matrix that maps basis A to B\n\n      this.multiplyMatrices(m1, m2.transpose());\n      return this;\n    }\n    /**\r\n    * Transposes this matrix.\r\n    *\r\n    * @return {Matrix3} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"transpose\",\n    value: function transpose() {\n      var e = this.elements;\n      var t;\n      t = e[1];\n      e[1] = e[3];\n      e[3] = t;\n      t = e[2];\n      e[2] = e[6];\n      e[6] = t;\n      t = e[5];\n      e[5] = e[7];\n      e[7] = t;\n      return this;\n    }\n    /**\r\n    * Computes the element index according to the given column and row.\r\n    *\r\n    * @param {Number} column - Index of the column.\r\n    * @param {Number} row - Index of the row.\r\n    * @return {Number} The index of the element at the provided row and column.\r\n    */\n\n  }, {\n    key: \"getElementIndex\",\n    value: function getElementIndex(column, row) {\n      return column * 3 + row;\n    }\n    /**\r\n    * Computes the frobenius norm. It's the squareroot of the sum of all\r\n    * squared matrix elements.\r\n    *\r\n    * @return {Number} The frobenius norm.\r\n    */\n\n  }, {\n    key: \"frobeniusNorm\",\n    value: function frobeniusNorm() {\n      var e = this.elements;\n      var norm = 0;\n\n      for (var _i = 0; _i < 9; _i++) {\n        norm += e[_i] * e[_i];\n      }\n\n      return Math.sqrt(norm);\n    }\n    /**\r\n    * Computes the  \"off-diagonal\" frobenius norm. Assumes the matrix is symmetric.\r\n    *\r\n    * @return {Number} The \"off-diagonal\" frobenius norm.\r\n    */\n\n  }, {\n    key: \"offDiagonalFrobeniusNorm\",\n    value: function offDiagonalFrobeniusNorm() {\n      var e = this.elements;\n      var norm = 0;\n\n      for (var _i2 = 0; _i2 < 3; _i2++) {\n        var _t = e[this.getElementIndex(colVal[_i2], rowVal[_i2])];\n        norm += 2 * _t * _t; // multiply the result by two since the matrix is symetric\n      }\n\n      return Math.sqrt(norm);\n    }\n    /**\r\n    * Computes the eigenvectors and eigenvalues.\r\n    *\r\n    * Reference: https://github.com/AnalyticalGraphicsInc/cesium/blob/411a1afbd36b72df64d7362de6aa934730447234/Source/Core/Matrix3.js#L1141 (Apache License 2.0)\r\n    *\r\n    * The values along the diagonal of the diagonal matrix are the eigenvalues.\r\n    * The columns of the unitary matrix are the corresponding eigenvectors.\r\n    *\r\n    * @param {Object} result - An object with unitary and diagonal properties which are matrices onto which to store the result.\r\n    * @return {Object} An object with unitary and diagonal properties which are matrices onto which to store the result.\r\n    */\n\n  }, {\n    key: \"eigenDecomposition\",\n    value: function eigenDecomposition(result) {\n      var count = 0;\n      var sweep = 0;\n      var maxSweeps = 10;\n      result.unitary.identity();\n      result.diagonal.copy(this);\n      var unitaryMatrix = result.unitary;\n      var diagonalMatrix = result.diagonal;\n      var epsilon = Number.EPSILON * diagonalMatrix.frobeniusNorm();\n\n      while (sweep < maxSweeps && diagonalMatrix.offDiagonalFrobeniusNorm() > epsilon) {\n        diagonalMatrix.shurDecomposition(m1);\n        m2.copy(m1).transpose();\n        diagonalMatrix.multiply(m1);\n        diagonalMatrix.premultiply(m2);\n        unitaryMatrix.multiply(m1);\n\n        if (++count > 2) {\n          sweep++;\n          count = 0;\n        }\n      }\n\n      return result;\n    }\n    /**\r\n    * Finds the largest off-diagonal term and then creates a matrix\r\n    * which can be used to help reduce it.\r\n    *\r\n    * @param {Matrix3} result - The result matrix.\r\n    * @return {Matrix3} The result matrix.\r\n    */\n\n  }, {\n    key: \"shurDecomposition\",\n    value: function shurDecomposition(result) {\n      var maxDiagonal = 0;\n      var rotAxis = 1; // find pivot (rotAxis) based on largest off-diagonal term\n\n      var e = this.elements;\n\n      for (var _i3 = 0; _i3 < 3; _i3++) {\n        var _t2 = Math.abs(e[this.getElementIndex(colVal[_i3], rowVal[_i3])]);\n\n        if (_t2 > maxDiagonal) {\n          maxDiagonal = _t2;\n          rotAxis = _i3;\n        }\n      }\n\n      var c = 1;\n      var s = 0;\n      var p = rowVal[rotAxis];\n      var q = colVal[rotAxis];\n\n      if (Math.abs(e[this.getElementIndex(q, p)]) > Number.EPSILON) {\n        var qq = e[this.getElementIndex(q, q)];\n        var pp = e[this.getElementIndex(p, p)];\n        var qp = e[this.getElementIndex(q, p)];\n        var tau = (qq - pp) / 2 / qp;\n\n        var _t3;\n\n        if (tau < 0) {\n          _t3 = -1 / (-tau + Math.sqrt(1 + tau * tau));\n        } else {\n          _t3 = 1 / (tau + Math.sqrt(1.0 + tau * tau));\n        }\n\n        c = 1.0 / Math.sqrt(1.0 + _t3 * _t3);\n        s = _t3 * c;\n      }\n\n      result.identity();\n      result.elements[this.getElementIndex(p, p)] = c;\n      result.elements[this.getElementIndex(q, q)] = c;\n      result.elements[this.getElementIndex(q, p)] = s;\n      result.elements[this.getElementIndex(p, q)] = -s;\n      return result;\n    }\n    /**\r\n    * Creates a rotation matrix from the given quaternion.\r\n    *\r\n    * @param {Quaternion} q - A quaternion representing a rotation.\r\n    * @return {Matrix3} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"fromQuaternion\",\n    value: function fromQuaternion(q) {\n      var e = this.elements;\n      var x = q.x,\n          y = q.y,\n          z = q.z,\n          w = q.w;\n      var x2 = x + x,\n          y2 = y + y,\n          z2 = z + z;\n      var xx = x * x2,\n          xy = x * y2,\n          xz = x * z2;\n      var yy = y * y2,\n          yz = y * z2,\n          zz = z * z2;\n      var wx = w * x2,\n          wy = w * y2,\n          wz = w * z2;\n      e[0] = 1 - (yy + zz);\n      e[3] = xy - wz;\n      e[6] = xz + wy;\n      e[1] = xy + wz;\n      e[4] = 1 - (xx + zz);\n      e[7] = yz - wx;\n      e[2] = xz - wy;\n      e[5] = yz + wx;\n      e[8] = 1 - (xx + yy);\n      return this;\n    }\n    /**\r\n    * Sets the elements of this matrix by extracting the upper-left 3x3 portion\r\n    * from a 4x4 matrix.\r\n    *\r\n    * @param {Matrix4} m - A 4x4 matrix.\r\n    * @return {Matrix3} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"fromMatrix4\",\n    value: function fromMatrix4(m) {\n      var e = this.elements;\n      var me = m.elements;\n      e[0] = me[0];\n      e[1] = me[1];\n      e[2] = me[2];\n      e[3] = me[4];\n      e[4] = me[5];\n      e[5] = me[6];\n      e[6] = me[8];\n      e[7] = me[9];\n      e[8] = me[10];\n      return this;\n    }\n    /**\r\n    * Sets the elements of this matrix from an array.\r\n    *\r\n    * @param {Array} array - An array.\r\n    * @param {Number} offset - An optional offset.\r\n    * @return {Matrix3} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var e = this.elements;\n\n      for (var _i4 = 0; _i4 < 9; _i4++) {\n        e[_i4] = array[_i4 + offset];\n      }\n\n      return this;\n    }\n    /**\r\n    * Copies all elements of this matrix to the given array.\r\n    *\r\n    * @param {Array} array - An array.\r\n    * @param {Number} offset - An optional offset.\r\n    * @return {Array} The array with the elements of the matrix.\r\n    */\n\n  }, {\n    key: \"toArray\",\n    value: function toArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var e = this.elements;\n      array[offset + 0] = e[0];\n      array[offset + 1] = e[1];\n      array[offset + 2] = e[2];\n      array[offset + 3] = e[3];\n      array[offset + 4] = e[4];\n      array[offset + 5] = e[5];\n      array[offset + 6] = e[6];\n      array[offset + 7] = e[7];\n      array[offset + 8] = e[8];\n      return array;\n    }\n    /**\r\n    * Returns true if the given matrix is deep equal with this matrix.\r\n    *\r\n    * @param {Matrix3} m - The matrix to test.\r\n    * @return {Boolean} The result of the equality test.\r\n    */\n\n  }, {\n    key: \"equals\",\n    value: function equals(m) {\n      var e = this.elements;\n      var me = m.elements;\n\n      for (var _i5 = 0; _i5 < 9; _i5++) {\n        if (e[_i5] !== me[_i5]) return false;\n      }\n\n      return true;\n    }\n  }]);\n\n  return Matrix3;\n}();\n\nvar m1 = new Matrix3();\nvar m2 = new Matrix3();\nvar matrix = new Matrix3();\nvar vector = new Vector3();\n/**\r\n* Class representing a quaternion.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar Quaternion =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new quaternion with the given values.\r\n  *\r\n  * @param {Number} x - The x component.\r\n  * @param {Number} y - The y component.\r\n  * @param {Number} z - The z component.\r\n  * @param {Number} w - The w component.\r\n  */\n  function Quaternion() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    _classCallCheck(this, Quaternion);\n\n    /**\r\n    * The x component.\r\n    * @type Number\r\n    */\n    this.x = x;\n    /**\r\n    * The y component.\r\n    * @type Number\r\n    */\n\n    this.y = y;\n    /**\r\n    * The z component.\r\n    * @type Number\r\n    */\n\n    this.z = z;\n    /**\r\n    * The w component.\r\n    * @type Number\r\n    */\n\n    this.w = w;\n  }\n  /**\r\n  * Sets the given values to this quaternion.\r\n  *\r\n  * @param {Number} x - The x component.\r\n  * @param {Number} y - The y component.\r\n  * @param {Number} z - The z component.\r\n  * @param {Number} w - The w component.\r\n  * @return {Quaternion} A reference to this quaternion.\r\n  */\n\n\n  _createClass(Quaternion, [{\n    key: \"set\",\n    value: function set(x, y, z, w) {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n      return this;\n    }\n    /**\r\n    * Copies all values from the given quaternion to this quaternion.\r\n    *\r\n    * @param {Quaternion} q - The quaternion to copy.\r\n    * @return {Quaternion} A reference to this quaternion.\r\n    */\n\n  }, {\n    key: \"copy\",\n    value: function copy(q) {\n      this.x = q.x;\n      this.y = q.y;\n      this.z = q.z;\n      this.w = q.w;\n      return this;\n    }\n    /**\r\n    * Creates a new quaternion and copies all values from this quaternion.\r\n    *\r\n    * @return {Quaternion} A new quaternion.\r\n    */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\r\n    * Computes the inverse of this quaternion.\r\n    *\r\n    * @return {Quaternion} A reference to this quaternion.\r\n    */\n\n  }, {\n    key: \"inverse\",\n    value: function inverse() {\n      return this.conjugate().normalize();\n    }\n    /**\r\n    * Computes the conjugate of this quaternion.\r\n    *\r\n    * @return {Quaternion} A reference to this quaternion.\r\n    */\n\n  }, {\n    key: \"conjugate\",\n    value: function conjugate() {\n      this.x *= -1;\n      this.y *= -1;\n      this.z *= -1;\n      return this;\n    }\n    /**\r\n    * Computes the dot product of this and the given quaternion.\r\n    *\r\n    * @param {Quaternion} q - The given quaternion.\r\n    * @return {Quaternion} A reference to this quaternion.\r\n    */\n\n  }, {\n    key: \"dot\",\n    value: function dot(q) {\n      return this.x * q.x + this.y * q.y + this.z * q.z + this.w * q.w;\n    }\n    /**\r\n    * Computes the length of this quaternion.\r\n    *\r\n    * @return {Number} The length of this quaternion.\r\n    */\n\n  }, {\n    key: \"length\",\n    value: function length() {\n      return Math.sqrt(this.squaredLength());\n    }\n    /**\r\n    * Computes the squared length of this quaternion.\r\n    *\r\n    * @return {Number} The squared length of this quaternion.\r\n    */\n\n  }, {\n    key: \"squaredLength\",\n    value: function squaredLength() {\n      return this.dot(this);\n    }\n    /**\r\n    * Normalizes this quaternion.\r\n    *\r\n    * @return {Quaternion} A reference to this quaternion.\r\n    */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var l = this.length();\n\n      if (l === 0) {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 1;\n      } else {\n        l = 1 / l;\n        this.x = this.x * l;\n        this.y = this.y * l;\n        this.z = this.z * l;\n        this.w = this.w * l;\n      }\n\n      return this;\n    }\n    /**\r\n    * Multiplies this quaternion with the given quaternion.\r\n    *\r\n    * @param {Quaternion} q - The quaternion to multiply.\r\n    * @return {Quaternion} A reference to this quaternion.\r\n    */\n\n  }, {\n    key: \"multiply\",\n    value: function multiply(q) {\n      return this.multiplyQuaternions(this, q);\n    }\n    /**\r\n    * Multiplies the given quaternion with this quaternion.\r\n    * So the order of the multiplication is switched compared to {@link Quaternion#multiply}.\r\n    *\r\n    * @param {Quaternion} q - The quaternion to multiply.\r\n    * @return {Quaternion} A reference to this quaternion.\r\n    */\n\n  }, {\n    key: \"premultiply\",\n    value: function premultiply(q) {\n      return this.multiplyQuaternions(q, this);\n    }\n    /**\r\n    * Multiplies two given quaternions and stores the result in this quaternion.\r\n    *\r\n    * @param {Quaternion} a - The first quaternion of the operation.\r\n    * @param {Quaternion} b - The second quaternion of the operation.\r\n    * @return {Quaternion} A reference to this quaternion.\r\n    */\n\n  }, {\n    key: \"multiplyQuaternions\",\n    value: function multiplyQuaternions(a, b) {\n      var qax = a.x,\n          qay = a.y,\n          qaz = a.z,\n          qaw = a.w;\n      var qbx = b.x,\n          qby = b.y,\n          qbz = b.z,\n          qbw = b.w;\n      this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n      this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n      this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n      this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n      return this;\n    }\n    /**\r\n    * Computes the shortest angle between two rotation defined by this quaternion and the given one.\r\n    *\r\n    * @param {Quaternion} q - The given quaternion.\r\n    * @return {Number} The angle in radians.\r\n    */\n\n  }, {\n    key: \"angleTo\",\n    value: function angleTo(q) {\n      return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));\n    }\n    /**\r\n    * Transforms this rotation defined by this quaternion towards the target rotation\r\n    * defined by the given quaternion by the given angular step. The rotation will not overshoot.\r\n    *\r\n    * @param {Quaternion} q - The target rotation.\r\n    * @param {Number} step - The maximum step in radians.\r\n    * @param {Number} tolerance - A tolerance value in radians to tweak the result\r\n    * when both rotations are considered to be equal.\r\n    * @return {Boolean} Whether the given quaternion already represents the target rotation.\r\n    */\n\n  }, {\n    key: \"rotateTo\",\n    value: function rotateTo(q, step) {\n      var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0001;\n      var angle = this.angleTo(q);\n      if (angle < tolerance) return true;\n      var t = Math.min(1, step / angle);\n      this.slerp(q, t);\n      return false;\n    }\n    /**\r\n    * Creates a quaternion that orients an object to face towards a specified target direction.\r\n    *\r\n    * @param {Vector3} localForward - Specifies the forward direction in the local space of the object.\r\n    * @param {Vector3} targetDirection - Specifies the desired world space direction the object should look at.\r\n    * @param {Vector3} localUp - Specifies the up direction in the local space of the object.\r\n    * @return {Quaternion} A reference to this quaternion.\r\n    */\n\n  }, {\n    key: \"lookAt\",\n    value: function lookAt(localForward, targetDirection, localUp) {\n      matrix.lookAt(localForward, targetDirection, localUp);\n      this.fromMatrix3(matrix);\n    }\n    /**\r\n    * Spherically interpolates between this quaternion and the given quaternion by t.\r\n    * The parameter t is clamped to the range [0, 1].\r\n    *\r\n    * @param {Quaternion} q - The target rotation.\r\n    * @param {Number} t - The interpolation parameter.\r\n    * @return {Quaternion} A reference to this quaternion.\r\n    */\n\n  }, {\n    key: \"slerp\",\n    value: function slerp(q, t) {\n      if (t === 0) return this;\n      if (t === 1) return this.copy(q);\n      var x = this.x,\n          y = this.y,\n          z = this.z,\n          w = this.w;\n      var cosHalfTheta = w * q.w + x * q.x + y * q.y + z * q.z;\n\n      if (cosHalfTheta < 0) {\n        this.w = -q.w;\n        this.x = -q.x;\n        this.y = -q.y;\n        this.z = -q.z;\n        cosHalfTheta = -cosHalfTheta;\n      } else {\n        this.copy(q);\n      }\n\n      if (cosHalfTheta >= 1.0) {\n        this.w = w;\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        return this;\n      }\n\n      var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n\n      if (Math.abs(sinHalfTheta) < 0.001) {\n        this.w = 0.5 * (w + this.w);\n        this.x = 0.5 * (x + this.x);\n        this.y = 0.5 * (y + this.y);\n        this.z = 0.5 * (z + this.z);\n        return this;\n      }\n\n      var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n      var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;\n      var ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n      this.w = w * ratioA + this.w * ratioB;\n      this.x = x * ratioA + this.x * ratioB;\n      this.y = y * ratioA + this.y * ratioB;\n      this.z = z * ratioA + this.z * ratioB;\n      return this;\n    }\n    /**\r\n    * Extracts the rotation of the given 4x4 matrix and stores it in this quaternion.\r\n    *\r\n    * @param {Matrix4} m - A 4x4 matrix.\r\n    * @return {Quaternion} A reference to this quaternion.\r\n    */\n\n  }, {\n    key: \"extractRotationFromMatrix\",\n    value: function extractRotationFromMatrix(m) {\n      var e = matrix.elements;\n      var me = m.elements; // remove scaling from the 3x3 portion\n\n      var sx = 1 / vector.fromMatrix4Column(m, 0).length();\n      var sy = 1 / vector.fromMatrix4Column(m, 1).length();\n      var sz = 1 / vector.fromMatrix4Column(m, 2).length();\n      e[0] = me[0] * sx;\n      e[1] = me[1] * sx;\n      e[2] = me[2] * sx;\n      e[3] = me[4] * sy;\n      e[4] = me[5] * sy;\n      e[5] = me[6] * sy;\n      e[6] = me[8] * sz;\n      e[7] = me[9] * sz;\n      e[8] = me[10] * sz;\n      this.fromMatrix3(matrix);\n      return this;\n    }\n    /**\r\n    * Sets the components of this quaternion from the given euler angle (YXZ order).\r\n    *\r\n    * @param {Number} x - Rotation around x axis in radians.\r\n    * @param {Number} y - Rotation around y axis in radians.\r\n    * @param {Number} z - Rotation around z axis in radians.\r\n    * @return {Quaternion} A reference to this quaternion.\r\n    */\n\n  }, {\n    key: \"fromEuler\",\n    value: function fromEuler(x, y, z) {\n      // from 3D Math Primer for Graphics and Game Development\n      // 8.7.5 Converting Euler Angles to a Quaternion\n      // assuming YXZ (head/pitch/bank or yaw/pitch/roll) order\n      var c1 = Math.cos(y / 2);\n      var c2 = Math.cos(x / 2);\n      var c3 = Math.cos(z / 2);\n      var s1 = Math.sin(y / 2);\n      var s2 = Math.sin(x / 2);\n      var s3 = Math.sin(z / 2);\n      this.w = c1 * c2 * c3 + s1 * s2 * s3;\n      this.x = c1 * s2 * c3 + s1 * c2 * s3;\n      this.y = s1 * c2 * c3 - c1 * s2 * s3;\n      this.z = c1 * c2 * s3 - s1 * s2 * c3;\n      return this;\n    }\n    /**\r\n    * Returns an euler angel (YXZ order) representation of this quaternion.\r\n    *\r\n    * @param {Object} euler - The resulting euler angles.\r\n    * @return {Object} The resulting euler angles.\r\n    */\n\n  }, {\n    key: \"toEuler\",\n    value: function toEuler(euler) {\n      // from 3D Math Primer for Graphics and Game Development\n      // 8.7.6 Converting a Quaternion to Euler Angles\n      // extract pitch\n      var sp = -2 * (this.y * this.z - this.x * this.w); // check for gimbal lock\n\n      if (Math.abs(sp) > 0.9999) {\n        // looking straight up or down\n        euler.x = Math.PI * 0.5 * sp;\n        euler.y = Math.atan2(this.x * this.z + this.w * this.y, 0.5 - this.x * this.x - this.y * this.y);\n        euler.z = 0;\n      } else {\n        //todo test\n        euler.x = Math.asin(sp);\n        euler.y = Math.atan2(this.x * this.z + this.w * this.y, 0.5 - this.x * this.x - this.y * this.y);\n        euler.z = Math.atan2(this.x * this.y + this.w * this.z, 0.5 - this.x * this.x - this.z * this.z);\n      }\n\n      return euler;\n    }\n    /**\r\n    * Sets the components of this quaternion from the given 3x3 rotation matrix.\r\n    *\r\n    * @param {Matrix3} m - The rotation matrix.\r\n    * @return {Quaternion} A reference to this quaternion.\r\n    */\n\n  }, {\n    key: \"fromMatrix3\",\n    value: function fromMatrix3(m) {\n      var e = m.elements;\n      var m11 = e[0],\n          m12 = e[3],\n          m13 = e[6];\n      var m21 = e[1],\n          m22 = e[4],\n          m23 = e[7];\n      var m31 = e[2],\n          m32 = e[5],\n          m33 = e[8];\n      var trace = m11 + m22 + m33;\n\n      if (trace > 0) {\n        var s = 0.5 / Math.sqrt(trace + 1.0);\n        this.w = 0.25 / s;\n        this.x = (m32 - m23) * s;\n        this.y = (m13 - m31) * s;\n        this.z = (m21 - m12) * s;\n      } else if (m11 > m22 && m11 > m33) {\n        var _s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n        this.w = (m32 - m23) / _s;\n        this.x = 0.25 * _s;\n        this.y = (m12 + m21) / _s;\n        this.z = (m13 + m31) / _s;\n      } else if (m22 > m33) {\n        var _s2 = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n        this.w = (m13 - m31) / _s2;\n        this.x = (m12 + m21) / _s2;\n        this.y = 0.25 * _s2;\n        this.z = (m23 + m32) / _s2;\n      } else {\n        var _s3 = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n        this.w = (m21 - m12) / _s3;\n        this.x = (m13 + m31) / _s3;\n        this.y = (m23 + m32) / _s3;\n        this.z = 0.25 * _s3;\n      }\n\n      return this;\n    }\n    /**\r\n    * Sets the components of this quaternion from an array.\r\n    *\r\n    * @param {Array} array - An array.\r\n    * @param {Number} offset - An optional offset.\r\n    * @return {Quaternion} A reference to this quaternion.\r\n    */\n\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.x = array[offset + 0];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      this.w = array[offset + 3];\n      return this;\n    }\n    /**\r\n    * Copies all values of this quaternion to the given array.\r\n    *\r\n    * @param {Array} array - An array.\r\n    * @param {Number} offset - An optional offset.\r\n    * @return {Array} The array with the quaternion components.\r\n    */\n\n  }, {\n    key: \"toArray\",\n    value: function toArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      array[offset + 0] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      array[offset + 3] = this.w;\n      return array;\n    }\n    /**\r\n    * Returns true if the given quaternion is deep equal with this quaternion.\r\n    *\r\n    * @param {Quaternion} q - The quaternion to test.\r\n    * @return {Boolean} The result of the equality test.\r\n    */\n\n  }, {\n    key: \"equals\",\n    value: function equals(q) {\n      return q.x === this.x && q.y === this.y && q.z === this.z && q.w === this.w;\n    }\n  }]);\n\n  return Quaternion;\n}();\n/**\r\n* Class representing a 4x4 matrix. The elements of the matrix\r\n* are stored in column-major order.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar Matrix4 =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new 4x4 identity matrix.\r\n  */\n  function Matrix4() {\n    _classCallCheck(this, Matrix4);\n\n    /**\r\n    * The elements of the matrix in column-major order.\r\n    * @type Array\r\n    */\n    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n  }\n  /**\r\n  * Sets the given values to this matrix. The arguments are in row-major order.\r\n  *\r\n  * @param {Number} n11 - An element of the matrix.\r\n  * @param {Number} n12 - An element of the matrix.\r\n  * @param {Number} n13 - An element of the matrix.\r\n  * @param {Number} n14 - An element of the matrix.\r\n  * @param {Number} n21 - An element of the matrix.\r\n  * @param {Number} n22 - An element of the matrix.\r\n  * @param {Number} n23 - An element of the matrix.\r\n  * @param {Number} n24 - An element of the matrix.\r\n  * @param {Number} n31 - An element of the matrix.\r\n  * @param {Number} n32 - An element of the matrix.\r\n  * @param {Number} n33 - An element of the matrix.\r\n  * @param {Number} n34 - An element of the matrix.\r\n  * @param {Number} n41 - An element of the matrix.\r\n  * @param {Number} n42 - An element of the matrix.\r\n  * @param {Number} n43 - An element of the matrix.\r\n  * @param {Number} n44 - An element of the matrix.\r\n  * @return {Matrix4} A reference to this matrix.\r\n  */\n\n\n  _createClass(Matrix4, [{\n    key: \"set\",\n    value: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n      var e = this.elements;\n      e[0] = n11;\n      e[4] = n12;\n      e[8] = n13;\n      e[12] = n14;\n      e[1] = n21;\n      e[5] = n22;\n      e[9] = n23;\n      e[13] = n24;\n      e[2] = n31;\n      e[6] = n32;\n      e[10] = n33;\n      e[14] = n34;\n      e[3] = n41;\n      e[7] = n42;\n      e[11] = n43;\n      e[15] = n44;\n      return this;\n    }\n    /**\r\n    * Copies all values from the given matrix to this matrix.\r\n    *\r\n    * @param {Matrix4} m - The matrix to copy.\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"copy\",\n    value: function copy(m) {\n      var e = this.elements;\n      var me = m.elements;\n      e[0] = me[0];\n      e[1] = me[1];\n      e[2] = me[2];\n      e[3] = me[3];\n      e[4] = me[4];\n      e[5] = me[5];\n      e[6] = me[6];\n      e[7] = me[7];\n      e[8] = me[8];\n      e[9] = me[9];\n      e[10] = me[10];\n      e[11] = me[11];\n      e[12] = me[12];\n      e[13] = me[13];\n      e[14] = me[14];\n      e[15] = me[15];\n      return this;\n    }\n    /**\r\n    * Creates a new matrix and copies all values from this matrix.\r\n    *\r\n    * @return {Matrix4} A new matrix.\r\n    */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\r\n    * Transforms this matrix to an identity matrix.\r\n    *\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"identity\",\n    value: function identity() {\n      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      return this;\n    }\n    /**\r\n    * Multiplies this matrix with the given matrix.\r\n    *\r\n    * @param {Matrix4} m - The matrix to multiply.\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"multiply\",\n    value: function multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    /**\r\n    * Multiplies this matrix with the given matrix.\r\n    * So the order of the multiplication is switched compared to {@link Matrix4#multiply}.\r\n    *\r\n    * @param {Matrix4} m - The matrix to multiply.\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"premultiply\",\n    value: function premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    /**\r\n    * Multiplies two given matrices and stores the result in this matrix.\r\n    *\r\n    * @param {Matrix4} a - The first matrix of the operation.\r\n    * @param {Matrix4} b - The second matrix of the operation.\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"multiplyMatrices\",\n    value: function multiplyMatrices(a, b) {\n      var ae = a.elements;\n      var be = b.elements;\n      var e = this.elements;\n      var a11 = ae[0],\n          a12 = ae[4],\n          a13 = ae[8],\n          a14 = ae[12];\n      var a21 = ae[1],\n          a22 = ae[5],\n          a23 = ae[9],\n          a24 = ae[13];\n      var a31 = ae[2],\n          a32 = ae[6],\n          a33 = ae[10],\n          a34 = ae[14];\n      var a41 = ae[3],\n          a42 = ae[7],\n          a43 = ae[11],\n          a44 = ae[15];\n      var b11 = be[0],\n          b12 = be[4],\n          b13 = be[8],\n          b14 = be[12];\n      var b21 = be[1],\n          b22 = be[5],\n          b23 = be[9],\n          b24 = be[13];\n      var b31 = be[2],\n          b32 = be[6],\n          b33 = be[10],\n          b34 = be[14];\n      var b41 = be[3],\n          b42 = be[7],\n          b43 = be[11],\n          b44 = be[15];\n      e[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n      e[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n      e[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n      e[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n      e[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n      e[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n      e[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n      e[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n      e[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n      e[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n      e[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n      e[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n      e[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n      e[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n      e[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n      e[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n      return this;\n    }\n    /**\r\n    * Multiplies the given scalar with this matrix.\r\n    *\r\n    * @param {Number} s - The scalar to multiply.\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"multiplyScalar\",\n    value: function multiplyScalar(s) {\n      var e = this.elements;\n      e[0] *= s;\n      e[4] *= s;\n      e[8] *= s;\n      e[12] *= s;\n      e[1] *= s;\n      e[5] *= s;\n      e[9] *= s;\n      e[13] *= s;\n      e[2] *= s;\n      e[6] *= s;\n      e[10] *= s;\n      e[14] *= s;\n      e[3] *= s;\n      e[7] *= s;\n      e[11] *= s;\n      e[15] *= s;\n      return this;\n    }\n    /**\r\n    * Extracts the basis vectors and stores them to the given vectors.\r\n    *\r\n    * @param {Vector3} xAxis - The first result vector for the x-axis.\r\n    * @param {Vector3} yAxis - The second result vector for the y-axis.\r\n    * @param {Vector3} zAxis - The third result vector for the z-axis.\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"extractBasis\",\n    value: function extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.fromMatrix4Column(this, 0);\n      yAxis.fromMatrix4Column(this, 1);\n      zAxis.fromMatrix4Column(this, 2);\n      return this;\n    }\n    /**\r\n    * Makes a basis from the given vectors.\r\n    *\r\n    * @param {Vector3} xAxis - The first basis vector for the x-axis.\r\n    * @param {Vector3} yAxis - The second basis vector for the y-axis.\r\n    * @param {Vector3} zAxis - The third basis vector for the z-axis.\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"makeBasis\",\n    value: function makeBasis(xAxis, yAxis, zAxis) {\n      this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\n      return this;\n    }\n    /**\r\n    * Composes a matrix from the given position, quaternion and scale.\r\n    *\r\n    * @param {Vector3} position - A vector representing a position in 3D space.\r\n    * @param {Quaternion} rotation - A quaternion representing a rotation.\r\n    * @param {Vector3} scale - A vector representing a 3D scaling.\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"compose\",\n    value: function compose(position, rotation, scale) {\n      this.fromQuaternion(rotation);\n      this.scale(scale);\n      this.setPosition(position);\n      return this;\n    }\n    /**\r\n    * Scales this matrix by the given 3D vector.\r\n    *\r\n    * @param {Vector3} v - A 3D vector representing a scaling.\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"scale\",\n    value: function scale(v) {\n      var e = this.elements;\n      var x = v.x,\n          y = v.y,\n          z = v.z;\n      e[0] *= x;\n      e[4] *= y;\n      e[8] *= z;\n      e[1] *= x;\n      e[5] *= y;\n      e[9] *= z;\n      e[2] *= x;\n      e[6] *= y;\n      e[10] *= z;\n      e[3] *= x;\n      e[7] *= y;\n      e[11] *= z;\n      return this;\n    }\n    /**\r\n    * Sets the translation part of the 4x4 matrix to the given position vector.\r\n    *\r\n    * @param {Vector3} v - A 3D vector representing a position.\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(v) {\n      var e = this.elements;\n      e[12] = v.x;\n      e[13] = v.y;\n      e[14] = v.z;\n      return this;\n    }\n    /**\r\n    * Transposes this matrix.\r\n    *\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"transpose\",\n    value: function transpose() {\n      var e = this.elements;\n      var t;\n      t = e[1];\n      e[1] = e[4];\n      e[4] = t;\n      t = e[2];\n      e[2] = e[8];\n      e[8] = t;\n      t = e[6];\n      e[6] = e[9];\n      e[9] = t;\n      t = e[3];\n      e[3] = e[12];\n      e[12] = t;\n      t = e[7];\n      e[7] = e[13];\n      e[13] = t;\n      t = e[11];\n      e[11] = e[14];\n      e[14] = t;\n      return this;\n    }\n    /**\r\n    * Computes the inverse of this matrix and stored the result in the given matrix.\r\n    *\r\n    * @param {Matrix4} m - The result matrix.\r\n    * @return {Matrix4} The result matrix.\r\n    */\n\n  }, {\n    key: \"getInverse\",\n    value: function getInverse(m) {\n      var e = this.elements;\n      var me = m.elements;\n      var n11 = e[0],\n          n21 = e[1],\n          n31 = e[2],\n          n41 = e[3];\n      var n12 = e[4],\n          n22 = e[5],\n          n32 = e[6],\n          n42 = e[7];\n      var n13 = e[8],\n          n23 = e[9],\n          n33 = e[10],\n          n43 = e[11];\n      var n14 = e[12],\n          n24 = e[13],\n          n34 = e[14],\n          n44 = e[15];\n      var t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\n      var t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\n      var t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\n      var t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n      var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n      if (det === 0) {\n        Logger.warn('YUKA.Matrix4: .getInverse() can not invert matrix, determinant is 0.');\n        return this.identity();\n      }\n\n      var detInv = 1 / det;\n      me[0] = t11 * detInv;\n      me[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n      me[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n      me[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n      me[4] = t12 * detInv;\n      me[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n      me[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n      me[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n      me[8] = t13 * detInv;\n      me[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n      me[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n      me[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n      me[12] = t14 * detInv;\n      me[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n      me[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n      me[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n      return m;\n    }\n    /**\r\n    * Computes the maximum scale value for all three axis.\r\n    *\r\n    * @return {Number} The maximum scale value.\r\n    */\n\n  }, {\n    key: \"getMaxScale\",\n    value: function getMaxScale() {\n      var e = this.elements;\n      var scaleXSq = e[0] * e[0] + e[1] * e[1] + e[2] * e[2];\n      var scaleYSq = e[4] * e[4] + e[5] * e[5] + e[6] * e[6];\n      var scaleZSq = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];\n      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n    }\n    /**\r\n    * Uses the given quaternion to transform the upper left 3x3 part to a rotation matrix.\r\n    * Other parts of the matrix are equal to the identiy matrix.\r\n    *\r\n    * @param {Quaternion} q - A quaternion representing a rotation.\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"fromQuaternion\",\n    value: function fromQuaternion(q) {\n      var e = this.elements;\n      var x = q.x,\n          y = q.y,\n          z = q.z,\n          w = q.w;\n      var x2 = x + x,\n          y2 = y + y,\n          z2 = z + z;\n      var xx = x * x2,\n          xy = x * y2,\n          xz = x * z2;\n      var yy = y * y2,\n          yz = y * z2,\n          zz = z * z2;\n      var wx = w * x2,\n          wy = w * y2,\n          wz = w * z2;\n      e[0] = 1 - (yy + zz);\n      e[4] = xy - wz;\n      e[8] = xz + wy;\n      e[1] = xy + wz;\n      e[5] = 1 - (xx + zz);\n      e[9] = yz - wx;\n      e[2] = xz - wy;\n      e[6] = yz + wx;\n      e[10] = 1 - (xx + yy);\n      e[3] = 0;\n      e[7] = 0;\n      e[11] = 0;\n      e[12] = 0;\n      e[13] = 0;\n      e[14] = 0;\n      e[15] = 1;\n      return this;\n    }\n    /**\r\n    * Sets the upper-left 3x3 portion of this matrix by the given 3x3 matrix. Other\r\n    * parts of the matrix are equal to the identiy matrix.\r\n    *\r\n    * @param {Matrix3} m - A 3x3 matrix.\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"fromMatrix3\",\n    value: function fromMatrix3(m) {\n      var e = this.elements;\n      var me = m.elements;\n      e[0] = me[0];\n      e[1] = me[1];\n      e[2] = me[2];\n      e[3] = 0;\n      e[4] = me[3];\n      e[5] = me[4];\n      e[6] = me[5];\n      e[7] = 0;\n      e[8] = me[6];\n      e[9] = me[7];\n      e[10] = me[8];\n      e[11] = 0;\n      e[12] = 0;\n      e[13] = 0;\n      e[14] = 0;\n      e[15] = 1;\n      return this;\n    }\n    /**\r\n    * Sets the elements of this matrix from an array.\r\n    *\r\n    * @param {Array} array - An array.\r\n    * @param {Number} offset - An optional offset.\r\n    * @return {Matrix4} A reference to this matrix.\r\n    */\n\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var e = this.elements;\n\n      for (var _i6 = 0; _i6 < 16; _i6++) {\n        e[_i6] = array[_i6 + offset];\n      }\n\n      return this;\n    }\n    /**\r\n    * Copies all elements of this matrix to the given array.\r\n    *\r\n    * @param {Array} array - An array.\r\n    * @param {Number} offset - An optional offset.\r\n    * @return {Array} The array with the elements of the matrix.\r\n    */\n\n  }, {\n    key: \"toArray\",\n    value: function toArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var e = this.elements;\n      array[offset + 0] = e[0];\n      array[offset + 1] = e[1];\n      array[offset + 2] = e[2];\n      array[offset + 3] = e[3];\n      array[offset + 4] = e[4];\n      array[offset + 5] = e[5];\n      array[offset + 6] = e[6];\n      array[offset + 7] = e[7];\n      array[offset + 8] = e[8];\n      array[offset + 9] = e[9];\n      array[offset + 10] = e[10];\n      array[offset + 11] = e[11];\n      array[offset + 12] = e[12];\n      array[offset + 13] = e[13];\n      array[offset + 14] = e[14];\n      array[offset + 15] = e[15];\n      return array;\n    }\n    /**\r\n    * Returns true if the given matrix is deep equal with this matrix.\r\n    *\r\n    * @param {Matrix4} m - The matrix to test.\r\n    * @return {Boolean} The result of the equality test.\r\n    */\n\n  }, {\n    key: \"equals\",\n    value: function equals(m) {\n      var e = this.elements;\n      var me = m.elements;\n\n      for (var _i7 = 0; _i7 < 16; _i7++) {\n        if (e[_i7] !== me[_i7]) return false;\n      }\n\n      return true;\n    }\n  }]);\n\n  return Matrix4;\n}();\n\nvar targetRotation = new Quaternion();\nvar targetDirection = new Vector3();\nvar quaternionWorld = new Quaternion();\n/**\r\n* Base class for all game entities.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar GameEntity =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new game entity.\r\n  */\n  function GameEntity() {\n    _classCallCheck(this, GameEntity);\n\n    /**\r\n    * The name of this game entity.\r\n    * @type String\r\n    */\n    this.name = '';\n    /**\r\n    * Whether this game entity is active or not.\r\n    * @type Boolean\r\n    * @default true\r\n    */\n\n    this.active = true;\n    /**\r\n    * The child entities of this game entity.\r\n    * @type Array\r\n    */\n\n    this.children = new Array();\n    /**\r\n    * A reference to the parent entity of this game entity.\r\n    * Automatically set when added to a {@link GameEntity}.\r\n    * @type GameEntity\r\n    * @default null\r\n    */\n\n    this.parent = null;\n    /**\r\n    * A list of neighbors of this game entity.\r\n    * @type Array\r\n    */\n\n    this.neighbors = new Array();\n    /**\r\n    * Game entities within this radius are considered as neighbors of this entity.\r\n    * @type Number\r\n    * @default 1\r\n    */\n\n    this.neighborhoodRadius = 1;\n    /**\r\n    * Whether the neighborhood of this game entity is updated or not.\r\n    * @type Boolean\r\n    * @default false\r\n    */\n\n    this.updateNeighborhood = false;\n    /**\r\n    * The position of this game entity.\r\n    * @type Vector3\r\n    */\n\n    this.position = new Vector3();\n    /**\r\n    * The rotation of this game entity.\r\n    * @type Quaternion\r\n    */\n\n    this.rotation = new Quaternion();\n    /**\r\n    * The scaling of this game entity.\r\n    * @type Vector3\r\n    */\n\n    this.scale = new Vector3(1, 1, 1);\n    /**\r\n    * The default forward vector of this game entity.\r\n    * @type Vector3\r\n    * @default (0,0,1)\r\n    */\n\n    this.forward = new Vector3(0, 0, 1);\n    /**\r\n    * The default up vector of this game entity.\r\n    * @type Vector3\r\n    * @default (0,1,0)\r\n    */\n\n    this.up = new Vector3(0, 1, 0);\n    /**\r\n    * The bounding radius of this game entity in world units.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    this.boundingRadius = 0;\n    /**\r\n    * The maximum turn rate of this game entity in radians per seconds.\r\n    * @type Number\r\n    * @default \r\n    */\n\n    this.maxTurnRate = Math.PI;\n    /**\r\n    * Whether the entity can activate a trigger or not.\r\n    * @type Boolean\r\n    * @default true\r\n    */\n\n    this.canAcitivateTrigger = true;\n    /**\r\n    * A transformation matrix representing the world space of this game entity.\r\n    * @type Matrix4\r\n    */\n\n    this.worldMatrix = new Matrix4();\n    /**\r\n    * A reference to the entity manager of this game entity.\r\n    * Automatically set when added to an {@link EntityManager}.\r\n    * @type EntityManager\r\n    * @default null\r\n    */\n\n    this.manager = null; // private properties\n    // local transformation matrix. no part of the public API due to caching\n\n    this._localMatrix = new Matrix4(); // per-entity cache in order to avoid unnecessary matrix calculations\n\n    this._cache = {\n      position: new Vector3(),\n      rotation: new Quaternion(),\n      scale: new Vector3(1, 1, 1)\n    }; // render component\n\n    this._renderComponent = null;\n    this._renderComponentCallback = null; // flag to indicate whether the entity was updated by its manager at least once or not\n\n    this._started = false; // unique ID, primarily used in context of serialization/deserialization\n\n    this._uuid = null;\n  }\n\n  _createClass(GameEntity, [{\n    key: \"start\",\n\n    /**\r\n    * Executed when this game entity is updated for the first time by its {@link EntityManager}.\r\n    *\r\n    * @return {GameEntity} A reference to this game entity.\r\n    */\n    value: function start() {}\n    /**\r\n    * Updates the internal state of this game entity. Normally called by {@link EntityManager#update}\r\n    * in each simulation step.\r\n    *\r\n    * @param {Number} delta - The time delta.\r\n    * @return {GameEntity} A reference to this game entity.\r\n    */\n\n  }, {\n    key: \"update\",\n    value: function update()\n    /* delta */\n    {}\n    /**\r\n    * Adds a game entity as a child to this game entity.\r\n    *\r\n    * @param {GameEntity} entity - The game entity to add.\r\n    * @return {GameEntity} A reference to this game entity.\r\n    */\n\n  }, {\n    key: \"add\",\n    value: function add(entity) {\n      if (entity.parent !== null) {\n        entity.parent.remove(entity);\n      }\n\n      this.children.push(entity);\n      entity.parent = this;\n      return this;\n    }\n    /**\r\n    * Removes a game entity as a child from this game entity.\r\n    *\r\n    * @param {GameEntity} entity - The game entity to remove.\r\n    * @return {GameEntity} A reference to this game entity.\r\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove(entity) {\n      var index = this.children.indexOf(entity);\n      this.children.splice(index, 1);\n      entity.parent = null;\n      return this;\n    }\n    /**\r\n    * Computes the current direction (forward) vector of this game entity\r\n    * and stores the result in the given vector.\r\n    *\r\n    * @param {Vector3} result - The direction vector of this game entity.\r\n    * @return {Vector3} The direction vector of this game entity.\r\n    */\n\n  }, {\n    key: \"getDirection\",\n    value: function getDirection(result) {\n      return result.copy(this.forward).applyRotation(this.rotation).normalize();\n    }\n    /**\r\n    * Directly rotates the entity so it faces the given target position.\r\n    *\r\n    * @param {Vector3} target - The target position.\r\n    * @return {GameEntity} A reference to this game entity.\r\n    */\n\n  }, {\n    key: \"lookAt\",\n    value: function lookAt(target) {\n      targetDirection.subVectors(target, this.position).normalize();\n      this.rotation.lookAt(this.forward, targetDirection, this.up);\n      return this;\n    }\n    /**\r\n    * Given a target position, this method rotates the entity by an amount not\r\n    * greater than {@link GameEntity#maxTurnRate} until it directly faces the target.\r\n    *\r\n    * @param {Vector3} target - The target position.\r\n    * @param {Number} delta - The time delta.\r\n    * @param {Number} tolerance - A tolerance value in radians to tweak the result\r\n    * when a game entity is considered to face a target.\r\n    * @return {Boolean} Whether the entity is faced to the target or not.\r\n    */\n\n  }, {\n    key: \"rotateTo\",\n    value: function rotateTo(target, delta) {\n      var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0001;\n      targetDirection.subVectors(target, this.position).normalize();\n      targetRotation.lookAt(this.forward, targetDirection, this.up);\n      return this.rotation.rotateTo(targetRotation, this.maxTurnRate * delta, tolerance);\n    }\n    /**\r\n    * Computes the current direction (forward) vector of this game entity\r\n    * in world space and stores the result in the given vector.\r\n    *\r\n    * @param {Vector3} result - The direction vector of this game entity in world space.\r\n    * @return {Vector3} The direction vector of this game entity in world space.\r\n    */\n\n  }, {\n    key: \"getWorldDirection\",\n    value: function getWorldDirection(result) {\n      quaternionWorld.extractRotationFromMatrix(this.worldMatrix);\n      return result.copy(this.forward).applyRotation(quaternionWorld).normalize();\n    }\n    /**\r\n    * Computes the current position of this game entity in world space and\r\n    * stores the result in the given vector.\r\n    *\r\n    * @param {Vector3} result - The position of this game entity in world space.\r\n    * @return {Vector3} The position of this game entity in world space.\r\n    */\n\n  }, {\n    key: \"getWorldPosition\",\n    value: function getWorldPosition(result) {\n      return result.extractPositionFromMatrix(this.worldMatrix);\n    }\n    /**\r\n    * Updates the world matrix representing the world space.\r\n    *\r\n    * @param {Boolean} up - Whether to update the world matrices of the parents or not.\r\n    * @param {Boolean} down - Whether to update the world matrices of the children or not.\r\n    * @return {GameEntity} A reference to this game entity.\r\n    */\n\n  }, {\n    key: \"updateWorldMatrix\",\n    value: function updateWorldMatrix() {\n      var up = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var down = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var parent = this.parent;\n      var children = this.children; // update higher levels first\n\n      if (up === true && parent !== null) {\n        parent.updateWorldMatrix(true);\n      } // update this entity\n\n\n      this._updateMatrix();\n\n      if (parent === null) {\n        this.worldMatrix.copy(this._localMatrix);\n      } else {\n        this.worldMatrix.multiplyMatrices(this.parent.worldMatrix, this._localMatrix);\n      } // update lower levels\n\n\n      if (down === true) {\n        for (var _i8 = 0, l = children.length; _i8 < l; _i8++) {\n          var child = children[_i8];\n          child.updateWorldMatrix(false, true);\n        }\n      }\n\n      return this;\n    }\n    /**\r\n    * Sets a renderable component of a 3D engine with a sync callback for this game entity.\r\n    *\r\n    * @param {Object} renderComponent - A renderable component of a 3D engine.\r\n    * @param {Function} callback - A callback that can be used to sync this game entity with the renderable component.\r\n    * @return {GameEntity} A reference to this game entity.\r\n    */\n\n  }, {\n    key: \"setRenderComponent\",\n    value: function setRenderComponent(renderComponent, callback) {\n      this._renderComponent = renderComponent;\n      this._renderComponentCallback = callback;\n      return this;\n    }\n    /**\r\n    * Holds the implementation for the message handling of this game entity.\r\n    *\r\n    * @param {Telegram} telegram - The telegram with the message data.\r\n    * @return {Boolean} Whether the message was processed or not.\r\n    */\n\n  }, {\n    key: \"handleMessage\",\n    value: function handleMessage() {\n      return false;\n    }\n    /**\r\n    * Holds the implementation for the line of sight test of this game entity.\r\n    * This method is used by {@link Vision#visible} in order to determine whether\r\n    * this game entity blocks the given line of sight or not. Implement this method\r\n    * when your game entity acts as an obstacle.\r\n    *\r\n    * @param {Ray} ray - The ray that represents the line of sight.\r\n    * @param {Vector3} intersectionPoint - The intersection point.\r\n    * @return {Vector3} The intersection point.\r\n    */\n\n  }, {\n    key: \"lineOfSightTest\",\n    value: function lineOfSightTest() {\n      return null;\n    }\n    /**\r\n    * Sends a message with the given data to the specified receiver.\r\n    *\r\n    * @param {GameEntity} receiver - The receiver.\r\n    * @param {String} message - The actual message.\r\n    * @param {Number} delay - A time value in millisecond used to delay the message dispatching.\r\n    * @param {Object} data - An object for custom data.\r\n    * @return {GameEntity} A reference to this game entity.\r\n    */\n\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(receiver, message) {\n      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n      if (this.manager !== null) {\n        this.manager.sendMessage(this, receiver, message, delay, data);\n      } else {\n        Logger.error('YUKA.GameEntity: The game entity must be added to a manager in order to send a message.');\n      }\n\n      return this;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.constructor.name,\n        uuid: this.uuid,\n        name: this.name,\n        active: this.active,\n        children: entitiesToIds(this.children),\n        parent: this.parent !== null ? this.parent.uuid : null,\n        neighbors: entitiesToIds(this.neighbors),\n        neighborhoodRadius: this.neighborhoodRadius,\n        updateNeighborhood: this.updateNeighborhood,\n        position: this.position.toArray(new Array()),\n        rotation: this.rotation.toArray(new Array()),\n        scale: this.scale.toArray(new Array()),\n        forward: this.forward.toArray(new Array()),\n        up: this.up.toArray(new Array()),\n        boundingRadius: this.boundingRadius,\n        maxTurnRate: this.maxTurnRate,\n        worldMatrix: this.worldMatrix.toArray(new Array()),\n        _localMatrix: this._localMatrix.toArray(new Array()),\n        _cache: {\n          position: this._cache.position.toArray(new Array()),\n          rotation: this._cache.rotation.toArray(new Array()),\n          scale: this._cache.scale.toArray(new Array())\n        },\n        _started: this._started\n      };\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {GameEntity} A reference to this game entity.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.uuid = json.uuid;\n      this.name = json.name;\n      this.active = json.active;\n      this.neighborhoodRadius = json.neighborhoodRadius;\n      this.updateNeighborhood = json.updateNeighborhood;\n      this.position.fromArray(json.position);\n      this.rotation.fromArray(json.rotation);\n      this.scale.fromArray(json.scale);\n      this.forward.fromArray(json.forward);\n      this.up.fromArray(json.up);\n      this.boundingRadius = json.boundingRadius;\n      this.maxTurnRate = json.maxTurnRate;\n      this.worldMatrix.fromArray(json.worldMatrix);\n      this.children = json.children.slice();\n      this.neighbors = json.neighbors.slice();\n      this.parent = json.parent;\n\n      this._localMatrix.fromArray(json._localMatrix);\n\n      this._cache.position.fromArray(json._cache.position);\n\n      this._cache.rotation.fromArray(json._cache.rotation);\n\n      this._cache.scale.fromArray(json._cache.scale);\n\n      this._started = json._started;\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {GameEntity} A reference to this game entity.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      //\n      var neighbors = this.neighbors;\n\n      for (var _i9 = 0, l = neighbors.length; _i9 < l; _i9++) {\n        neighbors[_i9] = entities.get(neighbors[_i9]);\n      } //\n\n\n      var children = this.children;\n\n      for (var _i10 = 0, _l = children.length; _i10 < _l; _i10++) {\n        children[_i10] = entities.get(children[_i10]);\n      } //\n\n\n      this.parent = entities.get(this.parent) || null;\n      return this;\n    } // Updates the transformation matrix representing the local space.\n\n  }, {\n    key: \"_updateMatrix\",\n    value: function _updateMatrix() {\n      var cache = this._cache;\n\n      if (cache.position.equals(this.position) && cache.rotation.equals(this.rotation) && cache.scale.equals(this.scale)) {\n        return this;\n      }\n\n      this._localMatrix.compose(this.position, this.rotation, this.scale);\n\n      cache.position.copy(this.position);\n      cache.rotation.copy(this.rotation);\n      cache.scale.copy(this.scale);\n      return this;\n    }\n  }, {\n    key: \"uuid\",\n    get: function get() {\n      if (this._uuid === null) {\n        this._uuid = MathUtils.generateUUID();\n      }\n\n      return this._uuid;\n    },\n    set: function set(uuid) {\n      this._uuid = uuid;\n    }\n  }]);\n\n  return GameEntity;\n}();\n\nfunction entitiesToIds(array) {\n  var ids = new Array();\n\n  for (var _i11 = 0, l = array.length; _i11 < l; _i11++) {\n    ids.push(array[_i11].uuid);\n  }\n\n  return ids;\n}\n\nvar displacement = new Vector3();\nvar target = new Vector3();\n/**\r\n* Class representing moving game entities.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments GameEntity\r\n*/\n\nvar MovingEntity =\n/*#__PURE__*/\nfunction (_GameEntity) {\n  _inherits(MovingEntity, _GameEntity);\n\n  /**\r\n  * Constructs a new moving entity.\r\n  */\n  function MovingEntity() {\n    var _this;\n\n    _classCallCheck(this, MovingEntity);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MovingEntity).call(this));\n    /**\r\n    * The velocity of this game entity.\r\n    * @type Vector3\r\n    */\n\n    _this.velocity = new Vector3();\n    /**\r\n    * The maximum speed at which this game entity may travel.\r\n    * @type Number\r\n    */\n\n    _this.maxSpeed = 1;\n    /**\r\n    * Whether the orientation of this game entity will be updated based on the velocity or not.\r\n    * @type Boolean\r\n    * @default true\r\n    */\n\n    _this.updateOrientation = true;\n    return _this;\n  }\n  /**\r\n  * Updates the internal state of this game entity.\r\n  *\r\n  * @param {Number} delta - The time delta.\r\n  * @return {MovingEntity} A reference to this moving entity.\r\n  */\n\n\n  _createClass(MovingEntity, [{\n    key: \"update\",\n    value: function update(delta) {\n      // make sure vehicle does not exceed maximum speed\n      if (this.getSpeedSquared() > this.maxSpeed * this.maxSpeed) {\n        this.velocity.normalize();\n        this.velocity.multiplyScalar(this.maxSpeed);\n      } // calculate displacement\n\n\n      displacement.copy(this.velocity).multiplyScalar(delta); // calculate target position\n\n      target.copy(this.position).add(displacement); // update the orientation if the vehicle has a non zero velocity\n\n      if (this.updateOrientation && this.getSpeedSquared() > 0.00000001) {\n        this.lookAt(target);\n      } // update position\n\n\n      this.position.copy(target);\n      return this;\n    }\n    /**\r\n    * Returns the current speed of this game entity.\r\n    *\r\n    * @return {Number} The current speed.\r\n    */\n\n  }, {\n    key: \"getSpeed\",\n    value: function getSpeed() {\n      return this.velocity.length();\n    }\n    /**\r\n    * Returns the current speed in squared space of this game entity.\r\n    *\r\n    * @return {Number} The current speed in squared space.\r\n    */\n\n  }, {\n    key: \"getSpeedSquared\",\n    value: function getSpeedSquared() {\n      return this.velocity.squaredLength();\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(MovingEntity.prototype), \"toJSON\", this).call(this);\n\n      json.velocity = this.velocity.toArray(new Array());\n      json.maxSpeed = this.maxSpeed;\n      json.updateOrientation = this.updateOrientation;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {MovingEntity} A reference to this moving entity.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(MovingEntity.prototype), \"fromJSON\", this).call(this, json);\n\n      this.velocity.fromArray(json.velocity);\n      this.maxSpeed = json.maxSpeed;\n      this.updateOrientation = json.updateOrientation;\n      return this;\n    }\n  }]);\n\n  return MovingEntity;\n}(GameEntity);\n/**\r\n* Base class for all concrete steering behaviors. They produce a force that describes\r\n* where an agent should move and how fast it should travel to get there.\r\n*\r\n* Note: All built-in steering behaviors assume a {@link Vehicle#mass} of one. Different values can lead to an unexpected results.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar SteeringBehavior =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new steering behavior.\r\n  */\n  function SteeringBehavior() {\n    _classCallCheck(this, SteeringBehavior);\n\n    /**\r\n    * Whether this steering behavior is active or not.\r\n    * @type Boolean\r\n    * @default true\r\n    */\n    this.active = true;\n    /**\r\n    * Can be used to tweak the amount that a steering force contributes to the total steering force.\r\n    * @type Number\r\n    * @default 1\r\n    */\n\n    this.weight = 1;\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(SteeringBehavior, [{\n    key: \"calculate\",\n    value: function calculate()\n    /* vehicle, force, delta */\n    {}\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.constructor.name,\n        active: this.active,\n        weight: this.weight\n      };\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {SteeringBehavior} A reference to this steering behavior.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.active = json.active;\n      this.weight = json.weight;\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {SteeringBehavior} A reference to this steering behavior.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences()\n    /* entities */\n    {}\n  }]);\n\n  return SteeringBehavior;\n}();\n\nvar averageDirection = new Vector3();\nvar direction = new Vector3();\n/**\r\n* This steering behavior produces a force that keeps a vehicles heading aligned with its neighbors.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments SteeringBehavior\r\n*/\n\nvar AlignmentBehavior =\n/*#__PURE__*/\nfunction (_SteeringBehavior) {\n  _inherits(AlignmentBehavior, _SteeringBehavior);\n\n  /**\r\n  * Constructs a new alignment behavior.\r\n  */\n  function AlignmentBehavior() {\n    _classCallCheck(this, AlignmentBehavior);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(AlignmentBehavior).call(this));\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(AlignmentBehavior, [{\n    key: \"calculate\",\n    value: function calculate(vehicle, force\n    /*, delta */\n    ) {\n      averageDirection.set(0, 0, 0);\n      var neighbors = vehicle.neighbors; // iterate over all neighbors to calculate the average direction vector\n\n      for (var _i12 = 0, l = neighbors.length; _i12 < l; _i12++) {\n        var neighbor = neighbors[_i12];\n        neighbor.getDirection(direction);\n        averageDirection.add(direction);\n      }\n\n      if (neighbors.length > 0) {\n        averageDirection.divideScalar(neighbors.length); // produce a force to align the vehicle's heading\n\n        vehicle.getDirection(direction);\n        force.subVectors(averageDirection, direction);\n      }\n\n      return force;\n    }\n  }]);\n\n  return AlignmentBehavior;\n}(SteeringBehavior);\n\nvar desiredVelocity = new Vector3();\nvar displacement$1 = new Vector3();\n/**\r\n* This steering behavior produces a force that directs an agent toward a target position.\r\n* Unlike {@link SeekBehavior}, it decelerates so the agent comes to a gentle halt at the target position.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments SteeringBehavior\r\n*/\n\nvar ArriveBehavior =\n/*#__PURE__*/\nfunction (_SteeringBehavior2) {\n  _inherits(ArriveBehavior, _SteeringBehavior2);\n\n  /**\r\n  * Constructs a new arrive behavior.\r\n  *\r\n  * @param {Vector3} target - The target vector.\r\n  * @param {Number} deceleration - The amount of deceleration.\r\n  * @param {Number} tolerance - A tolerance value in world units to prevent the vehicle from overshooting its target.\r\n  */\n  function ArriveBehavior() {\n    var _this2;\n\n    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var deceleration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n    var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, ArriveBehavior);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ArriveBehavior).call(this));\n    /**\r\n    * The target vector.\r\n    * @type Vector3\r\n    */\n\n    _this2.target = target;\n    /**\r\n    * The amount of deceleration.\r\n    * @type Number\r\n    * @default 3\r\n    */\n\n    _this2.deceleration = deceleration;\n    /**\r\n     * A tolerance value in world units to prevent the vehicle from overshooting its target.\r\n     * @type {Number}\r\n     * @default 0\r\n     */\n\n    _this2.tolerance = tolerance;\n    return _this2;\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(ArriveBehavior, [{\n    key: \"calculate\",\n    value: function calculate(vehicle, force\n    /*, delta */\n    ) {\n      var target = this.target;\n      var deceleration = this.deceleration;\n      displacement$1.subVectors(target, vehicle.position);\n      var distance = displacement$1.length();\n\n      if (distance > this.tolerance) {\n        // calculate the speed required to reach the target given the desired deceleration\n        var speed = distance / deceleration; // make sure the speed does not exceed the max\n\n        speed = Math.min(speed, vehicle.maxSpeed); // from here proceed just like \"seek\" except we don't need to normalize\n        // the \"displacement\" vector because we have already gone to the trouble\n        // of calculating its length.\n\n        desiredVelocity.copy(displacement$1).multiplyScalar(speed / distance);\n      } else {\n        desiredVelocity.set(0, 0, 0);\n      }\n\n      return force.subVectors(desiredVelocity, vehicle.velocity);\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(ArriveBehavior.prototype), \"toJSON\", this).call(this);\n\n      json.target = this.target.toArray(new Array());\n      json.deceleration = this.deceleration;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {ArriveBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(ArriveBehavior.prototype), \"fromJSON\", this).call(this, json);\n\n      this.target.fromArray(json.target);\n      this.deceleration = json.deceleration;\n      return this;\n    }\n  }]);\n\n  return ArriveBehavior;\n}(SteeringBehavior);\n\nvar desiredVelocity$1 = new Vector3();\n/**\r\n* This steering behavior produces a force that directs an agent toward a target position.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments SteeringBehavior\r\n*/\n\nvar SeekBehavior =\n/*#__PURE__*/\nfunction (_SteeringBehavior3) {\n  _inherits(SeekBehavior, _SteeringBehavior3);\n\n  /**\r\n  * Constructs a new seek behavior.\r\n  *\r\n  * @param {Vector3} target - The target vector.\r\n  */\n  function SeekBehavior() {\n    var _this3;\n\n    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n\n    _classCallCheck(this, SeekBehavior);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(SeekBehavior).call(this));\n    /**\r\n    * The target vector.\r\n    * @type Vector3\r\n    */\n\n    _this3.target = target;\n    return _this3;\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(SeekBehavior, [{\n    key: \"calculate\",\n    value: function calculate(vehicle, force\n    /*, delta */\n    ) {\n      var target = this.target; // First the desired velocity is calculated.\n      // This is the velocity the agent would need to reach the target position in an ideal world.\n      // It represents the vector from the agent to the target,\n      // scaled to be the length of the maximum possible speed of the agent.\n\n      desiredVelocity$1.subVectors(target, vehicle.position).normalize();\n      desiredVelocity$1.multiplyScalar(vehicle.maxSpeed); // The steering force returned by this method is the force required,\n      // which when added to the agents current velocity vector gives the desired velocity.\n      // To achieve this you simply subtract the agents current velocity from the desired velocity.\n\n      return force.subVectors(desiredVelocity$1, vehicle.velocity);\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(SeekBehavior.prototype), \"toJSON\", this).call(this);\n\n      json.target = this.target.toArray(new Array());\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {SeekBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(SeekBehavior.prototype), \"fromJSON\", this).call(this, json);\n\n      this.target.fromArray(json.target);\n      return this;\n    }\n  }]);\n\n  return SeekBehavior;\n}(SteeringBehavior);\n\nvar centerOfMass = new Vector3();\n/**\r\n* This steering produces a steering force that moves a vehicle toward the center of mass of its neighbors.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments SteeringBehavior\r\n*/\n\nvar CohesionBehavior =\n/*#__PURE__*/\nfunction (_SteeringBehavior4) {\n  _inherits(CohesionBehavior, _SteeringBehavior4);\n\n  /**\r\n  * Constructs a new cohesion behavior.\r\n  */\n  function CohesionBehavior() {\n    var _this4;\n\n    _classCallCheck(this, CohesionBehavior);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(CohesionBehavior).call(this)); // internal behaviors\n\n    _this4._seek = new SeekBehavior();\n    return _this4;\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(CohesionBehavior, [{\n    key: \"calculate\",\n    value: function calculate(vehicle, force\n    /*, delta */\n    ) {\n      centerOfMass.set(0, 0, 0);\n      var neighbors = vehicle.neighbors; // iterate over all neighbors to calculate the center of mass\n\n      for (var _i13 = 0, l = neighbors.length; _i13 < l; _i13++) {\n        var neighbor = neighbors[_i13];\n        centerOfMass.add(neighbor.position);\n      }\n\n      if (neighbors.length > 0) {\n        centerOfMass.divideScalar(neighbors.length); // seek to it\n\n        this._seek.target = centerOfMass;\n\n        this._seek.calculate(vehicle, force); // the magnitude of cohesion is usually much larger than separation\n        // or alignment so it usually helps to normalize it\n\n\n        force.normalize();\n      }\n\n      return force;\n    }\n  }]);\n\n  return CohesionBehavior;\n}(SteeringBehavior);\n\nvar desiredVelocity$2 = new Vector3();\n/**\r\n* This steering behavior produces a force that steers an agent away from a target position.\r\n* It's the opposite of {@link SeekBehavior}.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments SteeringBehavior\r\n*/\n\nvar FleeBehavior =\n/*#__PURE__*/\nfunction (_SteeringBehavior5) {\n  _inherits(FleeBehavior, _SteeringBehavior5);\n\n  /**\r\n  * Constructs a new flee behavior.\r\n  *\r\n  * @param {Vector3} target - The target vector.\r\n  * @param {Number} panicDistance - The agent only flees from the target if it is inside this radius.\r\n  */\n  function FleeBehavior() {\n    var _this5;\n\n    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var panicDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\n    _classCallCheck(this, FleeBehavior);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(FleeBehavior).call(this));\n    /**\r\n    * The target vector.\r\n    * @type Vector3\r\n    */\n\n    _this5.target = target;\n    /**\r\n    * The agent only flees from the target if it is inside this radius.\r\n    * @type Number\r\n    * @default 10\r\n    */\n\n    _this5.panicDistance = panicDistance;\n    return _this5;\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(FleeBehavior, [{\n    key: \"calculate\",\n    value: function calculate(vehicle, force\n    /*, delta */\n    ) {\n      var target = this.target; // only flee if the target is within panic distance\n\n      var distanceToTargetSq = vehicle.position.squaredDistanceTo(target);\n\n      if (distanceToTargetSq <= this.panicDistance * this.panicDistance) {\n        // from here, the only difference compared to seek is that the desired\n        // velocity is calculated using a vector pointing in the opposite direction\n        desiredVelocity$2.subVectors(vehicle.position, target).normalize(); // if target and vehicle position are identical, choose default velocity\n\n        if (desiredVelocity$2.squaredLength() === 0) {\n          desiredVelocity$2.set(0, 0, 1);\n        }\n\n        desiredVelocity$2.multiplyScalar(vehicle.maxSpeed);\n        force.subVectors(desiredVelocity$2, vehicle.velocity);\n      }\n\n      return force;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(FleeBehavior.prototype), \"toJSON\", this).call(this);\n\n      json.target = this.target.toArray(new Array());\n      json.panicDistance = this.panicDistance;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {FleeBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(FleeBehavior.prototype), \"fromJSON\", this).call(this, json);\n\n      this.target.fromArray(json.target);\n      this.panicDistance = json.panicDistance;\n      return this;\n    }\n  }]);\n\n  return FleeBehavior;\n}(SteeringBehavior);\n\nvar displacement$2 = new Vector3();\nvar newPursuerVelocity = new Vector3();\nvar predictedPosition = new Vector3();\n/**\r\n* This steering behavior is is almost the same as {@link PursuitBehavior} except that\r\n* the agent flees from the estimated future position of the pursuer.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments SteeringBehavior\r\n*/\n\nvar EvadeBehavior =\n/*#__PURE__*/\nfunction (_SteeringBehavior6) {\n  _inherits(EvadeBehavior, _SteeringBehavior6);\n\n  /**\r\n  * Constructs a new evade behavior.\r\n  *\r\n  * @param {MovingEntity} pursuer - The agent to evade from.\r\n  * @param {Number} panicDistance - The agent only flees from the pursuer if it is inside this radius.\r\n  * @param {Number} predictionFactor - This factor determines how far the vehicle predicts the movement of the pursuer.\r\n  */\n  function EvadeBehavior() {\n    var _this6;\n\n    var pursuer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var panicDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    var predictionFactor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n    _classCallCheck(this, EvadeBehavior);\n\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(EvadeBehavior).call(this));\n    /**\r\n    * The agent to evade from.\r\n    * @type MovingEntity\r\n    * @default null\r\n    */\n\n    _this6.pursuer = pursuer;\n    /**\r\n    * The agent only flees from the pursuer if it is inside this radius.\r\n    * @type Number\r\n    * @default 10\r\n    */\n\n    _this6.panicDistance = panicDistance;\n    /**\r\n    * This factor determines how far the vehicle predicts the movement of the pursuer.\r\n    * @type Number\r\n    * @default 1\r\n    */\n\n    _this6.predictionFactor = predictionFactor; // internal behaviors\n\n    _this6._flee = new FleeBehavior();\n    return _this6;\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(EvadeBehavior, [{\n    key: \"calculate\",\n    value: function calculate(vehicle, force\n    /*, delta */\n    ) {\n      var pursuer = this.pursuer;\n      displacement$2.subVectors(pursuer.position, vehicle.position);\n      var lookAheadTime = displacement$2.length() / (vehicle.maxSpeed + pursuer.getSpeed());\n      lookAheadTime *= this.predictionFactor; // tweak the magnitude of the prediction\n      // calculate new velocity and predicted future position\n\n      newPursuerVelocity.copy(pursuer.velocity).multiplyScalar(lookAheadTime);\n      predictedPosition.addVectors(pursuer.position, newPursuerVelocity); // now flee away from predicted future position of the pursuer\n\n      this._flee.target = predictedPosition;\n      this._flee.panicDistance = this.panicDistance;\n\n      this._flee.calculate(vehicle, force);\n\n      return force;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(EvadeBehavior.prototype), \"toJSON\", this).call(this);\n\n      json.pursuer = this.pursuer ? this.pursuer.uuid : null;\n      json.panicDistance = this.panicDistance;\n      json.predictionFactor = this.predictionFactor;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {EvadeBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(EvadeBehavior.prototype), \"fromJSON\", this).call(this, json);\n\n      this.pursuer = json.pursuer;\n      this.panicDistance = json.panicDistance;\n      this.predictionFactor = json.predictionFactor;\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {EvadeBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      this.pursuer = entities.get(this.pursuer) || null;\n    }\n  }]);\n\n  return EvadeBehavior;\n}(SteeringBehavior);\n/**\r\n* Class for representing a walkable path.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar Path =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new path.\r\n  */\n  function Path() {\n    _classCallCheck(this, Path);\n\n    /**\r\n    * Whether this path is looped or not.\r\n    * @type Boolean\r\n    */\n    this.loop = false;\n    this._waypoints = new Array();\n    this._index = 0;\n  }\n  /**\r\n  * Adds the given waypoint to this path.\r\n  *\r\n  * @param {Vector3} waypoint - The waypoint to add.\r\n  * @return {Path} A reference to this path.\r\n  */\n\n\n  _createClass(Path, [{\n    key: \"add\",\n    value: function add(waypoint) {\n      this._waypoints.push(waypoint);\n\n      return this;\n    }\n    /**\r\n    * Clears the internal state of this path.\r\n    *\r\n    * @return {Path} A reference to this path.\r\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._waypoints.length = 0;\n      this._index = 0;\n      return this;\n    }\n    /**\r\n    * Returns the current active waypoint of this path.\r\n    *\r\n    * @return {Vector3} The current active waypoint.\r\n    */\n\n  }, {\n    key: \"current\",\n    value: function current() {\n      return this._waypoints[this._index];\n    }\n    /**\r\n    * Returns true if this path is not looped and the last waypoint is active.\r\n    *\r\n    * @return {Boolean} Whether this path is finished or not.\r\n    */\n\n  }, {\n    key: \"finished\",\n    value: function finished() {\n      var lastIndex = this._waypoints.length - 1;\n      return this.loop === true ? false : this._index === lastIndex;\n    }\n    /**\r\n    * Makes the next waypoint of this path active. If the path is looped and\r\n    * {@link Path#finished} returns true, the path starts from the beginning.\r\n    *\r\n    * @return {Path} A reference to this path.\r\n    */\n\n  }, {\n    key: \"advance\",\n    value: function advance() {\n      this._index++;\n\n      if (this._index === this._waypoints.length) {\n        if (this.loop === true) {\n          this._index = 0;\n        } else {\n          this._index--;\n        }\n      }\n\n      return this;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var data = {\n        type: this.constructor.name,\n        loop: this.loop,\n        _waypoints: new Array(),\n        _index: this._index\n      }; // waypoints\n\n      var waypoints = this._waypoints;\n\n      for (var _i14 = 0, l = waypoints.length; _i14 < l; _i14++) {\n        var waypoint = waypoints[_i14];\n\n        data._waypoints.push(waypoint.toArray(new Array()));\n      }\n\n      return data;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {Path} A reference to this path.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.loop = json.loop;\n      this._index = json._index; // waypoints\n\n      var waypointsJSON = json._waypoints;\n\n      for (var _i15 = 0, l = waypointsJSON.length; _i15 < l; _i15++) {\n        var waypointJSON = waypointsJSON[_i15];\n\n        this._waypoints.push(new Vector3().fromArray(waypointJSON));\n      }\n\n      return this;\n    }\n  }]);\n\n  return Path;\n}();\n/**\r\n* This steering behavior produces a force that moves a vehicle along a series of waypoints forming a path.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments SteeringBehavior\r\n*/\n\n\nvar FollowPathBehavior =\n/*#__PURE__*/\nfunction (_SteeringBehavior7) {\n  _inherits(FollowPathBehavior, _SteeringBehavior7);\n\n  /**\r\n  * Constructs a new follow path behavior.\r\n  *\r\n  * @param {Path} path - The path to follow.\r\n  * @param {Number} nextWaypointDistance - The distance the agent seeks for the next waypoint.\r\n  */\n  function FollowPathBehavior() {\n    var _this7;\n\n    var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Path();\n    var nextWaypointDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    _classCallCheck(this, FollowPathBehavior);\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(FollowPathBehavior).call(this));\n    /**\r\n    * The path to follow.\r\n    * @type Path\r\n    */\n\n    _this7.path = path;\n    /**\r\n    * The distance the agent seeks for the next waypoint.\r\n    * @type Number\r\n    * @default 1\r\n    */\n\n    _this7.nextWaypointDistance = nextWaypointDistance; // internal behaviors\n\n    _this7._arrive = new ArriveBehavior();\n    _this7._seek = new SeekBehavior();\n    return _this7;\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(FollowPathBehavior, [{\n    key: \"calculate\",\n    value: function calculate(vehicle, force\n    /*, delta */\n    ) {\n      var path = this.path; // calculate distance in square space from current waypoint to vehicle\n\n      var distanceSq = path.current().squaredDistanceTo(vehicle.position); // move to next waypoint if close enough to current target\n\n      if (distanceSq < this.nextWaypointDistance * this.nextWaypointDistance) {\n        path.advance();\n      }\n\n      var target = path.current();\n\n      if (path.finished() === true) {\n        this._arrive.target = target;\n\n        this._arrive.calculate(vehicle, force);\n      } else {\n        this._seek.target = target;\n\n        this._seek.calculate(vehicle, force);\n      }\n\n      return force;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(FollowPathBehavior.prototype), \"toJSON\", this).call(this);\n\n      json.path = this.path.toJSON();\n      json.nextWaypointDistance = this.nextWaypointDistance;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {FollowPathBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(FollowPathBehavior.prototype), \"fromJSON\", this).call(this, json);\n\n      this.path.fromJSON(json.path);\n      this.nextWaypointDistance = json.nextWaypointDistance;\n      return this;\n    }\n  }]);\n\n  return FollowPathBehavior;\n}(SteeringBehavior);\n\nvar midPoint = new Vector3();\nvar translation = new Vector3();\nvar predictedPosition1 = new Vector3();\nvar predictedPosition2 = new Vector3();\n/**\r\n* This steering behavior produces a force that moves a vehicle to the midpoint\r\n* of the imaginary line connecting two other agents.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments SteeringBehavior\r\n*/\n\nvar InterposeBehavior =\n/*#__PURE__*/\nfunction (_SteeringBehavior8) {\n  _inherits(InterposeBehavior, _SteeringBehavior8);\n\n  /**\r\n  * Constructs a new interpose behavior.\r\n  *\r\n  * @param {MovingEntity} entity1 - The first agent.\r\n  * @param {MovingEntity} entity2 - The second agent.\r\n  * @param {Number} deceleration - The amount of deceleration.\r\n  */\n  function InterposeBehavior() {\n    var _this8;\n\n    var entity1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var entity2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var deceleration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n\n    _classCallCheck(this, InterposeBehavior);\n\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(InterposeBehavior).call(this));\n    /**\r\n    * The first agent.\r\n    * @type MovingEntity\r\n    * @default null\r\n    */\n\n    _this8.entity1 = entity1;\n    /**\r\n    * The second agent.\r\n    * @type MovingEntity\r\n    * @default null\r\n    */\n\n    _this8.entity2 = entity2;\n    /**\r\n    * The amount of deceleration.\r\n    * @type Number\r\n    * @default 3\r\n    */\n\n    _this8.deceleration = deceleration; // internal behaviors\n\n    _this8._arrive = new ArriveBehavior();\n    return _this8;\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(InterposeBehavior, [{\n    key: \"calculate\",\n    value: function calculate(vehicle, force\n    /*, delta */\n    ) {\n      var entity1 = this.entity1;\n      var entity2 = this.entity2; // first we need to figure out where the two entities are going to be\n      // in the future. This is approximated by determining the time\n      // taken to reach the mid way point at the current time at max speed\n\n      midPoint.addVectors(entity1.position, entity2.position).multiplyScalar(0.5);\n      var time = vehicle.position.distanceTo(midPoint) / vehicle.maxSpeed; // now we have the time, we assume that entity 1 and entity 2 will\n      // continue on a straight trajectory and extrapolate to get their future positions\n\n      translation.copy(entity1.velocity).multiplyScalar(time);\n      predictedPosition1.addVectors(entity1.position, translation);\n      translation.copy(entity2.velocity).multiplyScalar(time);\n      predictedPosition2.addVectors(entity2.position, translation); // calculate the mid point of these predicted positions\n\n      midPoint.addVectors(predictedPosition1, predictedPosition2).multiplyScalar(0.5); // then steer to arrive at it\n\n      this._arrive.deceleration = this.deceleration;\n      this._arrive.target = midPoint;\n\n      this._arrive.calculate(vehicle, force);\n\n      return force;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(InterposeBehavior.prototype), \"toJSON\", this).call(this);\n\n      json.entity1 = this.entity1 ? this.entity1.uuid : null;\n      json.entity2 = this.entity2 ? this.entity2.uuid : null;\n      json.deceleration = this.deceleration;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {InterposeBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(InterposeBehavior.prototype), \"fromJSON\", this).call(this, json);\n\n      this.entity1 = json.entity1;\n      this.entity2 = json.entity2;\n      this.deceleration = json.deceleration;\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {InterposeBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      this.entity1 = entities.get(this.entity1) || null;\n      this.entity2 = entities.get(this.entity2) || null;\n    }\n  }]);\n\n  return InterposeBehavior;\n}(SteeringBehavior);\n\nvar vector$1 = new Vector3();\nvar center = new Vector3();\nvar size = new Vector3();\nvar points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];\n/**\r\n* Class representing an axis-aligned bounding box (AABB).\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar AABB =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new AABB with the given values.\r\n  *\r\n  * @param {Vector3} min - The minimum bounds of the AABB.\r\n  * @param {Vector3} max - The maximum bounds of the AABB.\r\n  */\n  function AABB() {\n    var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n\n    _classCallCheck(this, AABB);\n\n    /**\r\n    * The minimum bounds of the AABB.\r\n    * @type Vector3\r\n    */\n    this.min = min;\n    /**\r\n    * The maximum bounds of the AABB.\r\n    * @type Vector3\r\n    */\n\n    this.max = max;\n  }\n  /**\r\n  * Sets the given values to this AABB.\r\n  *\r\n  * @param {Vector3} min - The minimum bounds of the AABB.\r\n  * @param {Vector3} max - The maximum bounds of the AABB.\r\n  * @return {AABB} A reference to this AABB.\r\n  */\n\n\n  _createClass(AABB, [{\n    key: \"set\",\n    value: function set(min, max) {\n      this.min = min;\n      this.max = max;\n      return this;\n    }\n    /**\r\n    * Copies all values from the given AABB to this AABB.\r\n    *\r\n    * @param {AABB} aabb - The AABB to copy.\r\n    * @return {AABB} A reference to this AABB.\r\n    */\n\n  }, {\n    key: \"copy\",\n    value: function copy(aabb) {\n      this.min.copy(aabb.min);\n      this.max.copy(aabb.max);\n      return this;\n    }\n    /**\r\n    * Creates a new AABB and copies all values from this AABB.\r\n    *\r\n    * @return {AABB} A new AABB.\r\n    */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\r\n    * Ensures the given point is inside this AABB and stores\r\n    * the result in the given vector.\r\n    *\r\n    * @param {Vector3} point - A point in 3D space.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"clampPoint\",\n    value: function clampPoint(point, result) {\n      result.copy(point).clamp(this.min, this.max);\n      return result;\n    }\n    /**\r\n    * Returns true if the given point is inside this AABB.\r\n    *\r\n    * @param {Vector3} point - A point in 3D space.\r\n    * @return {Boolean} The result of the containments test.\r\n    */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;\n    }\n    /**\r\n    * Expands this AABB by the given point. So after this method call,\r\n    * the given point lies inside the AABB.\r\n    *\r\n    * @param {Vector3} point - A point in 3D space.\r\n    * @return {AABB} A reference to this AABB.\r\n    */\n\n  }, {\n    key: \"expand\",\n    value: function expand(point) {\n      this.min.min(point);\n      this.max.max(point);\n      return this;\n    }\n    /**\r\n    * Computes the center point of this AABB and stores it into the given vector.\r\n    *\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"getCenter\",\n    value: function getCenter(result) {\n      return result.addVectors(this.min, this.max).multiplyScalar(0.5);\n    }\n    /**\r\n    * Computes the size (width, height, depth) of this AABB and stores it into the given vector.\r\n    *\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"getSize\",\n    value: function getSize(result) {\n      return result.subVectors(this.max, this.min);\n    }\n    /**\r\n    * Returns true if the given AABB intersects this AABB.\r\n    *\r\n    * @param {AABB} aabb - The AABB to test.\r\n    * @return {Boolean} The result of the intersection test.\r\n    */\n\n  }, {\n    key: \"intersectsAABB\",\n    value: function intersectsAABB(aabb) {\n      return aabb.max.x < this.min.x || aabb.min.x > this.max.x || aabb.max.y < this.min.y || aabb.min.y > this.max.y || aabb.max.z < this.min.z || aabb.min.z > this.max.z ? false : true;\n    }\n    /**\r\n    * Returns true if the given bounding sphere intersects this AABB.\r\n    *\r\n    * @param {BoundingSphere} sphere - The bounding sphere to test.\r\n    * @return {Boolean} The result of the intersection test.\r\n    */\n\n  }, {\n    key: \"intersectsBoundingSphere\",\n    value: function intersectsBoundingSphere(sphere) {\n      // find the point on the AABB closest to the sphere center\n      this.clampPoint(sphere.center, vector$1); // if that point is inside the sphere, the AABB and sphere intersect.\n\n      return vector$1.squaredDistanceTo(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    /**\r\n    * Returns true if the given plane intersects this AABB.\r\n    *\r\n    * Reference: Testing Box Against Plane in Real-Time Collision Detection\r\n    * by Christer Ericson (chapter 5.2.3)\r\n    *\r\n    * @param {Plane} plane - The plane to test.\r\n    * @return {Boolean} The result of the intersection test.\r\n    */\n\n  }, {\n    key: \"intersectsPlane\",\n    value: function intersectsPlane(plane) {\n      var normal = plane.normal;\n      this.getCenter(center);\n      size.subVectors(this.max, center); // positive extends\n      // compute the projection interval radius of b onto L(t) = c + t * plane.normal\n\n      var r = size.x * Math.abs(normal.x) + size.y * Math.abs(normal.y) + size.z * Math.abs(normal.z); // compute distance of box center from plane\n\n      var s = plane.distanceToPoint(center);\n      return Math.abs(s) <= r;\n    }\n    /**\r\n    * Returns the normal for a given point on this AABB's surface.\r\n    *\r\n    * @param {Vector3} point - The point on the surface\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"getNormalFromSurfacePoint\",\n    value: function getNormalFromSurfacePoint(point, result) {\n      // from https://www.gamedev.net/forums/topic/551816-finding-the-aabb-surface-normal-from-an-intersection-point-on-aabb/\n      result.set(0, 0, 0);\n      var distance;\n      var minDistance = Infinity;\n      this.getCenter(center);\n      this.getSize(size); // transform point into local space of AABB\n\n      vector$1.copy(point).sub(center); // x-axis\n\n      distance = Math.abs(size.x - Math.abs(vector$1.x));\n\n      if (distance < minDistance) {\n        minDistance = distance;\n        result.set(1 * Math.sign(vector$1.x), 0, 0);\n      } // y-axis\n\n\n      distance = Math.abs(size.y - Math.abs(vector$1.y));\n\n      if (distance < minDistance) {\n        minDistance = distance;\n        result.set(0, 1 * Math.sign(vector$1.y), 0);\n      } // z-axis\n\n\n      distance = Math.abs(size.z - Math.abs(vector$1.z));\n\n      if (distance < minDistance) {\n        result.set(0, 0, 1 * Math.sign(vector$1.z));\n      }\n\n      return result;\n    }\n    /**\r\n    * Sets the values of the AABB from the given center and size vector.\r\n    *\r\n    * @param {Vector3} center - The center point of the AABB.\r\n    * @param {Vector3} size - The size of the AABB per axis.\r\n    * @return {AABB} A reference to this AABB.\r\n    */\n\n  }, {\n    key: \"fromCenterAndSize\",\n    value: function fromCenterAndSize(center, size) {\n      vector$1.copy(size).multiplyScalar(0.5); // compute half size\n\n      this.min.copy(center).sub(vector$1);\n      this.max.copy(center).add(vector$1);\n      return this;\n    }\n    /**\r\n    * Computes an AABB that encloses the given set of points.\r\n    *\r\n    * @param {Array} points - An array of 3D vectors representing points in 3D space.\r\n    * @return {AABB} A reference to this AABB.\r\n    */\n\n  }, {\n    key: \"fromPoints\",\n    value: function fromPoints(points) {\n      this.min.set(Infinity, Infinity, Infinity);\n      this.max.set(-Infinity, -Infinity, -Infinity);\n\n      for (var _i16 = 0, l = points.length; _i16 < l; _i16++) {\n        this.expand(points[_i16]);\n      }\n\n      return this;\n    }\n    /**\r\n    * Transforms this AABB with the given 4x4 transformation matrix.\r\n    *\r\n    * @param {Matrix4} matrix - The 4x4 transformation matrix.\r\n    * @return {AABB} A reference to this AABB.\r\n    */\n\n  }, {\n    key: \"applyMatrix4\",\n    value: function applyMatrix4(matrix) {\n      var min = this.min;\n      var max = this.max;\n      points[0].set(min.x, min.y, min.z).applyMatrix4(matrix);\n      points[1].set(min.x, min.y, max.z).applyMatrix4(matrix);\n      points[2].set(min.x, max.y, min.z).applyMatrix4(matrix);\n      points[3].set(min.x, max.y, max.z).applyMatrix4(matrix);\n      points[4].set(max.x, min.y, min.z).applyMatrix4(matrix);\n      points[5].set(max.x, min.y, max.z).applyMatrix4(matrix);\n      points[6].set(max.x, max.y, min.z).applyMatrix4(matrix);\n      points[7].set(max.x, max.y, max.z).applyMatrix4(matrix);\n      return this.fromPoints(points);\n    }\n    /**\r\n    * Returns true if the given AABB is deep equal with this AABB.\r\n    *\r\n    * @param {AABB} aabb - The AABB to test.\r\n    * @return {Boolean} The result of the equality test.\r\n    */\n\n  }, {\n    key: \"equals\",\n    value: function equals(aabb) {\n      return aabb.min.equals(this.min) && aabb.max.equals(this.max);\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.constructor.name,\n        min: this.min.toArray(new Array()),\n        max: this.max.toArray(new Array())\n      };\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {AABB} A reference to this AABB.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.min.fromArray(json.min);\n      this.max.fromArray(json.max);\n      return this;\n    }\n  }]);\n\n  return AABB;\n}();\n\nvar aabb = new AABB();\n/**\r\n* Class representing a bounding sphere.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar BoundingSphere =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new bounding sphere with the given values.\r\n  *\r\n  * @param {Vector3} center - The center position of the bounding sphere.\r\n  * @param {Number} radius - The radius of the bounding sphere.\r\n  */\n  function BoundingSphere() {\n    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, BoundingSphere);\n\n    /**\r\n    * The center position of the bounding sphere.\r\n    * @type Vector3\r\n    */\n    this.center = center;\n    /**\r\n    * The radius of the bounding sphere.\r\n    * @type Number\r\n    */\n\n    this.radius = radius;\n  }\n  /**\r\n  * Sets the given values to this bounding sphere.\r\n  *\r\n  * @param {Vector3} center - The center position of the bounding sphere.\r\n  * @param {Number} radius - The radius of the bounding sphere.\r\n  * @return {BoundingSphere} A reference to this bounding sphere.\r\n  */\n\n\n  _createClass(BoundingSphere, [{\n    key: \"set\",\n    value: function set(center, radius) {\n      this.center = center;\n      this.radius = radius;\n      return this;\n    }\n    /**\r\n    * Copies all values from the given bounding sphere to this bounding sphere.\r\n    *\r\n    * @param {BoundingSphere} sphere - The bounding sphere to copy.\r\n    * @return {BoundingSphere} A reference to this bounding sphere.\r\n    */\n\n  }, {\n    key: \"copy\",\n    value: function copy(sphere) {\n      this.center.copy(sphere.center);\n      this.radius = sphere.radius;\n      return this;\n    }\n    /**\r\n    * Creates a new bounding sphere and copies all values from this bounding sphere.\r\n    *\r\n    * @return {BoundingSphere} A new bounding sphere.\r\n    */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\r\n    * Ensures the given point is inside this bounding sphere and stores\r\n    * the result in the given vector.\r\n    *\r\n    * @param {Vector3} point - A point in 3D space.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"clampPoint\",\n    value: function clampPoint(point, result) {\n      result.copy(point);\n      var squaredDistance = this.center.squaredDistanceTo(point);\n\n      if (squaredDistance > this.radius * this.radius) {\n        result.sub(this.center).normalize();\n        result.multiplyScalar(this.radius).add(this.center);\n      }\n\n      return result;\n    }\n    /**\r\n    * Returns true if the given point is inside this bounding sphere.\r\n    *\r\n    * @param {Vector3} point - A point in 3D space.\r\n    * @return {Boolean} The result of the containments test.\r\n    */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      return point.squaredDistanceTo(this.center) <= this.radius * this.radius;\n    }\n    /**\r\n    * Returns true if the given bounding sphere intersects this bounding sphere.\r\n    *\r\n    * @param {BoundingSphere} sphere - The bounding sphere to test.\r\n    * @return {Boolean} The result of the intersection test.\r\n    */\n\n  }, {\n    key: \"intersectsBoundingSphere\",\n    value: function intersectsBoundingSphere(sphere) {\n      var radius = this.radius + sphere.radius;\n      return sphere.center.squaredDistanceTo(this.center) <= radius * radius;\n    }\n    /**\r\n    * Returns true if the given plane intersects this bounding sphere.\r\n    *\r\n    * Reference: Testing Sphere Against Plane in Real-Time Collision Detection\r\n    * by Christer Ericson (chapter 5.2.2)\r\n    *\r\n    * @param {Plane} plane - The plane to test.\r\n    * @return {Boolean} The result of the intersection test.\r\n    */\n\n  }, {\n    key: \"intersectsPlane\",\n    value: function intersectsPlane(plane) {\n      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n    }\n    /**\r\n    * Returns the normal for a given point on this bounding sphere's surface.\r\n    *\r\n    * @param {Vector3} point - The point on the surface\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"getNormalFromSurfacePoint\",\n    value: function getNormalFromSurfacePoint(point, result) {\n      return result.subVectors(point, this.center).normalize();\n    }\n    /**\r\n    * Computes a bounding sphere that encloses the given set of points.\r\n    *\r\n    * @param {Array} points - An array of 3D vectors representing points in 3D space.\r\n    * @return {BoundingSphere} A reference to this bounding sphere.\r\n    */\n\n  }, {\n    key: \"fromPoints\",\n    value: function fromPoints(points) {\n      // Using an AABB is a simple way to compute a bounding sphere for a given set\n      // of points. However, there are other more complex algorithms that produce a\n      // more tight bounding sphere. For now, this approach is a good start.\n      aabb.fromPoints(points);\n      aabb.getCenter(this.center);\n      this.radius = this.center.distanceTo(aabb.max);\n      return this;\n    }\n    /**\r\n    * Transforms this bounding sphere with the given 4x4 transformation matrix.\r\n    *\r\n    * @param {Matrix4} matrix - The 4x4 transformation matrix.\r\n    * @return {BoundingSphere} A reference to this bounding sphere.\r\n    */\n\n  }, {\n    key: \"applyMatrix4\",\n    value: function applyMatrix4(matrix) {\n      this.center.applyMatrix4(matrix);\n      this.radius = this.radius * matrix.getMaxScale();\n      return this;\n    }\n    /**\r\n    * Returns true if the given bounding sphere is deep equal with this bounding sphere.\r\n    *\r\n    * @param {BoundingSphere} sphere - The bounding sphere to test.\r\n    * @return {Boolean} The result of the equality test.\r\n    */\n\n  }, {\n    key: \"equals\",\n    value: function equals(sphere) {\n      return sphere.center.equals(this.center) && sphere.radius === this.radius;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.constructor.name,\n        center: this.center.toArray(new Array()),\n        radius: this.radius\n      };\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {BoundingSphere} A reference to this bounding sphere.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.center.fromArray(json.center);\n      this.radius = json.radius;\n      return this;\n    }\n  }]);\n\n  return BoundingSphere;\n}();\n\nvar v1$1 = new Vector3();\nvar edge1 = new Vector3();\nvar edge2 = new Vector3();\nvar normal = new Vector3();\nvar size$1 = new Vector3();\nvar matrix$1 = new Matrix4();\nvar inverse = new Matrix4();\nvar aabb$1 = new AABB();\n/**\r\n* Class representing a ray in 3D space.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar Ray =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new ray with the given values.\r\n  *\r\n  * @param {Vector3} origin - The origin of the ray.\r\n  * @param {Vector3} direction - The direction of the ray.\r\n  */\n  function Ray() {\n    var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n\n    _classCallCheck(this, Ray);\n\n    /**\r\n    * The origin of the ray.\r\n    * @type Vector3\r\n    */\n    this.origin = origin;\n    /**\r\n    * The direction of the ray.\r\n    * @type Vector3\r\n    */\n\n    this.direction = direction;\n  }\n  /**\r\n  * Sets the given values to this ray.\r\n  *\r\n  * @param {Vector3} origin - The origin of the ray.\r\n  * @param {Vector3} direction - The direction of the ray.\r\n  * @return {Ray} A reference to this ray.\r\n  */\n\n\n  _createClass(Ray, [{\n    key: \"set\",\n    value: function set(origin, direction) {\n      this.origin = origin;\n      this.direction = direction;\n      return this;\n    }\n    /**\r\n    * Copies all values from the given ray to this ray.\r\n    *\r\n    * @param {Ray} ray - The ray to copy.\r\n    * @return {Ray} A reference to this ray.\r\n    */\n\n  }, {\n    key: \"copy\",\n    value: function copy(ray) {\n      this.origin.copy(ray.origin);\n      this.direction.copy(ray.direction);\n      return this;\n    }\n    /**\r\n    * Creates a new ray and copies all values from this ray.\r\n    *\r\n    * @return {Ray} A new ray.\r\n    */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\r\n    * Computes a position on the ray according to the given t value\r\n    * and stores the result in the given 3D vector. The t value has a range of\r\n    * [0, Infinity] where 0 means the position is equal with the origin of the ray.\r\n    *\r\n    * @param {Number} t - A scalar value representing a position on the ray.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"at\",\n    value: function at(t, result) {\n      // t has to be zero or positive\n      return result.copy(this.direction).multiplyScalar(t).add(this.origin);\n    }\n    /**\r\n    * Performs a ray/sphere intersection test and stores the intersection point\r\n    * to the given 3D vector. If no intersection is detected, *null* is returned.\r\n    *\r\n    * @param {BoundingSphere} sphere - A bounding sphere.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"intersectBoundingSphere\",\n    value: function intersectBoundingSphere(sphere, result) {\n      v1$1.subVectors(sphere.center, this.origin);\n      var tca = v1$1.dot(this.direction);\n      var d2 = v1$1.dot(v1$1) - tca * tca;\n      var radius2 = sphere.radius * sphere.radius;\n      if (d2 > radius2) return null;\n      var thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere\n\n      var t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere\n\n      var t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null\n\n      if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:\n      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n      // in order to always return an intersect point that is in front of the ray.\n\n      if (t0 < 0) return this.at(t1, result); // else t0 is in front of the ray, so return the first collision point scaled by t0\n\n      return this.at(t0, result);\n    }\n    /**\r\n    * Performs a ray/sphere intersection test. Returns either true or false if\r\n    * there is a intersection or not.\r\n    *\r\n    * @param {BoundingSphere} sphere - A bounding sphere.\r\n    * @return {boolean} Whether there is an intersection or not.\r\n    */\n\n  }, {\n    key: \"intersectsBoundingSphere\",\n    value: function intersectsBoundingSphere(sphere) {\n      var v1 = new Vector3();\n      var squaredDistanceToPoint;\n      var directionDistance = v1.subVectors(sphere.center, this.origin).dot(this.direction);\n\n      if (directionDistance < 0) {\n        // sphere's center behind the ray\n        squaredDistanceToPoint = this.origin.squaredDistanceTo(sphere.center);\n      } else {\n        v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n        squaredDistanceToPoint = v1.squaredDistanceTo(sphere.center);\n      }\n\n      return squaredDistanceToPoint <= sphere.radius * sphere.radius;\n    }\n    /**\r\n    * Performs a ray/AABB intersection test and stores the intersection point\r\n    * to the given 3D vector. If no intersection is detected, *null* is returned.\r\n    *\r\n    * @param {AABB} aabb - An AABB.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"intersectAABB\",\n    value: function intersectAABB(aabb, result) {\n      var tmin, tmax, tymin, tymax, tzmin, tzmax;\n      var invdirx = 1 / this.direction.x,\n          invdiry = 1 / this.direction.y,\n          invdirz = 1 / this.direction.z;\n      var origin = this.origin;\n\n      if (invdirx >= 0) {\n        tmin = (aabb.min.x - origin.x) * invdirx;\n        tmax = (aabb.max.x - origin.x) * invdirx;\n      } else {\n        tmin = (aabb.max.x - origin.x) * invdirx;\n        tmax = (aabb.min.x - origin.x) * invdirx;\n      }\n\n      if (invdiry >= 0) {\n        tymin = (aabb.min.y - origin.y) * invdiry;\n        tymax = (aabb.max.y - origin.y) * invdiry;\n      } else {\n        tymin = (aabb.max.y - origin.y) * invdiry;\n        tymax = (aabb.min.y - origin.y) * invdiry;\n      }\n\n      if (tmin > tymax || tymin > tmax) return null; // these lines also handle the case where tmin or tmax is NaN\n      // (result of 0 * Infinity). x !== x returns true if x is NaN\n\n      if (tymin > tmin || tmin !== tmin) tmin = tymin;\n      if (tymax < tmax || tmax !== tmax) tmax = tymax;\n\n      if (invdirz >= 0) {\n        tzmin = (aabb.min.z - origin.z) * invdirz;\n        tzmax = (aabb.max.z - origin.z) * invdirz;\n      } else {\n        tzmin = (aabb.max.z - origin.z) * invdirz;\n        tzmax = (aabb.min.z - origin.z) * invdirz;\n      }\n\n      if (tmin > tzmax || tzmin > tmax) return null;\n      if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n      if (tzmax < tmax || tmax !== tmax) tmax = tzmax; // return point closest to the ray (positive side)\n\n      if (tmax < 0) return null;\n      return this.at(tmin >= 0 ? tmin : tmax, result);\n    }\n    /**\r\n    * Performs a ray/AABB intersection test. Returns either true or false if\r\n    * there is a intersection or not.\r\n    *\r\n    * @param {AABB} aabb - An axis-aligned bounding box.\r\n    * @return {boolean} Whether there is an intersection or not.\r\n    */\n\n  }, {\n    key: \"intersectsAABB\",\n    value: function intersectsAABB(aabb) {\n      return this.intersectAABB(aabb, v1$1) !== null;\n    }\n    /**\r\n    * Performs a ray/plane intersection test and stores the intersection point\r\n    * to the given 3D vector. If no intersection is detected, *null* is returned.\r\n    *\r\n    * @param {Plane} plane - A plane.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"intersectPlane\",\n    value: function intersectPlane(plane, result) {\n      var t;\n      var denominator = plane.normal.dot(this.direction);\n\n      if (denominator === 0) {\n        if (plane.distanceToPoint(this.origin) === 0) {\n          // ray is coplanar\n          t = 0;\n        } else {\n          // ray is parallel, no intersection\n          return null;\n        }\n      } else {\n        t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n      } // there is no intersection if t is negative\n\n\n      return t >= 0 ? this.at(t, result) : null;\n    }\n    /**\r\n    * Performs a ray/plane intersection test. Returns either true or false if\r\n    * there is a intersection or not.\r\n    *\r\n    * @param {Plane} plane - A plane.\r\n    * @return {boolean} Whether there is an intersection or not.\r\n    */\n\n  }, {\n    key: \"intersectsPlane\",\n    value: function intersectsPlane(plane) {\n      // check if the ray lies on the plane first\n      var distToPoint = plane.distanceToPoint(this.origin);\n\n      if (distToPoint === 0) {\n        return true;\n      }\n\n      var denominator = plane.normal.dot(this.direction);\n\n      if (denominator * distToPoint < 0) {\n        return true;\n      } // ray origin is behind the plane (and is pointing behind it)\n\n\n      return false;\n    }\n    /**\r\n    * Performs a ray/OBB intersection test and stores the intersection point\r\n    * to the given 3D vector. If no intersection is detected, *null* is returned.\r\n    *\r\n    * @param {OBB} obb - An orientend bounding box.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"intersectOBB\",\n    value: function intersectOBB(obb, result) {\n      // the idea is to perform the intersection test in the local space\n      // of the OBB.\n      obb.getSize(size$1);\n      aabb$1.fromCenterAndSize(v1$1.set(0, 0, 0), size$1);\n      matrix$1.fromMatrix3(obb.rotation);\n      matrix$1.setPosition(obb.center); // transform ray to the local space of the OBB\n\n      localRay.copy(this).applyMatrix4(matrix$1.getInverse(inverse)); // perform ray <-> AABB intersection test\n\n      if (localRay.intersectAABB(aabb$1, result)) {\n        // transform the intersection point back to world space\n        return result.applyMatrix4(matrix$1);\n      } else {\n        return null;\n      }\n    }\n    /**\r\n    * Performs a ray/OBB intersection test. Returns either true or false if\r\n    * there is a intersection or not.\r\n    *\r\n    * @param {OBB} obb - An orientend bounding box.\r\n    * @return {boolean} Whether there is an intersection or not.\r\n    */\n\n  }, {\n    key: \"intersectsOBB\",\n    value: function intersectsOBB(obb) {\n      return this.intersectOBB(obb, v1$1) !== null;\n    }\n    /**\r\n    * Performs a ray/convex hull intersection test and stores the intersection point\r\n    * to the given 3D vector. If no intersection is detected, *null* is returned.\r\n    * The implementation is based on \"Fast Ray-Convex Polyhedron Intersection\"\r\n    * by Eric Haines, GRAPHICS GEMS II\r\n    *\r\n    * @param {ConvexHull} convexHull - A convex hull.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"intersectConvexHull\",\n    value: function intersectConvexHull(convexHull, result) {\n      var faces = convexHull.faces;\n      var tNear = -Infinity;\n      var tFar = Infinity;\n\n      for (var _i17 = 0, l = faces.length; _i17 < l; _i17++) {\n        var face = faces[_i17];\n        var _plane = face.plane;\n\n        var vN = _plane.distanceToPoint(this.origin);\n\n        var vD = _plane.normal.dot(this.direction); // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n        // the ray is turned away or parallel to the plane, there is no intersection\n\n\n        if (vN > 0 && vD >= 0) return null; // compute the distance from the rays origin to the intersection with the plane\n\n        var _t4 = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. since the ray has a direction, the intersection point\n        // would lie \"behind\" the origin with a negative distance\n\n\n        if (_t4 <= 0) continue; // now categorized plane as front-facing or back-facing\n\n        if (vD > 0) {\n          //  plane faces away from the ray, so this plane is a back-face\n          tFar = Math.min(_t4, tFar);\n        } else {\n          // front-face\n          tNear = Math.max(_t4, tNear);\n        }\n\n        if (tNear > tFar) {\n          // if tNear ever is greater than tFar, the ray must miss the convex hull\n          return null;\n        }\n      } // evaluate intersection point\n      // always try tNear first since its the closer intersection point\n\n\n      if (tNear !== -Infinity) {\n        this.at(tNear, result);\n      } else {\n        this.at(tFar, result);\n      }\n\n      return result;\n    }\n    /**\r\n    * Performs a ray/convex hull intersection test. Returns either true or false if\r\n    * there is a intersection or not.\r\n    *\r\n    * @param {ConvexHull} convexHull - A convex hull.\r\n    * @return {boolean} Whether there is an intersection or not.\r\n    */\n\n  }, {\n    key: \"intersectsConvexHull\",\n    value: function intersectsConvexHull(convexHull) {\n      return this.intersectConvexHull(convexHull, v1$1) !== null;\n    }\n    /**\r\n    * Performs a ray/triangle intersection test and stores the intersection point\r\n    * to the given 3D vector. If no intersection is detected, *null* is returned.\r\n    *\r\n    * @param {Triangle} triangle - A triangle.\r\n    * @param {Boolean} backfaceCulling - Whether back face culling is active or not.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"intersectTriangle\",\n    value: function intersectTriangle(triangle, backfaceCulling, result) {\n      // reference: https://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n      var a = triangle.a;\n      var b = triangle.b;\n      var c = triangle.c;\n      edge1.subVectors(b, a);\n      edge2.subVectors(c, a);\n      normal.crossVectors(edge1, edge2);\n      var DdN = this.direction.dot(normal);\n      var sign;\n\n      if (DdN > 0) {\n        if (backfaceCulling) return null;\n        sign = 1;\n      } else if (DdN < 0) {\n        sign = -1;\n        DdN = -DdN;\n      } else {\n        return null;\n      }\n\n      v1$1.subVectors(this.origin, a);\n      var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(v1$1, edge2)); // b1 < 0, no intersection\n\n      if (DdQxE2 < 0) {\n        return null;\n      }\n\n      var DdE1xQ = sign * this.direction.dot(edge1.cross(v1$1)); // b2 < 0, no intersection\n\n      if (DdE1xQ < 0) {\n        return null;\n      } // b1 + b2 > 1, no intersection\n\n\n      if (DdQxE2 + DdE1xQ > DdN) {\n        return null;\n      } // line intersects triangle, check if ray does\n\n\n      var QdN = -sign * v1$1.dot(normal); // t < 0, no intersection\n\n      if (QdN < 0) {\n        return null;\n      } // ray intersects triangle\n\n\n      return this.at(QdN / DdN, result);\n    }\n    /**\r\n    * Performs a ray/BVH intersection test and stores the intersection point\r\n    * to the given 3D vector. If no intersection is detected, *null* is returned.\r\n    *\r\n    * @param {BVH} bvh - A BVH.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"intersectBVH\",\n    value: function intersectBVH(bvh, result) {\n      return bvh.root.intersectRay(this, result);\n    }\n    /**\r\n    * Performs a ray/BVH intersection test. Returns either true or false if\r\n    * there is a intersection or not.\r\n    *\r\n    * @param {BVH} bvh - A BVH.\r\n    * @return {boolean} Whether there is an intersection or not.\r\n    */\n\n  }, {\n    key: \"intersectsBVH\",\n    value: function intersectsBVH(bvh) {\n      return bvh.root.intersectsRay(this);\n    }\n    /**\r\n    * Transforms this ray by the given 4x4 matrix.\r\n    *\r\n    * @param {Matrix4} m - The 4x4 matrix.\r\n    * @return {Ray} A reference to this ray.\r\n    */\n\n  }, {\n    key: \"applyMatrix4\",\n    value: function applyMatrix4(m) {\n      this.origin.applyMatrix4(m);\n      this.direction.transformDirection(m);\n      return this;\n    }\n    /**\r\n    * Returns true if the given ray is deep equal with this ray.\r\n    *\r\n    * @param {Ray} ray - The ray to test.\r\n    * @return {Boolean} The result of the equality test.\r\n    */\n\n  }, {\n    key: \"equals\",\n    value: function equals(ray) {\n      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n    }\n  }]);\n\n  return Ray;\n}();\n\nvar localRay = new Ray();\nvar inverse$1 = new Matrix4();\nvar localPositionOfObstacle = new Vector3();\nvar localPositionOfClosestObstacle = new Vector3();\nvar intersectionPoint = new Vector3();\nvar boundingSphere = new BoundingSphere();\nvar ray = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 1));\n/**\r\n* This steering behavior produces a force so a vehicle avoids obstacles lying in its path.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @author {@link https://github.com/robp94|robp94}\r\n* @augments SteeringBehavior\r\n*/\n\nvar ObstacleAvoidanceBehavior =\n/*#__PURE__*/\nfunction (_SteeringBehavior9) {\n  _inherits(ObstacleAvoidanceBehavior, _SteeringBehavior9);\n\n  /**\r\n  * Constructs a new obstacle avoidance behavior.\r\n  *\r\n  * @param {Array} obstacles - An Array with obstacle of type {@link GameEntity}.\r\n  */\n  function ObstacleAvoidanceBehavior() {\n    var _this9;\n\n    var obstacles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Array();\n\n    _classCallCheck(this, ObstacleAvoidanceBehavior);\n\n    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(ObstacleAvoidanceBehavior).call(this));\n    /**\r\n    * An Array with obstacle of type {@link GameEntity}.\r\n    * @type Array\r\n    */\n\n    _this9.obstacles = obstacles;\n    /**\r\n    * This factor determines how much the vehicle decelerates if an intersection occurs.\r\n    * @type Number\r\n    * @default 0.2\r\n    */\n\n    _this9.brakingWeight = 0.2;\n    /**\r\n    * Minimum length of the detection box used for intersection tests.\r\n    * @type Number\r\n    * @default 4\r\n    */\n\n    _this9.dBoxMinLength = 4; //\n\n    return _this9;\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(ObstacleAvoidanceBehavior, [{\n    key: \"calculate\",\n    value: function calculate(vehicle, force\n    /*, delta */\n    ) {\n      var obstacles = this.obstacles; // this will keep track of the closest intersecting obstacle\n\n      var closestObstacle = null; // this will be used to track the distance to the closest obstacle\n\n      var distanceToClosestObstacle = Infinity; // the detection box length is proportional to the agent's velocity\n\n      var dBoxLength = this.dBoxMinLength + vehicle.getSpeed() / vehicle.maxSpeed * this.dBoxMinLength;\n      vehicle.worldMatrix.getInverse(inverse$1);\n\n      for (var _i18 = 0, l = obstacles.length; _i18 < l; _i18++) {\n        var obstacle = obstacles[_i18];\n        if (obstacle === vehicle) continue; // calculate this obstacle's position in local space of the vehicle\n\n        localPositionOfObstacle.copy(obstacle.position).applyMatrix4(inverse$1); // if the local position has a positive z value then it must lay behind the agent.\n        // besides the absolute z value must be smaller than the length of the detection box\n\n        if (localPositionOfObstacle.z > 0 && Math.abs(localPositionOfObstacle.z) < dBoxLength) {\n          // if the distance from the x axis to the object's position is less\n          // than its radius + half the width of the detection box then there is a potential intersection\n          var expandedRadius = obstacle.boundingRadius + vehicle.boundingRadius;\n\n          if (Math.abs(localPositionOfObstacle.x) < expandedRadius) {\n            // do intersection test in local space of the vehicle\n            boundingSphere.center.copy(localPositionOfObstacle);\n            boundingSphere.radius = expandedRadius;\n            ray.intersectBoundingSphere(boundingSphere, intersectionPoint); // compare distances\n\n            if (intersectionPoint.z < distanceToClosestObstacle) {\n              // save new minimum distance\n              distanceToClosestObstacle = intersectionPoint.z; // save closest obstacle\n\n              closestObstacle = obstacle; // save local position for force calculation\n\n              localPositionOfClosestObstacle.copy(localPositionOfObstacle);\n            }\n          }\n        }\n      } // if we have found an intersecting obstacle, calculate a steering force away from it\n\n\n      if (closestObstacle !== null) {\n        // the closer the agent is to an object, the stronger the steering force should be\n        var multiplier = 1 + (dBoxLength - localPositionOfClosestObstacle.z) / dBoxLength; // calculate the lateral force\n\n        force.x = (closestObstacle.boundingRadius - localPositionOfClosestObstacle.x) * multiplier; // apply a braking force proportional to the obstacles distance from the vehicle\n\n        force.z = (closestObstacle.boundingRadius - localPositionOfClosestObstacle.z) * this.brakingWeight; // finally, convert the steering vector from local to world space (just apply the rotation)\n\n        force.applyRotation(vehicle.rotation);\n      }\n\n      return force;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(ObstacleAvoidanceBehavior.prototype), \"toJSON\", this).call(this);\n\n      json.obstacles = new Array();\n      json.brakingWeight = this.brakingWeight;\n      json.dBoxMinLength = this.dBoxMinLength; // obstacles\n\n      for (var _i19 = 0, l = this.obstacles.length; _i19 < l; _i19++) {\n        json.obstacles.push(this.obstacles[_i19].uuid);\n      }\n\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {ObstacleAvoidanceBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(ObstacleAvoidanceBehavior.prototype), \"fromJSON\", this).call(this, json);\n\n      this.obstacles = json.obstacles;\n      this.brakingWeight = json.brakingWeight;\n      this.dBoxMinLength = json.dBoxMinLength;\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {ObstacleAvoidanceBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      var obstacles = this.obstacles;\n\n      for (var _i20 = 0, l = obstacles.length; _i20 < l; _i20++) {\n        obstacles[_i20] = entities.get(obstacles[_i20]);\n      }\n    }\n  }]);\n\n  return ObstacleAvoidanceBehavior;\n}(SteeringBehavior);\n\nvar offsetWorld = new Vector3();\nvar toOffset = new Vector3();\nvar newLeaderVelocity = new Vector3();\nvar predictedPosition$1 = new Vector3();\n/**\r\n* This steering behavior produces a force that keeps a vehicle at a specified offset from a leader vehicle.\r\n* Useful for creating formations.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments SteeringBehavior\r\n*/\n\nvar OffsetPursuitBehavior =\n/*#__PURE__*/\nfunction (_SteeringBehavior10) {\n  _inherits(OffsetPursuitBehavior, _SteeringBehavior10);\n\n  /**\r\n  * Constructs a new offset pursuit behavior.\r\n  *\r\n  * @param {Vehicle} leader - The leader vehicle.\r\n  * @param {Vector3} offset - The offset from the leader.\r\n  */\n  function OffsetPursuitBehavior() {\n    var _this10;\n\n    var leader = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n\n    _classCallCheck(this, OffsetPursuitBehavior);\n\n    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(OffsetPursuitBehavior).call(this));\n    /**\r\n    * The leader vehicle.\r\n    * @type Vehicle\r\n    */\n\n    _this10.leader = leader;\n    /**\r\n    * The offset from the leader.\r\n    * @type Vector3\r\n    */\n\n    _this10.offset = offset; // internal behaviors\n\n    _this10._arrive = new ArriveBehavior();\n    _this10._arrive.deceleration = 1.5;\n    return _this10;\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(OffsetPursuitBehavior, [{\n    key: \"calculate\",\n    value: function calculate(vehicle, force\n    /*, delta */\n    ) {\n      var leader = this.leader;\n      var offset = this.offset; // calculate the offset's position in world space\n\n      offsetWorld.copy(offset).applyMatrix4(leader.worldMatrix); // calculate the vector that points from the vehicle to the offset position\n\n      toOffset.subVectors(offsetWorld, vehicle.position); // the lookahead time is proportional to the distance between the leader\n      // and the pursuer and is inversely proportional to the sum of both\n      // agent's velocities\n\n      var lookAheadTime = toOffset.length() / (vehicle.maxSpeed + leader.getSpeed()); // calculate new velocity and predicted future position\n\n      newLeaderVelocity.copy(leader.velocity).multiplyScalar(lookAheadTime);\n      predictedPosition$1.addVectors(offsetWorld, newLeaderVelocity); // now arrive at the predicted future position of the offset\n\n      this._arrive.target = predictedPosition$1;\n\n      this._arrive.calculate(vehicle, force);\n\n      return force;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(OffsetPursuitBehavior.prototype), \"toJSON\", this).call(this);\n\n      json.leader = this.leader ? this.leader.uuid : null;\n      json.offset = this.offset;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {OffsetPursuitBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(OffsetPursuitBehavior.prototype), \"fromJSON\", this).call(this, json);\n\n      this.leader = json.leader;\n      this.offset = json.offset;\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {OffsetPursuitBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      this.leader = entities.get(this.leader) || null;\n    }\n  }]);\n\n  return OffsetPursuitBehavior;\n}(SteeringBehavior);\n\nvar displacement$3 = new Vector3();\nvar vehicleDirection = new Vector3();\nvar evaderDirection = new Vector3();\nvar newEvaderVelocity = new Vector3();\nvar predictedPosition$2 = new Vector3();\n/**\r\n* This steering behavior is useful when an agent is required to intercept a moving agent.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments SteeringBehavior\r\n*/\n\nvar PursuitBehavior =\n/*#__PURE__*/\nfunction (_SteeringBehavior11) {\n  _inherits(PursuitBehavior, _SteeringBehavior11);\n\n  /**\r\n  * Constructs a new pursuit behavior.\r\n  *\r\n  * @param {MovingEntity} evader - The agent to pursue.\r\n  * @param {Number} predictionFactor - This factor determines how far the vehicle predicts the movement of the evader.\r\n  */\n  function PursuitBehavior() {\n    var _this11;\n\n    var evader = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var predictionFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    _classCallCheck(this, PursuitBehavior);\n\n    _this11 = _possibleConstructorReturn(this, _getPrototypeOf(PursuitBehavior).call(this));\n    /**\r\n    * The agent to pursue.\r\n    * @type MovingEntity\r\n    * @default null\r\n    */\n\n    _this11.evader = evader;\n    /**\r\n    * This factor determines how far the vehicle predicts the movement of the evader.\r\n    * @type Number\r\n    * @default 1\r\n    */\n\n    _this11.predictionFactor = predictionFactor; // internal behaviors\n\n    _this11._seek = new SeekBehavior();\n    return _this11;\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(PursuitBehavior, [{\n    key: \"calculate\",\n    value: function calculate(vehicle, force\n    /*, delta */\n    ) {\n      var evader = this.evader;\n      displacement$3.subVectors(evader.position, vehicle.position); // 1. if the evader is ahead and facing the agent then we can just seek for the evader's current position\n\n      vehicle.getDirection(vehicleDirection);\n      evader.getDirection(evaderDirection); // first condition: evader must be in front of the pursuer\n\n      var evaderAhead = displacement$3.dot(vehicleDirection) > 0; // second condition: evader must almost directly facing the agent\n\n      var facing = vehicleDirection.dot(evaderDirection) < -0.95;\n\n      if (evaderAhead === true && facing === true) {\n        this._seek.target = evader.position;\n\n        this._seek.calculate(vehicle, force);\n\n        return force;\n      } // 2. evader not considered ahead so we predict where the evader will be\n      // the lookahead time is proportional to the distance between the evader\n      // and the pursuer. and is inversely proportional to the sum of the\n      // agent's velocities\n\n\n      var lookAheadTime = displacement$3.length() / (vehicle.maxSpeed + evader.getSpeed());\n      lookAheadTime *= this.predictionFactor; // tweak the magnitude of the prediction\n      // calculate new velocity and predicted future position\n\n      newEvaderVelocity.copy(evader.velocity).multiplyScalar(lookAheadTime);\n      predictedPosition$2.addVectors(evader.position, newEvaderVelocity); // now seek to the predicted future position of the evader\n\n      this._seek.target = predictedPosition$2;\n\n      this._seek.calculate(vehicle, force);\n\n      return force;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(PursuitBehavior.prototype), \"toJSON\", this).call(this);\n\n      json.evader = this.evader ? this.evader.uuid : null;\n      json.predictionFactor = this.predictionFactor;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {PursuitBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(PursuitBehavior.prototype), \"fromJSON\", this).call(this, json);\n\n      this.evader = json.evader;\n      this.predictionFactor = json.predictionFactor;\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {PursuitBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      this.evader = entities.get(this.evader) || null;\n    }\n  }]);\n\n  return PursuitBehavior;\n}(SteeringBehavior);\n\nvar toAgent = new Vector3();\n/**\r\n* This steering produces a force that steers a vehicle away from those in its neighborhood region.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments SteeringBehavior\r\n*/\n\nvar SeparationBehavior =\n/*#__PURE__*/\nfunction (_SteeringBehavior12) {\n  _inherits(SeparationBehavior, _SteeringBehavior12);\n\n  /**\r\n  * Constructs a new separation behavior.\r\n  */\n  function SeparationBehavior() {\n    _classCallCheck(this, SeparationBehavior);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SeparationBehavior).call(this));\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(SeparationBehavior, [{\n    key: \"calculate\",\n    value: function calculate(vehicle, force\n    /*, delta */\n    ) {\n      var neighbors = vehicle.neighbors;\n\n      for (var _i21 = 0, l = neighbors.length; _i21 < l; _i21++) {\n        var neighbor = neighbors[_i21];\n        toAgent.subVectors(vehicle.position, neighbor.position);\n        var length = toAgent.length(); // handle zero length if both vehicles have the same position\n\n        if (length === 0) length = 0.0001; // scale the force inversely proportional to the agents distance from its neighbor\n\n        toAgent.normalize().divideScalar(length);\n        force.add(toAgent);\n      }\n\n      return force;\n    }\n  }]);\n\n  return SeparationBehavior;\n}(SteeringBehavior);\n\nvar targetWorld = new Vector3();\nvar randomDisplacement = new Vector3();\n/**\r\n* This steering behavior produces a steering force that will give the\r\n* impression of a random walk through the agents environment. The behavior only\r\n* produces a 2D force (XZ).\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments SteeringBehavior\r\n*/\n\nvar WanderBehavior =\n/*#__PURE__*/\nfunction (_SteeringBehavior13) {\n  _inherits(WanderBehavior, _SteeringBehavior13);\n\n  /**\r\n  * Constructs a new wander behavior.\r\n  *\r\n  * @param {Number} radius - The radius of the wander circle for the wander behavior.\r\n  * @param {Number} distance - The distance the wander circle is projected in front of the agent.\r\n  * @param {Number} jitter - The maximum amount of displacement along the sphere each frame.\r\n  */\n  function WanderBehavior() {\n    var _this12;\n\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n    var jitter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n\n    _classCallCheck(this, WanderBehavior);\n\n    _this12 = _possibleConstructorReturn(this, _getPrototypeOf(WanderBehavior).call(this));\n    /**\r\n    * The radius of the constraining circle for the wander behavior.\r\n    * @type Number\r\n    * @default 1\r\n    */\n\n    _this12.radius = radius;\n    /**\r\n    * The distance the wander sphere is projected in front of the agent.\r\n    * @type Number\r\n    * @default 5\r\n    */\n\n    _this12.distance = distance;\n    /**\r\n    * The maximum amount of displacement along the sphere each frame.\r\n    * @type Number\r\n    * @default 5\r\n    */\n\n    _this12.jitter = jitter;\n    _this12._targetLocal = new Vector3();\n    generateRandomPointOnCircle(_this12.radius, _this12._targetLocal);\n    return _this12;\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(WanderBehavior, [{\n    key: \"calculate\",\n    value: function calculate(vehicle, force, delta) {\n      // this behavior is dependent on the update rate, so this line must be\n      // included when using time independent frame rate\n      var jitterThisTimeSlice = this.jitter * delta; // prepare random vector\n\n      randomDisplacement.x = MathUtils.randFloat(-1, 1) * jitterThisTimeSlice;\n      randomDisplacement.z = MathUtils.randFloat(-1, 1) * jitterThisTimeSlice; // add random vector to the target's position\n\n      this._targetLocal.add(randomDisplacement); // re-project this new vector back onto a unit sphere\n\n\n      this._targetLocal.normalize(); // increase the length of the vector to the same as the radius of the wander sphere\n\n\n      this._targetLocal.multiplyScalar(this.radius); // move the target into a position wanderDist in front of the agent\n\n\n      targetWorld.copy(this._targetLocal);\n      targetWorld.z += this.distance; // project the target into world space\n\n      targetWorld.applyMatrix4(vehicle.worldMatrix); // and steer towards it\n\n      force.subVectors(targetWorld, vehicle.position);\n      return force;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(WanderBehavior.prototype), \"toJSON\", this).call(this);\n\n      json.radius = this.radius;\n      json.distance = this.distance;\n      json.jitter = this.jitter;\n      json._targetLocal = this._targetLocal.toArray(new Array());\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {WanderBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(WanderBehavior.prototype), \"fromJSON\", this).call(this, json);\n\n      this.radius = json.radius;\n      this.distance = json.distance;\n      this.jitter = json.jitter;\n\n      this._targetLocal.fromArray(json._targetLocal);\n\n      return this;\n    }\n  }]);\n\n  return WanderBehavior;\n}(SteeringBehavior); //\n\n\nfunction generateRandomPointOnCircle(radius, target) {\n  var theta = Math.random() * Math.PI * 2;\n  target.x = radius * Math.cos(theta);\n  target.z = radius * Math.sin(theta);\n}\n\nvar force = new Vector3();\n/**\r\n* This class is responsible for managing the steering of a single vehicle. The steering manager\r\n* can manage multiple steering behaviors and combine their produced force into a single one used\r\n* by the vehicle.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar SteeringManager =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new steering manager.\r\n  *\r\n  * @param {Vehicle} vehicle - The vehicle that owns this steering manager.\r\n  */\n  function SteeringManager(vehicle) {\n    _classCallCheck(this, SteeringManager);\n\n    /**\r\n    * The vehicle that owns this steering manager.\r\n    * @type Vehicle\r\n    */\n    this.vehicle = vehicle;\n    /**\r\n    * A list of all steering behaviors.\r\n    * @type Array\r\n    */\n\n    this.behaviors = new Array();\n    this._steeringForce = new Vector3(); // the calculated steering force per simulation step\n\n    this._typesMap = new Map(); // used for deserialization of custom behaviors\n  }\n  /**\r\n  * Adds the given steering behavior to this steering manager.\r\n  *\r\n  * @param {SteeringBehavior} behavior - The steering behavior to add.\r\n  * @return {SteeringManager} A reference to this steering manager.\r\n  */\n\n\n  _createClass(SteeringManager, [{\n    key: \"add\",\n    value: function add(behavior) {\n      this.behaviors.push(behavior);\n      return this;\n    }\n    /**\r\n    * Removes the given steering behavior from this steering manager.\r\n    *\r\n    * @param {SteeringBehavior} behavior - The steering behavior to remove.\r\n    * @return {SteeringManager} A reference to this steering manager.\r\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove(behavior) {\n      var index = this.behaviors.indexOf(behavior);\n      this.behaviors.splice(index, 1);\n      return this;\n    }\n    /**\r\n    * Clears the internal state of this steering manager.\r\n    *\r\n    * @return {SteeringManager} A reference to this steering manager.\r\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.behaviors.length = 0;\n      return this;\n    }\n    /**\r\n    * Calculates the steering forces for all active steering behaviors and\r\n    * combines it into a single result force. This method is called in\r\n    * {@link Vehicle#update}.\r\n    *\r\n    * @param {Number} delta - The time delta.\r\n    * @param {Vector3} result - The force/result vector.\r\n    * @return {Vector3} The force/result vector.\r\n    */\n\n  }, {\n    key: \"calculate\",\n    value: function calculate(delta, result) {\n      this._calculateByOrder(delta);\n\n      return result.copy(this._steeringForce);\n    } // this method calculates how much of its max steering force the vehicle has\n    // left to apply and then applies that amount of the force to add\n\n  }, {\n    key: \"_accumulate\",\n    value: function _accumulate(forceToAdd) {\n      // calculate how much steering force the vehicle has used so far\n      var magnitudeSoFar = this._steeringForce.length(); // calculate how much steering force remains to be used by this vehicle\n\n\n      var magnitudeRemaining = this.vehicle.maxForce - magnitudeSoFar; // return false if there is no more force left to use\n\n      if (magnitudeRemaining <= 0) return false; // calculate the magnitude of the force we want to add\n\n      var magnitudeToAdd = forceToAdd.length(); // restrict the magnitude of forceToAdd, so we don't exceed the max force of the vehicle\n\n      if (magnitudeToAdd > magnitudeRemaining) {\n        forceToAdd.normalize().multiplyScalar(magnitudeRemaining);\n      } // add force\n\n\n      this._steeringForce.add(forceToAdd);\n\n      return true;\n    }\n  }, {\n    key: \"_calculateByOrder\",\n    value: function _calculateByOrder(delta) {\n      var behaviors = this.behaviors; // reset steering force\n\n      this._steeringForce.set(0, 0, 0); // calculate for each behavior the respective force\n\n\n      for (var _i22 = 0, l = behaviors.length; _i22 < l; _i22++) {\n        var behavior = behaviors[_i22];\n\n        if (behavior.active === true) {\n          force.set(0, 0, 0);\n          behavior.calculate(this.vehicle, force, delta);\n          force.multiplyScalar(behavior.weight);\n          if (this._accumulate(force) === false) return;\n        }\n      }\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var data = {\n        type: 'SteeringManager',\n        behaviors: new Array()\n      };\n      var behaviors = this.behaviors;\n\n      for (var _i23 = 0, l = behaviors.length; _i23 < l; _i23++) {\n        var behavior = behaviors[_i23];\n        data.behaviors.push(behavior.toJSON());\n      }\n\n      return data;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {SteeringManager} A reference to this steering manager.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.clear();\n      var behaviorsJSON = json.behaviors;\n\n      for (var _i24 = 0, l = behaviorsJSON.length; _i24 < l; _i24++) {\n        var behaviorJSON = behaviorsJSON[_i24];\n        var type = behaviorJSON.type;\n        var behavior = void 0;\n\n        switch (type) {\n          case 'SteeringBehavior':\n            behavior = new SteeringBehavior().fromJSON(behaviorJSON);\n            break;\n\n          case 'AlignmentBehavior':\n            behavior = new AlignmentBehavior().fromJSON(behaviorJSON);\n            break;\n\n          case 'ArriveBehavior':\n            behavior = new ArriveBehavior().fromJSON(behaviorJSON);\n            break;\n\n          case 'CohesionBehavior':\n            behavior = new CohesionBehavior().fromJSON(behaviorJSON);\n            break;\n\n          case 'EvadeBehavior':\n            behavior = new EvadeBehavior().fromJSON(behaviorJSON);\n            break;\n\n          case 'FleeBehavior':\n            behavior = new FleeBehavior().fromJSON(behaviorJSON);\n            break;\n\n          case 'FollowPathBehavior':\n            behavior = new FollowPathBehavior().fromJSON(behaviorJSON);\n            break;\n\n          case 'InterposeBehavior':\n            behavior = new InterposeBehavior().fromJSON(behaviorJSON);\n            break;\n\n          case 'ObstacleAvoidanceBehavior':\n            behavior = new ObstacleAvoidanceBehavior().fromJSON(behaviorJSON);\n            break;\n\n          case 'OffsetPursuitBehavior':\n            behavior = new OffsetPursuitBehavior().fromJSON(behaviorJSON);\n            break;\n\n          case 'PursuitBehavior':\n            behavior = new PursuitBehavior().fromJSON(behaviorJSON);\n            break;\n\n          case 'SeekBehavior':\n            behavior = new SeekBehavior().fromJSON(behaviorJSON);\n            break;\n\n          case 'SeparationBehavior':\n            behavior = new SeparationBehavior().fromJSON(behaviorJSON);\n            break;\n\n          case 'WanderBehavior':\n            behavior = new WanderBehavior().fromJSON(behaviorJSON);\n            break;\n\n          default:\n            // handle custom type\n            var ctor = this._typesMap.get(type);\n\n            if (ctor !== undefined) {\n              behavior = new ctor().fromJSON(behaviorJSON);\n            } else {\n              Logger.warn('YUKA.SteeringManager: Unsupported steering behavior type:', type);\n              continue;\n            }\n\n        }\n\n        this.add(behavior);\n      }\n\n      return this;\n    }\n    /**\r\n     * Registers a custom type for deserialization. When calling {@link SteeringManager#fromJSON}\r\n     * the steering manager is able to pick the correct constructor in order to create custom\r\n     * steering behavior.\r\n     *\r\n     * @param {String} type - The name of the behavior type.\r\n     * @param {Function} constructor - The constructor function.\r\n     * @return {SteeringManager} A reference to this steering manager.\r\n     */\n\n  }, {\n    key: \"registerType\",\n    value: function registerType(type, constructor) {\n      this._typesMap.set(type, constructor);\n\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {SteeringManager} A reference to this steering manager.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      var behaviors = this.behaviors;\n\n      for (var _i25 = 0, l = behaviors.length; _i25 < l; _i25++) {\n        var behavior = behaviors[_i25];\n        behavior.resolveReferences(entities);\n      }\n\n      return this;\n    }\n  }]);\n\n  return SteeringManager;\n}();\n/**\r\n* This class can be used to smooth the result of a vector calculation. One use case\r\n* is the smoothing of the velocity vector of game entities in order to avoid a shaky\r\n* movements due to conflicting forces.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @author {@link https://github.com/robp94|robp94}\r\n*/\n\n\nvar Smoother =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new smoother.\r\n  *\r\n  * @param {Number} count - The amount of samples the smoother will use to average a vector.\r\n  */\n  function Smoother() {\n    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n\n    _classCallCheck(this, Smoother);\n\n    /**\r\n    * The amount of samples the smoother will use to average a vector.\r\n    * @type Number\r\n    * @default 10\r\n    */\n    this.count = count;\n    this._history = new Array(); // this holds the history\n\n    this._slot = 0; // the current sample slot\n    // initialize history with Vector3s\n\n    for (var _i26 = 0; _i26 < this.count; _i26++) {\n      this._history[_i26] = new Vector3();\n    }\n  }\n  /**\r\n  * Calculates for the given value a smooth average.\r\n  *\r\n  * @param {Vector3} value - The value to smooth.\r\n  * @param {Vector3} average - The calculated average.\r\n  * @return {Vector3} The calculated average.\r\n  */\n\n\n  _createClass(Smoother, [{\n    key: \"calculate\",\n    value: function calculate(value, average) {\n      // ensure, average is a zero vector\n      average.set(0, 0, 0); // make sure the slot index wraps around\n\n      if (this._slot === this.count) {\n        this._slot = 0;\n      } // overwrite the oldest value with the newest\n\n\n      this._history[this._slot].copy(value); // increase slot index\n\n\n      this._slot++; // now calculate the average of the history array\n\n      for (var _i27 = 0; _i27 < this.count; _i27++) {\n        average.add(this._history[_i27]);\n      }\n\n      average.divideScalar(this.count);\n      return average;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var data = {\n        type: this.constructor.name,\n        count: this.count,\n        _history: new Array(),\n        _slot: this._slot\n      }; // history\n\n      var history = this._history;\n\n      for (var _i28 = 0, l = history.length; _i28 < l; _i28++) {\n        var value = history[_i28];\n\n        data._history.push(value.toArray(new Array()));\n      }\n\n      return data;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {Smoother} A reference to this smoother.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.count = json.count;\n      this._slot = json._slot; // history\n\n      var historyJSON = json._history;\n      this._history.length = 0;\n\n      for (var _i29 = 0, l = historyJSON.length; _i29 < l; _i29++) {\n        var valueJSON = historyJSON[_i29];\n\n        this._history.push(new Vector3().fromArray(valueJSON));\n      }\n\n      return this;\n    }\n  }]);\n\n  return Smoother;\n}();\n\nvar steeringForce = new Vector3();\nvar displacement$4 = new Vector3();\nvar acceleration = new Vector3();\nvar target$1 = new Vector3();\nvar velocitySmooth = new Vector3();\n/**\r\n* This type of game entity implements a special type of locomotion, the so called\r\n* *Vehicle Model*. The class uses basic physical metrics in order to implement a\r\n* realistic movement.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @author {@link https://github.com/robp94|robp94}\r\n* @augments MovingEntity\r\n*/\n\nvar Vehicle =\n/*#__PURE__*/\nfunction (_MovingEntity) {\n  _inherits(Vehicle, _MovingEntity);\n\n  /**\r\n  * Constructs a new vehicle.\r\n  */\n  function Vehicle() {\n    var _this13;\n\n    _classCallCheck(this, Vehicle);\n\n    _this13 = _possibleConstructorReturn(this, _getPrototypeOf(Vehicle).call(this));\n    /**\r\n    * The mass if the vehicle in kilogram.\r\n    * @type Number\r\n    * @default 1\r\n    */\n\n    _this13.mass = 1;\n    /**\r\n    * The maximum force this entity can produce to power itself.\r\n    * @type Number\r\n    * @default 100\r\n    */\n\n    _this13.maxForce = 100;\n    /**\r\n    * The steering manager of this vehicle.\r\n    * @type SteeringManager\r\n    */\n\n    _this13.steering = new SteeringManager(_assertThisInitialized(_assertThisInitialized(_this13)));\n    /**\r\n    * An optional smoother to avoid shakiness due to conflicting steering behaviors.\r\n    * @type Smoother\r\n    * @default null\r\n    */\n\n    _this13.smoother = null;\n    return _this13;\n  }\n  /**\r\n  * This method is responsible for updating the position based on the force produced\r\n  * by the internal steering manager.\r\n  *\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vehicle} A reference to this vehicle.\r\n  */\n\n\n  _createClass(Vehicle, [{\n    key: \"update\",\n    value: function update(delta) {\n      // calculate steering force\n      this.steering.calculate(delta, steeringForce); // acceleration = force / mass\n\n      acceleration.copy(steeringForce).divideScalar(this.mass); // update velocity\n\n      this.velocity.add(acceleration.multiplyScalar(delta)); // make sure vehicle does not exceed maximum speed\n\n      if (this.getSpeedSquared() > this.maxSpeed * this.maxSpeed) {\n        this.velocity.normalize();\n        this.velocity.multiplyScalar(this.maxSpeed);\n      } // calculate displacement\n\n\n      displacement$4.copy(this.velocity).multiplyScalar(delta); // calculate target position\n\n      target$1.copy(this.position).add(displacement$4); // update the orientation if the vehicle has a non zero velocity\n\n      if (this.updateOrientation === true && this.smoother === null && this.getSpeedSquared() > 0.00000001) {\n        this.lookAt(target$1);\n      } // update position\n\n\n      this.position.copy(target$1); // if smoothing is enabled, the orientation (not the position!) of the vehicle is\n      // changed based on a post-processed velocity vector\n\n      if (this.updateOrientation === true && this.smoother !== null) {\n        this.smoother.calculate(this.velocity, velocitySmooth);\n        displacement$4.copy(velocitySmooth).multiplyScalar(delta);\n        target$1.copy(this.position).add(displacement$4);\n        this.lookAt(target$1);\n      }\n\n      return this;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(Vehicle.prototype), \"toJSON\", this).call(this);\n\n      json.mass = this.mass;\n      json.maxForce = this.maxForce;\n      json.steering = this.steering.toJSON();\n      json.smoother = this.smoother ? this.smoother.toJSON() : null;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {Vehicle} A reference to this vehicle.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(Vehicle.prototype), \"fromJSON\", this).call(this, json);\n\n      this.mass = json.mass;\n      this.maxForce = json.maxForce;\n      this.steering = new SteeringManager(this).fromJSON(json.steering);\n      this.smoother = json.smoother ? new Smoother().fromJSON(json.smoother) : null;\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {Vehicle} A reference to this vehicle.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      _get(_getPrototypeOf(Vehicle.prototype), \"resolveReferences\", this).call(this, entities);\n\n      this.steering.resolveReferences(entities);\n    }\n  }]);\n\n  return Vehicle;\n}(MovingEntity);\n/**\r\n* Base class for representing trigger regions. It's a predefine region in 3D space,\r\n* owned by one or more triggers. The shape of the trigger can be arbitrary.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar TriggerRegion =\n/*#__PURE__*/\nfunction () {\n  function TriggerRegion() {\n    _classCallCheck(this, TriggerRegion);\n  }\n\n  _createClass(TriggerRegion, [{\n    key: \"touching\",\n\n    /**\r\n    * Returns true if the bounding volume of the given game entity touches/intersects\r\n    * the trigger region. Must be implemented by all concrete trigger regions.\r\n    *\r\n    * @param {GameEntity} entity - The entity to test.\r\n    * @return {Boolean} Whether this trigger touches the given game entity or not.\r\n    */\n    value: function touching()\n    /* entity */\n    {\n      return false;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.constructor.name\n      };\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {TriggerRegion} A reference to this trigger region.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON()\n    /* json */\n    {\n      return this;\n    }\n  }]);\n\n  return TriggerRegion;\n}();\n\nvar boundingSphereEntity = new BoundingSphere();\n/**\r\n* Class for representing a rectangular trigger region as an AABB.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments TriggerRegion\r\n*/\n\nvar RectangularTriggerRegion =\n/*#__PURE__*/\nfunction (_TriggerRegion) {\n  _inherits(RectangularTriggerRegion, _TriggerRegion);\n\n  /**\r\n  * Constructs a new rectangular trigger region with the given values.\r\n  *\r\n  * @param {Vector3} min - The minimum bounds of the region.\r\n  * @param {Vector3} max - The maximum bounds of the region.\r\n  */\n  function RectangularTriggerRegion() {\n    var _this14;\n\n    var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n\n    _classCallCheck(this, RectangularTriggerRegion);\n\n    _this14 = _possibleConstructorReturn(this, _getPrototypeOf(RectangularTriggerRegion).call(this));\n    _this14._aabb = new AABB(min, max);\n    return _this14;\n  }\n\n  _createClass(RectangularTriggerRegion, [{\n    key: \"fromPositionAndSize\",\n\n    /**\r\n    * Creates the new rectangular trigger region from a given position and size.\r\n    *\r\n    * @param {Vector3} position - The center position of the trigger region.\r\n    * @param {Vector3} size - The size of the trigger region per axis.\r\n    * @return {RectangularTriggerRegion} A reference to this trigger region.\r\n    */\n    value: function fromPositionAndSize(position, size) {\n      this._aabb.fromCenterAndSize(position, size);\n\n      return this;\n    }\n    /**\r\n    * Returns true if the bounding volume of the given game entity touches/intersects\r\n    * the trigger region.\r\n    *\r\n    * @param {GameEntity} entity - The entity to test.\r\n    * @return {Boolean} Whether this trigger touches the given game entity or not.\r\n    */\n\n  }, {\n    key: \"touching\",\n    value: function touching(entity) {\n      boundingSphereEntity.set(entity.position, entity.boundingRadius);\n      return this._aabb.intersectsBoundingSphere(boundingSphereEntity);\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(RectangularTriggerRegion.prototype), \"toJSON\", this).call(this);\n\n      json._aabb = this._aabb.toJSON();\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {RectangularTriggerRegion} A reference to this trigger region.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(RectangularTriggerRegion.prototype), \"fromJSON\", this).call(this, json);\n\n      this._aabb.fromJSON(json._aabb);\n\n      return this;\n    }\n  }, {\n    key: \"min\",\n    get: function get() {\n      return this._aabb.min;\n    },\n    set: function set(min) {\n      this._aabb.min = min;\n    }\n  }, {\n    key: \"max\",\n    get: function get() {\n      return this._aabb.max;\n    },\n    set: function set(max) {\n      this._aabb.max = max;\n    }\n  }]);\n\n  return RectangularTriggerRegion;\n}(TriggerRegion);\n\nvar boundingSphereEntity$1 = new BoundingSphere();\n/**\r\n* Class for representing a spherical trigger region as a bounding sphere.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments TriggerRegion\r\n*/\n\nvar SphericalTriggerRegion =\n/*#__PURE__*/\nfunction (_TriggerRegion2) {\n  _inherits(SphericalTriggerRegion, _TriggerRegion2);\n\n  /**\r\n  * Constructs a new spherical trigger region with the given values.\r\n  *\r\n  * @param {Vector3} position - The center position of the region.\r\n  * @param {Number} radius - The radius of the region.\r\n  */\n  function SphericalTriggerRegion() {\n    var _this15;\n\n    var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, SphericalTriggerRegion);\n\n    _this15 = _possibleConstructorReturn(this, _getPrototypeOf(SphericalTriggerRegion).call(this));\n    _this15._boundingSphere = new BoundingSphere(position, radius);\n    return _this15;\n  }\n\n  _createClass(SphericalTriggerRegion, [{\n    key: \"touching\",\n\n    /**\r\n    * Returns true if the bounding volume of the given game entity touches/intersects\r\n    * the trigger region.\r\n    *\r\n    * @param {GameEntity} entity - The entity to test.\r\n    * @return {Boolean} Whether this trigger touches the given game entity or not.\r\n    */\n    value: function touching(entity) {\n      boundingSphereEntity$1.set(entity.position, entity.boundingRadius);\n      return this._boundingSphere.intersectsBoundingSphere(boundingSphereEntity$1);\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(SphericalTriggerRegion.prototype), \"toJSON\", this).call(this);\n\n      json._boundingSphere = this._boundingSphere.toJSON();\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {SphericalTriggerRegion} A reference to this trigger region.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(SphericalTriggerRegion.prototype), \"fromJSON\", this).call(this, json);\n\n      this._boundingSphere.fromJSON(json._boundingSphere);\n\n      return this;\n    }\n  }, {\n    key: \"position\",\n    get: function get() {\n      return this._boundingSphere.center;\n    },\n    set: function set(position) {\n      this._boundingSphere.center = position;\n    }\n  }, {\n    key: \"radius\",\n    get: function get() {\n      return this._boundingSphere.radius;\n    },\n    set: function set(radius) {\n      this._boundingSphere.radius = radius;\n    }\n  }]);\n\n  return SphericalTriggerRegion;\n}(TriggerRegion);\n/**\r\n* Base class for representing triggers. A trigger generates an action if a game entity\r\n* touches its trigger region, a predefine region in 3D space.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar Trigger =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new trigger with the given values.\r\n  *\r\n  * @param {TriggerRegion} region - The region of the trigger.\r\n  */\n  function Trigger() {\n    var region = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new TriggerRegion();\n\n    _classCallCheck(this, Trigger);\n\n    /**\r\n    * Whether this trigger is active or not.\r\n    * @type Boolean\r\n    * @default true\r\n    */\n    this.active = true;\n    /**\r\n    * The region of the trigger.\r\n    * @type TriggerRegion\r\n    */\n\n    this.region = region; //\n\n    this._typesMap = new Map(); // used for deserialization of custom triggerRegions\n  }\n  /**\r\n  * This method is called per simulation step for all game entities. If the game\r\n  * entity touches the region of the trigger, the respective action is executed.\r\n  *\r\n  * @param {GameEntity} entity - The entity to test\r\n  * @return {Trigger} A reference to this trigger.\r\n  */\n\n\n  _createClass(Trigger, [{\n    key: \"check\",\n    value: function check(entity) {\n      if (this.active === true && this.region.touching(entity) === true) {\n        this.execute(entity);\n      }\n\n      return this;\n    }\n    /**\r\n    * This method is called when the trigger should execute its action.\r\n    * Must be implemented by all concrete triggers.\r\n    *\r\n    * @param {GameEntity} entity - The entity that touched the trigger region.\r\n    * @return {Trigger} A reference to this trigger.\r\n    */\n\n  }, {\n    key: \"execute\",\n    value: function execute()\n    /* entity */\n    {}\n    /**\r\n    * Triggers can have internal states. This method is called per simulation step\r\n    * and can be used to update the trigger.\r\n    *\r\n    * @param {Number} delta - The time delta value.\r\n    * @return {Trigger} A reference to this trigger.\r\n    */\n\n  }, {\n    key: \"update\",\n    value: function update()\n    /* delta */\n    {}\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.constructor.name,\n        active: this.active,\n        region: this.region.toJSON()\n      };\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {Trigger} A reference to this trigger.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.active = json.active;\n      var regionJSON = json.region;\n      var type = regionJSON.type;\n\n      switch (type) {\n        case 'TriggerRegion':\n          this.region = new TriggerRegion().fromJSON(regionJSON);\n          break;\n\n        case 'RectangularTriggerRegion':\n          this.region = new RectangularTriggerRegion().fromJSON(regionJSON);\n          break;\n\n        case 'SphericalTriggerRegion':\n          this.region = new SphericalTriggerRegion().fromJSON(regionJSON);\n          break;\n\n        default:\n          // handle custom type\n          var ctor = this._typesMap.get(type);\n\n          if (ctor !== undefined) {\n            this.region = new ctor().fromJSON(regionJSON);\n          } else {\n            Logger.warn('YUKA.Trigger: Unsupported trigger region type:', regionJSON.type);\n          }\n\n      }\n\n      return this;\n    }\n    /**\r\n     * Registers a custom type for deserialization. When calling {@link Trigger#fromJSON}\r\n     * the trigger is able to pick the correct constructor in order to create custom\r\n     * trigger regions.\r\n     *\r\n     * @param {String} type - The name of the trigger region.\r\n     * @param {Function} constructor - The constructor function.\r\n     * @return {Trigger} A reference to this trigger.\r\n     */\n\n  }, {\n    key: \"registerType\",\n    value: function registerType(type, constructor) {\n      this._typesMap.set(type, constructor);\n\n      return this;\n    }\n  }]);\n\n  return Trigger;\n}();\n\nvar candidates = new Array();\n/**\r\n* This class is used for managing all central objects of a game like\r\n* game entities and triggers.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar EntityManager =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new entity manager.\r\n  */\n  function EntityManager() {\n    _classCallCheck(this, EntityManager);\n\n    /**\r\n    * A list of {@link GameEntity game entities }.\r\n    * @type Array\r\n    */\n    this.entities = new Array();\n    /**\r\n    * A list of {@link Trigger triggers }.\r\n    * @type Array\r\n    */\n\n    this.triggers = new Array();\n    /**\r\n    * A reference to a spatial index.\r\n    * @type CellSpacePartitioning\r\n    * @default null\r\n    */\n\n    this.spatialIndex = null;\n    this._indexMap = new Map(); // used by spatial indices\n\n    this._typesMap = new Map(); // used for deserialization of custom entities\n\n    this._messageDispatcher = new MessageDispatcher();\n  }\n  /**\r\n  * Adds a game entity to this entity manager.\r\n  *\r\n  * @param {GameEntity} entity - The game entity to add.\r\n  * @return {EntityManager} A reference to this entity manager.\r\n  */\n\n\n  _createClass(EntityManager, [{\n    key: \"add\",\n    value: function add(entity) {\n      this.entities.push(entity);\n      entity.manager = this;\n      return this;\n    }\n    /**\r\n    * Removes a game entity from this entity manager.\r\n    *\r\n    * @param {GameEntity} entity - The game entity to remove.\r\n    * @return {EntityManager} A reference to this entity manager.\r\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove(entity) {\n      var index = this.entities.indexOf(entity);\n      this.entities.splice(index, 1);\n      entity.manager = null;\n      return this;\n    }\n    /**\r\n    * Adds a trigger to this entity manager.\r\n    *\r\n    * @param {Trigger} trigger - The trigger to add.\r\n    * @return {EntityManager} A reference to this entity manager.\r\n    */\n\n  }, {\n    key: \"addTrigger\",\n    value: function addTrigger(trigger) {\n      this.triggers.push(trigger);\n      return this;\n    }\n    /**\r\n    * Removes a trigger to this entity manager.\r\n    *\r\n    * @param {Trigger} trigger - The trigger to remove.\r\n    * @return {EntityManager} A reference to this entity manager.\r\n    */\n\n  }, {\n    key: \"removeTrigger\",\n    value: function removeTrigger(trigger) {\n      var index = this.triggers.indexOf(trigger);\n      this.triggers.splice(index, 1);\n      return this;\n    }\n    /**\r\n    * Clears the internal state of this entity manager.\r\n    *\r\n    * @return {EntityManager} A reference to this entity manager.\r\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.entities.length = 0;\n      this.triggers.length = 0;\n\n      this._messageDispatcher.clear();\n\n      return this;\n    }\n    /**\r\n    * Returns an entity by the given name. If no game entity is found, *null*\r\n    * is returned. This method should be used once (e.g. at {@link GameEntity#start})\r\n    * and the result should be cached for later use.\r\n    *\r\n    * @param {String} name - The name of the game entity.\r\n    * @return {GameEntity} The found game entity.\r\n    */\n\n  }, {\n    key: \"getEntityByName\",\n    value: function getEntityByName(name) {\n      var entities = this.entities;\n\n      for (var _i30 = 0, l = entities.length; _i30 < l; _i30++) {\n        var entity = entities[_i30];\n        if (entity.name === name) return entity;\n      }\n\n      return null;\n    }\n    /**\r\n    * The central update method of this entity manager. Updates all\r\n    * game entities, triggers and delayed messages.\r\n    *\r\n    * @param {Number} delta - The time delta.\r\n    * @return {EntityManager} A reference to this entity manager.\r\n    */\n\n  }, {\n    key: \"update\",\n    value: function update(delta) {\n      var entities = this.entities;\n      var triggers = this.triggers; // update entities\n\n      for (var _i31 = entities.length - 1; _i31 >= 0; _i31--) {\n        var entity = entities[_i31];\n        this.updateEntity(entity, delta);\n      } // update triggers\n\n\n      for (var _i32 = triggers.length - 1; _i32 >= 0; _i32--) {\n        var trigger = triggers[_i32];\n        this.updateTrigger(trigger, delta);\n      } // handle messaging\n\n\n      this._messageDispatcher.dispatchDelayedMessages(delta);\n\n      return this;\n    }\n    /**\r\n    * Updates a single entity.\r\n    *\r\n    * @param {GameEntity} entity - The game entity to update.\r\n    * @param {Number} delta - The time delta.\r\n    * @return {EntityManager} A reference to this entity manager.\r\n    */\n\n  }, {\n    key: \"updateEntity\",\n    value: function updateEntity(entity, delta) {\n      if (entity.active === true) {\n        this.updateNeighborhood(entity); //\n\n        if (entity._started === false) {\n          entity.start();\n          entity._started = true;\n        } //\n\n\n        entity.update(delta);\n        entity.updateWorldMatrix(); //\n\n        var children = entity.children;\n\n        for (var _i33 = children.length - 1; _i33 >= 0; _i33--) {\n          var child = children[_i33];\n          this.updateEntity(child, delta);\n        } //\n\n\n        if (this.spatialIndex !== null) {\n          var currentIndex = this._indexMap.get(entity) || -1;\n          currentIndex = this.spatialIndex.updateEntity(entity, currentIndex);\n\n          this._indexMap.set(entity, currentIndex);\n        } //\n\n\n        var renderComponent = entity._renderComponent;\n        var renderComponentCallback = entity._renderComponentCallback;\n\n        if (renderComponent !== null && renderComponentCallback !== null) {\n          renderComponentCallback(entity, renderComponent);\n        }\n      }\n\n      return this;\n    }\n    /**\r\n    * Updates the neighborhood of a single game entity.\r\n    *\r\n    * @param {GameEntity} entity - The game entity to update.\r\n    * @return {EntityManager} A reference to this entity manager.\r\n    */\n\n  }, {\n    key: \"updateNeighborhood\",\n    value: function updateNeighborhood(entity) {\n      if (entity.updateNeighborhood === true) {\n        entity.neighbors.length = 0; // determine candidates\n\n        if (this.spatialIndex !== null) {\n          this.spatialIndex.query(entity.position, entity.neighborhoodRadius, candidates);\n        } else {\n          // worst case runtime complexity with O(n)\n          candidates.length = 0;\n          candidates.push.apply(candidates, _toConsumableArray(this.entities));\n        } // verify if candidates are within the predefined range\n\n\n        var neighborhoodRadiusSq = entity.neighborhoodRadius * entity.neighborhoodRadius;\n\n        for (var _i34 = 0, l = candidates.length; _i34 < l; _i34++) {\n          var candidate = candidates[_i34];\n\n          if (entity !== candidate && candidate.active === true) {\n            var distanceSq = entity.position.squaredDistanceTo(candidate.position);\n\n            if (distanceSq <= neighborhoodRadiusSq) {\n              entity.neighbors.push(candidate);\n            }\n          }\n        }\n      }\n\n      return this;\n    }\n    /**\r\n    * Updates a single trigger.\r\n    *\r\n    * @param {Trigger} trigger - The trigger to update.\r\n    * @return {EntityManager} A reference to this entity manager.\r\n    */\n\n  }, {\n    key: \"updateTrigger\",\n    value: function updateTrigger(trigger, delta) {\n      if (trigger.active === true) {\n        trigger.update(delta);\n        var entities = this.entities;\n\n        for (var _i35 = entities.length - 1; _i35 >= 0; _i35--) {\n          var entity = entities[_i35];\n\n          if (entity.active === true && entity.canAcitivateTrigger) {\n            trigger.check(entity);\n          }\n        }\n      }\n\n      return this;\n    }\n    /**\r\n    * Interface for game entities so they can send messages to other game entities.\r\n    *\r\n    * @param {GameEntity} sender - The sender.\r\n    * @param {GameEntity} receiver - The receiver.\r\n    * @param {String} message - The actual message.\r\n    * @param {Number} delay - A time value in millisecond used to delay the message dispatching.\r\n    * @param {Object} data - An object for custom data.\r\n    * @return {EntityManager} A reference to this entity manager.\r\n    */\n\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(sender, receiver, message, delay, data) {\n      this._messageDispatcher.dispatch(sender, receiver, message, delay, data);\n\n      return this;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var data = {\n        type: this.constructor.name,\n        entities: new Array(),\n        triggers: new Array(),\n        _messageDispatcher: this._messageDispatcher.toJSON()\n      }; // entities\n\n      function processEntity(entity) {\n        data.entities.push(entity.toJSON());\n\n        for (var _i36 = 0, l = entity.children.length; _i36 < l; _i36++) {\n          processEntity(entity.children[_i36]);\n        }\n      }\n\n      for (var _i37 = 0, l = this.entities.length; _i37 < l; _i37++) {\n        // recursively process all entities\n        processEntity(this.entities[_i37]);\n      } // triggers\n\n\n      for (var _i38 = 0, _l2 = this.triggers.length; _i38 < _l2; _i38++) {\n        var trigger = this.triggers[_i38];\n        data.triggers.push(trigger.toJSON());\n      }\n\n      return data;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {EntityManager} A reference to this entity manager.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.clear();\n      var entitiesJSON = json.entities;\n      var triggersJSON = json.triggers;\n      var _messageDispatcherJSON = json._messageDispatcher; // entities\n\n      var entitiesMap = new Map();\n\n      for (var _i39 = 0, l = entitiesJSON.length; _i39 < l; _i39++) {\n        var entityJSON = entitiesJSON[_i39];\n        var type = entityJSON.type;\n        var entity = void 0;\n\n        switch (type) {\n          case 'GameEntity':\n            entity = new GameEntity().fromJSON(entityJSON);\n            break;\n\n          case 'MovingEntity':\n            entity = new MovingEntity().fromJSON(entityJSON);\n            break;\n\n          case 'Vehicle':\n            entity = new Vehicle().fromJSON(entityJSON);\n            break;\n\n          default:\n            // handle custom type\n            var ctor = this._typesMap.get(type);\n\n            if (ctor !== undefined) {\n              entity = new ctor().fromJSON(entityJSON);\n            } else {\n              Logger.warn('YUKA.EntityManager: Unsupported entity type:', type);\n              continue;\n            }\n\n        }\n\n        entitiesMap.set(entity.uuid, entity);\n        if (entity.parent === null) this.add(entity);\n      } // resolve UUIDs to game entity objects\n\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = entitiesMap.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _entity = _step.value;\n\n          _entity.resolveReferences(entitiesMap);\n        } // triggers\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      for (var _i40 = 0, _l3 = triggersJSON.length; _i40 < _l3; _i40++) {\n        var triggerJSON = triggersJSON[_i40];\n        var _type = triggerJSON.type;\n        var trigger = void 0;\n\n        if (_type === 'Trigger') {\n          trigger = new Trigger().fromJSON(triggerJSON);\n        } else {\n          // handle custom type\n          var _ctor = this._typesMap.get(_type);\n\n          if (_ctor !== undefined) {\n            trigger = new _ctor().fromJSON(triggerJSON);\n          } else {\n            Logger.warn('YUKA.EntityManager: Unsupported trigger type:', _type);\n            continue;\n          }\n        }\n\n        this.addTrigger(trigger);\n      } // restore delayed messages\n\n\n      this._messageDispatcher.fromJSON(_messageDispatcherJSON);\n\n      return this;\n    }\n    /**\r\n    * Registers a custom type for deserialization. When calling {@link EntityManager#fromJSON}\r\n    * the entity manager is able to pick the correct constructor in order to create custom\r\n    * game entities or triggers.\r\n    *\r\n    * @param {String} type - The name of the entity or trigger type.\r\n    * @param {Function} constructor - The constructor function.\r\n    * @return {EntityManager} A reference to this entity manager.\r\n    */\n\n  }, {\n    key: \"registerType\",\n    value: function registerType(type, constructor) {\n      this._typesMap.set(type, constructor);\n\n      return this;\n    }\n  }]);\n\n  return EntityManager;\n}();\n/**\r\n* Other classes can inherit from this class in order to provide an\r\n* event based API. Useful for controls development.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar EventDispatcher =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new event dispatcher.\r\n  */\n  function EventDispatcher() {\n    _classCallCheck(this, EventDispatcher);\n\n    this._events = new Map();\n  }\n  /**\r\n  * Adds an event listener for the given event type.\r\n  *\r\n  * @param {String} type - The event type.\r\n  * @param {Function} listener - The event listener to add.\r\n  */\n\n\n  _createClass(EventDispatcher, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type, listener) {\n      var events = this._events;\n\n      if (events.has(type) === false) {\n        events.set(type, new Array());\n      }\n\n      var listeners = events.get(type);\n\n      if (listeners.indexOf(listener) === -1) {\n        listeners.push(listener);\n      }\n    }\n    /**\r\n    * Removes the given event listener for the given event type.\r\n    *\r\n    * @param {String} type - The event type.\r\n    * @param {Function} listener - The event listener to remove.\r\n    */\n\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, listener) {\n      var events = this._events;\n      var listeners = events.get(type);\n\n      if (listeners !== undefined) {\n        var index = listeners.indexOf(listener);\n        if (index !== -1) listeners.splice(index, 1);\n      }\n    }\n    /**\r\n    * Returns true if the given event listener is set for the given event type.\r\n    *\r\n    * @param {String} type - The event type.\r\n    * @param {Function} listener - The event listener to add.\r\n    * @return {Boolean} Whether the given event listener is set for the given event type or not.\r\n    */\n\n  }, {\n    key: \"hasEventListener\",\n    value: function hasEventListener(type, listener) {\n      var events = this._events;\n      var listeners = events.get(type);\n      return listeners !== undefined && listeners.indexOf(listener) !== -1;\n    }\n    /**\r\n    * Dispatches an event to all respective event listeners.\r\n    *\r\n    * @param {Object} event - The event object.\r\n    */\n\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      var events = this._events;\n      var listeners = events.get(event.type);\n\n      if (listeners !== undefined) {\n        event.target = this;\n\n        for (var _i41 = 0, l = listeners.length; _i41 < l; _i41++) {\n          listeners[_i41].call(this, event);\n        }\n      }\n    }\n  }]);\n\n  return EventDispatcher;\n}();\n\nvar v1$2 = new Vector3();\nvar v2 = new Vector3();\nvar d = new Vector3();\n/**\r\n* Class representing a plane in 3D space. The plane is specified in Hessian normal form.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar Plane =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new plane with the given values.\r\n  *\r\n  * @param {Vector3} normal - The normal vector of the plane.\r\n  * @param {Number} constant - The distance of the plane from the origin.\r\n  */\n  function Plane() {\n    var normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(0, 0, 1);\n    var constant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, Plane);\n\n    /**\r\n    * The normal vector of the plane.\r\n    * @type Vector3\r\n    */\n    this.normal = normal;\n    /**\r\n    * The distance of the plane from the origin.\r\n    * @type Number\r\n    */\n\n    this.constant = constant;\n  }\n  /**\r\n  * Sets the given values to this plane.\r\n  *\r\n  * @param {Vector3} normal - The normal vector of the plane.\r\n  * @param {Number} constant - The distance of the plane from the origin.\r\n  * @return {Plane} A reference to this plane.\r\n  */\n\n\n  _createClass(Plane, [{\n    key: \"set\",\n    value: function set(normal, constant) {\n      this.normal = normal;\n      this.constant = constant;\n      return this;\n    }\n    /**\r\n    * Copies all values from the given plane to this plane.\r\n    *\r\n    * @param {Plane} plane - The plane to copy.\r\n    * @return {Plane} A reference to this plane.\r\n    */\n\n  }, {\n    key: \"copy\",\n    value: function copy(plane) {\n      this.normal.copy(plane.normal);\n      this.constant = plane.constant;\n      return this;\n    }\n    /**\r\n    * Creates a new plane and copies all values from this plane.\r\n    *\r\n    * @return {Plane} A new plane.\r\n    */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\r\n    * Computes the signed distance from the given 3D vector to this plane.\r\n    * The sign of the distance indicates the half-space in which the points lies.\r\n    * Zero means the point lies on the plane.\r\n    *\r\n    * @param {Vector3} point - A point in 3D space.\r\n    * @return {Number} The signed distance.\r\n    */\n\n  }, {\n    key: \"distanceToPoint\",\n    value: function distanceToPoint(point) {\n      return this.normal.dot(point) + this.constant;\n    }\n    /**\r\n    * Sets the values of the plane from the given normal vector and a coplanar point.\r\n    *\r\n    * @param {Vector3} normal - A normalized vector.\r\n    * @param {Vector3} point - A coplanar point.\r\n    * @return {Plane} A reference to this plane.\r\n    */\n\n  }, {\n    key: \"fromNormalAndCoplanarPoint\",\n    value: function fromNormalAndCoplanarPoint(normal, point) {\n      this.normal.copy(normal);\n      this.constant = -point.dot(this.normal);\n      return this;\n    }\n    /**\r\n    * Sets the values of the plane from three given coplanar points.\r\n    *\r\n    * @param {Vector3} a - A coplanar point.\r\n    * @param {Vector3} b - A coplanar point.\r\n    * @param {Vector3} c - A coplanar point.\r\n    * @return {Plane} A reference to this plane.\r\n    */\n\n  }, {\n    key: \"fromCoplanarPoints\",\n    value: function fromCoplanarPoints(a, b, c) {\n      v1$2.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();\n      this.fromNormalAndCoplanarPoint(v1$2, a);\n      return this;\n    }\n    /**\r\n    * Performs a plane/plane intersection test and stores the intersection point\r\n    * to the given 3D vector. If no intersection is detected, *null* is returned.\r\n    *\r\n    * Reference: Intersection of Two Planes in Real-Time Collision Detection\r\n    * by Christer Ericson (chapter 5.4.4)\r\n    *\r\n    * @param {Plane} plane - The plane to test.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"intersectPlane\",\n    value: function intersectPlane(plane, result) {\n      // compute direction of intersection line\n      d.crossVectors(this.normal, plane.normal); // if d is zero, the planes are parallel (and separated)\n      // or coincident, so theyre not considered intersecting\n\n      var denom = d.dot(d);\n      if (denom === 0) return null; // compute point on intersection line\n\n      v1$2.copy(plane.normal).multiplyScalar(this.constant);\n      v2.copy(this.normal).multiplyScalar(plane.constant);\n      result.crossVectors(v1$2.sub(v2), d).divideScalar(denom);\n      return result;\n    }\n    /**\r\n    * Returns true if the given plane intersects this plane.\r\n    *\r\n    * @param {Plane} plane - The plane to test.\r\n    * @return {Boolean} The result of the intersection test.\r\n    */\n\n  }, {\n    key: \"intersectsPlane\",\n    value: function intersectsPlane(plane) {\n      var d = this.normal.dot(plane.normal);\n      return Math.abs(d) !== 1;\n    }\n    /**\r\n    * Projects the given point onto the plane. The result is written\r\n    * to the given vector.\r\n    *\r\n    * @param {Vector3} point - The point to project onto the plane.\r\n    * @param {Vector3} result - The projected point.\r\n    * @return {Vector3} The projected point.\r\n    */\n\n  }, {\n    key: \"projectPoint\",\n    value: function projectPoint(point, result) {\n      v1$2.copy(this.normal).multiplyScalar(this.distanceToPoint(point));\n      result.subVectors(point, v1$2);\n      return result;\n    }\n    /**\r\n    * Returns true if the given plane is deep equal with this plane.\r\n    *\r\n    * @param {Plane} plane - The plane to test.\r\n    * @return {Boolean} The result of the equality test.\r\n    */\n\n  }, {\n    key: \"equals\",\n    value: function equals(plane) {\n      return plane.normal.equals(this.normal) && plane.constant === this.constant;\n    }\n  }]);\n\n  return Plane;\n}();\n\nvar boundingSphere$1 = new BoundingSphere();\nvar triangle = {\n  a: new Vector3(),\n  b: new Vector3(),\n  c: new Vector3()\n};\nvar rayLocal = new Ray();\nvar plane = new Plane();\nvar inverseMatrix = new Matrix4();\nvar closestIntersectionPoint = new Vector3();\nvar closestTriangle = {\n  a: new Vector3(),\n  b: new Vector3(),\n  c: new Vector3()\n};\n/**\r\n* Class for representing a polygon mesh. The faces consist of triangles.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar MeshGeometry =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new mesh geometry.\r\n  *\r\n  * @param {TypedArray} vertices - The vertex buffer (Float32Array).\r\n  * @param {TypedArray} indices - The index buffer (Uint16Array/Uint32Array).\r\n  */\n  function MeshGeometry() {\n    var vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Float32Array();\n    var indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, MeshGeometry);\n\n    this.vertices = vertices;\n    this.indices = indices;\n    this.backfaceCulling = true;\n    this.aabb = new AABB();\n    this.boundingSphere = new BoundingSphere();\n    this.computeBoundingVolume();\n  }\n  /**\r\n  * Computes the internal bounding volumes of this mesh geometry.\r\n  *\r\n  * @return {MeshGeometry} A reference to this mesh geometry.\r\n  */\n\n\n  _createClass(MeshGeometry, [{\n    key: \"computeBoundingVolume\",\n    value: function computeBoundingVolume() {\n      var vertices = this.vertices;\n      var vertex = new Vector3();\n      var aabb = this.aabb;\n      var boundingSphere = this.boundingSphere; // compute AABB\n\n      aabb.min.set(Infinity, Infinity, Infinity);\n      aabb.max.set(-Infinity, -Infinity, -Infinity);\n\n      for (var _i42 = 0, l = vertices.length; _i42 < l; _i42 += 3) {\n        vertex.x = vertices[_i42];\n        vertex.y = vertices[_i42 + 1];\n        vertex.z = vertices[_i42 + 2];\n        aabb.expand(vertex);\n      } // compute bounding sphere\n\n\n      aabb.getCenter(boundingSphere.center);\n      boundingSphere.radius = boundingSphere.center.distanceTo(aabb.max);\n      return this;\n    }\n    /**\r\n     * Performs a ray intersection test with the geometry of the obstacle and stores\r\n     * the intersection point in the given result vector. If no intersection is detected,\r\n     * *null* is returned.\r\n     *\r\n     * @param {Ray} ray - The ray to test.\r\n     * @param {Matrix4} worldMatrix - The matrix that transforms the geometry to world space.\r\n     * @param {Boolean} closest - Whether the closest intersection point should be computed or not.\r\n     * @param {Vector3} intersectionPoint - The intersection point.\r\n     * @param {Vector3} normal - The normal vector of the respective triangle.\r\n     * @return {Vector3} The result vector.\r\n     */\n\n  }, {\n    key: \"intersectRay\",\n    value: function intersectRay(ray, worldMatrix, closest, intersectionPoint) {\n      var normal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n      // check bounding sphere first in world space\n      boundingSphere$1.copy(this.boundingSphere).applyMatrix4(worldMatrix);\n\n      if (ray.intersectsBoundingSphere(boundingSphere$1)) {\n        // transform the ray into the local space of the obstacle\n        worldMatrix.getInverse(inverseMatrix);\n        rayLocal.copy(ray).applyMatrix4(inverseMatrix); // check AABB in local space since its more expensive to convert an AABB to world space than a bounding sphere\n\n        if (rayLocal.intersectsAABB(this.aabb)) {\n          // now perform more expensive test with all triangles of the geometry\n          var vertices = this.vertices;\n          var indices = this.indices;\n          var minDistance = Infinity;\n          var found = false;\n\n          if (indices === null) {\n            // non-indexed geometry\n            for (var _i43 = 0, l = vertices.length; _i43 < l; _i43 += 9) {\n              triangle.a.set(vertices[_i43], vertices[_i43 + 1], vertices[_i43 + 2]);\n              triangle.b.set(vertices[_i43 + 3], vertices[_i43 + 4], vertices[_i43 + 5]);\n              triangle.c.set(vertices[_i43 + 6], vertices[_i43 + 7], vertices[_i43 + 8]);\n\n              if (rayLocal.intersectTriangle(triangle, this.backfaceCulling, intersectionPoint) !== null) {\n                if (closest) {\n                  var distance = intersectionPoint.squaredDistanceTo(rayLocal.origin);\n\n                  if (distance < minDistance) {\n                    minDistance = distance;\n                    closestIntersectionPoint.copy(intersectionPoint);\n                    closestTriangle.a.copy(triangle.a);\n                    closestTriangle.b.copy(triangle.b);\n                    closestTriangle.c.copy(triangle.c);\n                    found = true;\n                  }\n                } else {\n                  found = true;\n                  break;\n                }\n              }\n            }\n          } else {\n            // indexed geometry\n            for (var _i44 = 0, _l4 = indices.length; _i44 < _l4; _i44 += 3) {\n              var _a = indices[_i44];\n              var _b = indices[_i44 + 1];\n              var _c = indices[_i44 + 2];\n              var stride = 3;\n              triangle.a.set(vertices[_a * stride], vertices[_a * stride + 1], vertices[_a * stride + 2]);\n              triangle.b.set(vertices[_b * stride], vertices[_b * stride + 1], vertices[_b * stride + 2]);\n              triangle.c.set(vertices[_c * stride], vertices[_c * stride + 1], vertices[_c * stride + 2]);\n\n              if (rayLocal.intersectTriangle(triangle, this.backfaceCulling, intersectionPoint) !== null) {\n                if (closest) {\n                  var _distance = intersectionPoint.squaredDistanceTo(rayLocal.origin);\n\n                  if (_distance < minDistance) {\n                    minDistance = _distance;\n                    closestIntersectionPoint.copy(intersectionPoint);\n                    closestTriangle.a.copy(triangle.a);\n                    closestTriangle.b.copy(triangle.b);\n                    closestTriangle.c.copy(triangle.c);\n                    found = true;\n                  }\n                } else {\n                  found = true;\n                  break;\n                }\n              }\n            }\n          } // intersection was found\n\n\n          if (found) {\n            if (closest) {\n              // restore closest intersection point and triangle\n              intersectionPoint.copy(closestIntersectionPoint);\n              triangle.a.copy(closestTriangle.a);\n              triangle.b.copy(closestTriangle.b);\n              triangle.c.copy(closestTriangle.c);\n            } // transform intersection point back to world space\n\n\n            intersectionPoint.applyMatrix4(worldMatrix); // compute normal of triangle in world space if necessary\n\n            if (normal !== null) {\n              plane.fromCoplanarPoints(triangle.a, triangle.b, triangle.c);\n              normal.copy(plane.normal);\n              normal.transformDirection(worldMatrix);\n            }\n\n            return intersectionPoint;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\r\n     * Returns a new geometry without containing indices.\r\n     *\r\n     * @return {MeshGeometry} The new geometry.\r\n     */\n\n  }, {\n    key: \"toTriangleSoup\",\n    value: function toTriangleSoup() {\n      var indices = this.indices;\n      var vertices = this.vertices;\n      var newVertices;\n\n      if (indices) {\n        newVertices = new Float32Array(indices.length * 3);\n\n        for (var _i45 = 0, l = indices.length; _i45 < l; _i45++) {\n          var _a2 = indices[_i45];\n          var stride = 3;\n          newVertices[_i45 * stride] = vertices[_a2 * stride];\n          newVertices[_i45 * stride + 1] = vertices[_a2 * stride + 1];\n          newVertices[_i45 * stride + 2] = vertices[_a2 * stride + 2];\n        }\n      } else {\n        newVertices = new Float32Array(vertices);\n      }\n\n      return new MeshGeometry(newVertices);\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        type: this.constructor.name\n      };\n      json.indices = {\n        type: this.indices ? this.indices.constructor.name : 'null',\n        data: this.indices ? Array.from(this.indices) : null\n      };\n      json.vertices = Array.from(this.vertices);\n      json.backfaceCulling = this.backfaceCulling;\n      json.aabb = this.aabb.toJSON();\n      json.boundingSphere = this.boundingSphere.toJSON();\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {MeshGeometry} A reference to this mesh geometry.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.aabb = new AABB().fromJSON(json.aabb);\n      this.boundingSphere = new BoundingSphere().fromJSON(json.boundingSphere);\n      this.backfaceCulling = json.backfaceCulling;\n      this.vertices = new Float32Array(json.vertices);\n\n      switch (json.indices.type) {\n        case 'Uint16Array':\n          this.indices = new Uint16Array(json.indices.data);\n          break;\n\n        case 'Uint32Array':\n          this.indices = new Uint32Array(json.indices.data);\n          break;\n\n        case 'null':\n          this.indices = null;\n          break;\n      }\n\n      return this;\n    }\n  }]);\n\n  return MeshGeometry;\n}();\n/**\r\n* Class for representing a timer.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar Time =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new time object.\r\n  */\n  function Time() {\n    _classCallCheck(this, Time);\n\n    /**\r\n    * The start time of this timer.\r\n    * @type Number\r\n    * @default 0\r\n    */\n    this.startTime = 0;\n    /**\r\n    * The time stamp of the last simulation step.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    this.previousTime = 0;\n    /**\r\n    * The time stamp of the current simulation step.\r\n    * @type Number\r\n    */\n\n    this.currentTime = this.now();\n    /**\r\n    * Whether the Page Visibility API should be used to avoid large time\r\n    * delta values produced via inactivity or not. This setting is\r\n    * ignored if the browser does not support the API.\r\n    * @type Boolean\r\n    * @default true\r\n    */\n\n    this.detectPageVisibility = true; //\n\n    if (typeof document !== 'undefined' && document.hidden !== undefined) {\n      this._pageVisibilityHandler = handleVisibilityChange.bind(this);\n      document.addEventListener('visibilitychange', this._pageVisibilityHandler, false);\n    }\n  }\n  /**\r\n  * Returns the delta time in seconds for the current simulation step.\r\n  *\r\n  * @return {Number} The delta time in seconds.\r\n  */\n\n\n  _createClass(Time, [{\n    key: \"getDelta\",\n    value: function getDelta() {\n      return (this.currentTime - this.previousTime) / 1000;\n    }\n    /**\r\n    * Returns the elapsed time in seconds of this timer.\r\n    *\r\n    * @return {Number} The elapsed time in seconds.\r\n    */\n\n  }, {\n    key: \"getElapsed\",\n    value: function getElapsed() {\n      return (this.currentTime - this.startTime) / 1000;\n    }\n    /**\r\n    * Updates the internal state of this timer.\r\n    *\r\n    * @return {Time} A reference to this timer.\r\n    */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.previousTime = this.currentTime;\n      this.currentTime = this.now();\n      return this;\n    }\n    /**\r\n    * Returns a current time value in milliseconds.\r\n    *\r\n    * @return {Number} A current time value in milliseconds.\r\n    */\n\n  }, {\n    key: \"now\",\n    value: function now() {\n      return (typeof performance === 'undefined' ? Date : performance).now();\n    }\n  }]);\n\n  return Time;\n}(); //\n\n\nfunction handleVisibilityChange() {\n  if (this.detectPageVisibility === true && document.hidden === false) {\n    // reset the current time when the app was inactive (window minimized or tab switched)\n    this.currentTime = this.now();\n  }\n}\n/**\r\n* Not all components of an AI system need to be updated in each simulation step.\r\n* This class can be used to control the update process by defining how many updates\r\n* should be executed per second.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar Regulator =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new regulator.\r\n  *\r\n  * @param {Number} updateFrequency - The amount of updates per second.\r\n  */\n  function Regulator() {\n    var updateFrequency = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    _classCallCheck(this, Regulator);\n\n    /**\r\n    * The amount of updates per second.\r\n    * @type Number\r\n    * @default 0\r\n    */\n    this.updateFrequency = updateFrequency;\n    this._time = new Time();\n    this._nextUpdateTime = 0;\n  }\n  /**\r\n  * Returns true if it is time to allow the next update.\r\n  *\r\n  * @return {Boolean} Whether an update is allowed or not.\r\n  */\n\n\n  _createClass(Regulator, [{\n    key: \"ready\",\n    value: function ready() {\n      this._time.update();\n\n      if (this._time.currentTime >= this._nextUpdateTime) {\n        this._nextUpdateTime = this._time.currentTime + 1000 / this.updateFrequency;\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return Regulator;\n}();\n/**\r\n* Base class for representing a state in context of State-driven agent design.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar State =\n/*#__PURE__*/\nfunction () {\n  function State() {\n    _classCallCheck(this, State);\n  }\n\n  _createClass(State, [{\n    key: \"enter\",\n\n    /**\r\n    * This method is called once during a state transition when the {@link StateMachine} makes\r\n    * this state active.\r\n    *\r\n    * @param {GameEntity} owner - The game entity that represents the execution context of this state.\r\n    */\n    value: function enter()\n    /* owner */\n    {}\n    /**\r\n    * This method is called per simulation step if this state is active.\r\n    *\r\n    * @param {GameEntity} owner - The game entity that represents the execution context of this state.\r\n    */\n\n  }, {\n    key: \"execute\",\n    value: function execute()\n    /* owner */\n    {}\n    /**\r\n    * This method is called once during a state transition when the {@link StateMachine} makes\r\n    * this state inactive.\r\n    *\r\n    * @param {GameEntity} owner - The game entity that represents the execution context of this state.\r\n    */\n\n  }, {\n    key: \"exit\",\n    value: function exit()\n    /* owner */\n    {}\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {}\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {State} A reference to this state.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON()\n    /* json */\n    {}\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {State} A reference to this state.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences()\n    /* entities */\n    {}\n    /**\r\n    * This method is called when messaging between game entities occurs.\r\n    *\r\n    * @param {GameEntity} owner - The game entity that represents the execution context of this state.\r\n    * @param {Telegram} telegram - A data structure containing the actual message.\r\n    * @return {Boolean} Whether the message was processed or not.\r\n    */\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage()\n    /* owner, telegram */\n    {\n      return false;\n    }\n  }]);\n\n  return State;\n}();\n/**\r\n* Finite state machine (FSM) for implementing State-driven agent design.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar StateMachine =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new state machine with the given values.\r\n  *\r\n  * @param {GameEntity} owner - The owner of this state machine.\r\n  */\n  function StateMachine() {\n    var owner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, StateMachine);\n\n    /**\r\n    * The game entity that owns this state machine.\r\n    * @type GameEntity\r\n    */\n    this.owner = owner;\n    /**\r\n    * The current state of the game entity.\r\n    * @type State\r\n    */\n\n    this.currentState = null;\n    /**\r\n    * The previous state of the game entity.\r\n    * @type State\r\n    */\n\n    this.previousState = null; // a reference to the last state the agent was in\n\n    /**\r\n    * This state logic is called every time the state machine is updated.\r\n    * @type State\r\n    */\n\n    this.globalState = null;\n    /**\r\n    * A map with all states of the state machine.\r\n    * @type Map\r\n    */\n\n    this.states = new Map(); //\n\n    this._typesMap = new Map();\n  }\n  /**\r\n  * Updates the internal state of the FSM. Usually called by {@link GameEntity#update}.\r\n  *\r\n  * @return {StateMachine} A reference to this state machine.\r\n  */\n\n\n  _createClass(StateMachine, [{\n    key: \"update\",\n    value: function update() {\n      if (this.globalState !== null) {\n        this.globalState.execute(this.owner);\n      }\n\n      if (this.currentState !== null) {\n        this.currentState.execute(this.owner);\n      }\n\n      return this;\n    }\n    /**\r\n    * Adds a new state with the given ID to the state machine.\r\n    *\r\n    * @param {String} id - The ID of the state.\r\n    * @param {State} state - The state.\r\n    * @return {StateMachine} A reference to this state machine.\r\n    */\n\n  }, {\n    key: \"add\",\n    value: function add(id, state) {\n      if (state instanceof State) {\n        this.states.set(id, state);\n      } else {\n        Logger.warn('YUKA.StateMachine: .add() needs a parameter of type \"YUKA.State\".');\n      }\n\n      return this;\n    }\n    /**\r\n    * Removes a state via its ID from the state machine.\r\n    *\r\n    * @param {String} id - The ID of the state.\r\n    * @return {StateMachine} A reference to this state machine.\r\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove(id) {\n      this.states.delete(id);\n      return this;\n    }\n    /**\r\n    * Returns the state for the given ID.\r\n    *\r\n    * @param {String} id - The ID of the state.\r\n    * @return {State} The state for the given ID.\r\n    */\n\n  }, {\n    key: \"get\",\n    value: function get(id) {\n      return this.states.get(id);\n    }\n    /**\r\n    * Performs a state change to the state defined by its ID.\r\n    *\r\n    * @param {String} id - The ID of the state.\r\n    * @return {StateMachine} A reference to this state machine.\r\n    */\n\n  }, {\n    key: \"changeTo\",\n    value: function changeTo(id) {\n      var state = this.get(id);\n\n      this._change(state);\n\n      return this;\n    }\n    /**\r\n    * Returns to the previous state.\r\n    *\r\n    * @return {StateMachine} A reference to this state machine.\r\n    */\n\n  }, {\n    key: \"revert\",\n    value: function revert() {\n      this._change(this.previousState);\n\n      return this;\n    }\n    /**\r\n    * Returns true if this FSM is in the given state.\r\n    *\r\n    * @return {Boolean} Whether this FSM is in the given state or not.\r\n    */\n\n  }, {\n    key: \"in\",\n    value: function _in(id) {\n      var state = this.get(id);\n      return state === this.currentState;\n    }\n    /**\r\n    * Tries to dispatch the massage to the current or global state and returns true\r\n    * if the message was processed successfully.\r\n    *\r\n    * @param {Telegram} telegram - The telegram with the message data.\r\n    * @return {Boolean} Whether the message was processed or not.\r\n    */\n\n  }, {\n    key: \"handleMessage\",\n    value: function handleMessage(telegram) {\n      // first see, if the current state is valid and that it can handle the message\n      if (this.currentState !== null && this.currentState.onMessage(this.owner, telegram) === true) {\n        return true;\n      } // if not, and if a global state has been implemented, send the message to the global state\n\n\n      if (this.globalState !== null && this.globalState.onMessage(this.owner, telegram) === true) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        owner: this.owner.uuid,\n        currentState: null,\n        previousState: null,\n        globalState: null,\n        states: new Array()\n      };\n      var statesMap = new Map(); // states\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.states[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              id = _step2$value[0],\n              state = _step2$value[1];\n\n          json.states.push({\n            type: state.constructor.name,\n            id: id,\n            state: state.toJSON()\n          });\n          statesMap.set(state, id);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      json.currentState = statesMap.get(this.currentState) || null;\n      json.previousState = statesMap.get(this.previousState) || null;\n      json.globalState = statesMap.get(this.globalState) || null;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {StateMachine} A reference to this state machine.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.owner = json.owner; //\n\n      var statesJSON = json.states;\n\n      for (var _i46 = 0, l = statesJSON.length; _i46 < l; _i46++) {\n        var stateJSON = statesJSON[_i46];\n        var type = stateJSON.type;\n\n        var ctor = this._typesMap.get(type);\n\n        if (ctor !== undefined) {\n          var id = stateJSON.id;\n          var state = new ctor().fromJSON(stateJSON.state);\n          this.add(id, state);\n        } else {\n          Logger.warn('YUKA.StateMachine: Unsupported state type:', type);\n          continue;\n        }\n      } //\n\n\n      this.currentState = json.currentState !== null ? this.get(json.currentState) || null : null;\n      this.previousState = json.previousState !== null ? this.get(json.previousState) || null : null;\n      this.globalState = json.globalState !== null ? this.get(json.globalState) || null : null;\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {StateMachine} A reference to this state machine.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      this.owner = entities.get(this.owner) || null;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.states.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var state = _step3.value;\n          state.resolveReferences(entities);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return this;\n    }\n    /**\r\n    * Registers a custom type for deserialization. When calling {@link StateMachine#fromJSON}\r\n    * the state machine is able to pick the correct constructor in order to create custom states.\r\n    *\r\n    * @param {String} type - The name of the state type.\r\n    * @param {Function} constructor - The constructor function.\r\n    * @return {StateMachine} A reference to this state machine.\r\n    */\n\n  }, {\n    key: \"registerType\",\n    value: function registerType(type, constructor) {\n      this._typesMap.set(type, constructor);\n\n      return this;\n    } //\n\n  }, {\n    key: \"_change\",\n    value: function _change(state) {\n      this.previousState = this.currentState;\n      this.currentState.exit(this.owner);\n      this.currentState = state;\n      this.currentState.enter(this.owner);\n    }\n  }]);\n\n  return StateMachine;\n}();\n/**\r\n* Base class for representing a term in a {@link FuzzyRule}.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar FuzzyTerm =\n/*#__PURE__*/\nfunction () {\n  function FuzzyTerm() {\n    _classCallCheck(this, FuzzyTerm);\n  }\n\n  _createClass(FuzzyTerm, [{\n    key: \"clearDegreeOfMembership\",\n\n    /**\r\n    * Clears the degree of membership value.\r\n    *\r\n    * @return {FuzzyTerm} A reference to this term.\r\n    */\n    value: function clearDegreeOfMembership() {}\n    /**\r\n    * Returns the degree of membership.\r\n    *\r\n    * @return {Number} Degree of membership.\r\n    */\n\n  }, {\n    key: \"getDegreeOfMembership\",\n    value: function getDegreeOfMembership() {}\n    /**\r\n    * Updates the degree of membership by the given value. This method is used when\r\n    * the term is part of a fuzzy rule's consequent.\r\n    *\r\n    * @param {Number} value - The value used to update the degree of membership.\r\n    * @return {FuzzyTerm} A reference to this term.\r\n    */\n\n  }, {\n    key: \"updateDegreeOfMembership\",\n    value: function updateDegreeOfMembership()\n    /* value */\n    {}\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.constructor.name\n      };\n    }\n  }]);\n\n  return FuzzyTerm;\n}();\n/**\r\n* Base class for representing more complex fuzzy terms based on the\r\n* composite design pattern.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments FuzzyTerm\r\n*/\n\n\nvar FuzzyCompositeTerm =\n/*#__PURE__*/\nfunction (_FuzzyTerm) {\n  _inherits(FuzzyCompositeTerm, _FuzzyTerm);\n\n  /**\r\n  * Constructs a new fuzzy composite term with the given values.\r\n  *\r\n  * @param {Array} terms - An arbitrary amount of fuzzy terms.\r\n  */\n  function FuzzyCompositeTerm() {\n    var _this16;\n\n    var terms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Array();\n\n    _classCallCheck(this, FuzzyCompositeTerm);\n\n    _this16 = _possibleConstructorReturn(this, _getPrototypeOf(FuzzyCompositeTerm).call(this));\n    /**\r\n    * List of fuzzy terms.\r\n    * @type Array\r\n    */\n\n    _this16.terms = terms;\n    return _this16;\n  }\n  /**\r\n  * Clears the degree of membership value.\r\n  *\r\n  * @return {FuzzyCompositeTerm} A reference to this term.\r\n  */\n\n\n  _createClass(FuzzyCompositeTerm, [{\n    key: \"clearDegreeOfMembership\",\n    value: function clearDegreeOfMembership() {\n      var terms = this.terms;\n\n      for (var _i47 = 0, l = terms.length; _i47 < l; _i47++) {\n        terms[_i47].clearDegreeOfMembership();\n      }\n\n      return this;\n    }\n    /**\r\n    * Updates the degree of membership by the given value. This method is used when\r\n    * the term is part of a fuzzy rule's consequent.\r\n    *\r\n    * @param {Number} value - The value used to update the degree of membership.\r\n    * @return {FuzzyCompositeTerm} A reference to this term.\r\n    */\n\n  }, {\n    key: \"updateDegreeOfMembership\",\n    value: function updateDegreeOfMembership(value) {\n      var terms = this.terms;\n\n      for (var _i48 = 0, l = terms.length; _i48 < l; _i48++) {\n        terms[_i48].updateDegreeOfMembership(value);\n      }\n\n      return this;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(FuzzyCompositeTerm.prototype), \"toJSON\", this).call(this);\n\n      json.terms = new Array();\n\n      for (var _i49 = 0, l = this.terms.length; _i49 < l; _i49++) {\n        var term = this.terms[_i49];\n\n        if (term instanceof FuzzyCompositeTerm) {\n          json.terms.push(term.toJSON());\n        } else {\n          json.terms.push(term.uuid);\n        }\n      }\n\n      return json;\n    }\n  }]);\n\n  return FuzzyCompositeTerm;\n}(FuzzyTerm);\n/**\r\n* Class for representing an AND operator. Can be used to construct\r\n* fuzzy rules.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments FuzzyCompositeTerm\r\n*/\n\n\nvar FuzzyAND =\n/*#__PURE__*/\nfunction (_FuzzyCompositeTerm) {\n  _inherits(FuzzyAND, _FuzzyCompositeTerm);\n\n  /**\r\n  * Constructs a new fuzzy AND operator with the given values. The constructor\r\n  * accepts and arbitrary amount of fuzzy terms.\r\n  */\n  function FuzzyAND() {\n    _classCallCheck(this, FuzzyAND);\n\n    var terms = Array.from(arguments);\n    return _possibleConstructorReturn(this, _getPrototypeOf(FuzzyAND).call(this, terms));\n  }\n  /**\r\n  * Returns the degree of membership. The AND operator returns the minimum\r\n  * degree of membership of the sets it is operating on.\r\n  *\r\n  * @return {Number} Degree of membership.\r\n  */\n\n\n  _createClass(FuzzyAND, [{\n    key: \"getDegreeOfMembership\",\n    value: function getDegreeOfMembership() {\n      var terms = this.terms;\n      var minDOM = Infinity;\n\n      for (var _i50 = 0, l = terms.length; _i50 < l; _i50++) {\n        var term = terms[_i50];\n        var currentDOM = term.getDegreeOfMembership();\n        if (currentDOM < minDOM) minDOM = currentDOM;\n      }\n\n      return minDOM;\n    }\n  }]);\n\n  return FuzzyAND;\n}(FuzzyCompositeTerm);\n/**\r\n* Hedges are special unary operators that can be employed to modify the meaning\r\n* of a fuzzy set. The FAIRLY fuzzy hedge widens the membership function.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments FuzzyCompositeTerm\r\n*/\n\n\nvar FuzzyFAIRLY =\n/*#__PURE__*/\nfunction (_FuzzyCompositeTerm2) {\n  _inherits(FuzzyFAIRLY, _FuzzyCompositeTerm2);\n\n  /**\r\n  * Constructs a new fuzzy FAIRLY hedge with the given values.\r\n  *\r\n  * @param {FuzzyTerm} fuzzyTerm - The fuzzy term this hedge is working on.\r\n  */\n  function FuzzyFAIRLY() {\n    var fuzzyTerm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, FuzzyFAIRLY);\n\n    var terms = fuzzyTerm !== null ? [fuzzyTerm] : new Array();\n    return _possibleConstructorReturn(this, _getPrototypeOf(FuzzyFAIRLY).call(this, terms));\n  } // FuzzyTerm API\n\n  /**\r\n  * Clears the degree of membership value.\r\n  *\r\n  * @return {FuzzyFAIRLY} A reference to this fuzzy hedge.\r\n  */\n\n\n  _createClass(FuzzyFAIRLY, [{\n    key: \"clearDegreeOfMembership\",\n    value: function clearDegreeOfMembership() {\n      var fuzzyTerm = this.terms[0];\n      fuzzyTerm.clearDegreeOfMembership();\n      return this;\n    }\n    /**\r\n    * Returns the degree of membership.\r\n    *\r\n    * @return {Number} Degree of membership.\r\n    */\n\n  }, {\n    key: \"getDegreeOfMembership\",\n    value: function getDegreeOfMembership() {\n      var fuzzyTerm = this.terms[0];\n      var dom = fuzzyTerm.getDegreeOfMembership();\n      return Math.sqrt(dom);\n    }\n    /**\r\n    * Updates the degree of membership by the given value.\r\n    *\r\n    * @return {FuzzyFAIRLY} A reference to this fuzzy hedge.\r\n    */\n\n  }, {\n    key: \"updateDegreeOfMembership\",\n    value: function updateDegreeOfMembership(value) {\n      var fuzzyTerm = this.terms[0];\n      fuzzyTerm.updateDegreeOfMembership(Math.sqrt(value));\n      return this;\n    }\n  }]);\n\n  return FuzzyFAIRLY;\n}(FuzzyCompositeTerm);\n/**\r\n* Class for representing an OR operator. Can be used to construct\r\n* fuzzy rules.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments FuzzyCompositeTerm\r\n*/\n\n\nvar FuzzyOR =\n/*#__PURE__*/\nfunction (_FuzzyCompositeTerm3) {\n  _inherits(FuzzyOR, _FuzzyCompositeTerm3);\n\n  /**\r\n  * Constructs a new fuzzy AND operator with the given values. The constructor\r\n  * accepts and arbitrary amount of fuzzy terms.\r\n  */\n  function FuzzyOR() {\n    _classCallCheck(this, FuzzyOR);\n\n    var terms = Array.from(arguments);\n    return _possibleConstructorReturn(this, _getPrototypeOf(FuzzyOR).call(this, terms));\n  }\n  /**\r\n  * Returns the degree of membership. The AND operator returns the maximum\r\n  * degree of membership of the sets it is operating on.\r\n  *\r\n  * @return {Number} Degree of membership.\r\n  */\n\n\n  _createClass(FuzzyOR, [{\n    key: \"getDegreeOfMembership\",\n    value: function getDegreeOfMembership() {\n      var terms = this.terms;\n      var maxDOM = -Infinity;\n\n      for (var _i51 = 0, l = terms.length; _i51 < l; _i51++) {\n        var term = terms[_i51];\n        var currentDOM = term.getDegreeOfMembership();\n        if (currentDOM > maxDOM) maxDOM = currentDOM;\n      }\n\n      return maxDOM;\n    }\n  }]);\n\n  return FuzzyOR;\n}(FuzzyCompositeTerm);\n/**\r\n* Hedges are special unary operators that can be employed to modify the meaning\r\n* of a fuzzy set. The FAIRLY fuzzy hedge widens the membership function.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments FuzzyCompositeTerm\r\n*/\n\n\nvar FuzzyVERY =\n/*#__PURE__*/\nfunction (_FuzzyCompositeTerm4) {\n  _inherits(FuzzyVERY, _FuzzyCompositeTerm4);\n\n  /**\r\n  * Constructs a new fuzzy VERY hedge with the given values.\r\n  *\r\n  * @param {FuzzyTerm} fuzzyTerm - The fuzzy term this hedge is working on.\r\n  */\n  function FuzzyVERY() {\n    var fuzzyTerm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, FuzzyVERY);\n\n    var terms = fuzzyTerm !== null ? [fuzzyTerm] : new Array();\n    return _possibleConstructorReturn(this, _getPrototypeOf(FuzzyVERY).call(this, terms));\n  } // FuzzyTerm API\n\n  /**\r\n  * Clears the degree of membership value.\r\n  *\r\n  * @return {FuzzyVERY} A reference to this fuzzy hedge.\r\n  */\n\n\n  _createClass(FuzzyVERY, [{\n    key: \"clearDegreeOfMembership\",\n    value: function clearDegreeOfMembership() {\n      var fuzzyTerm = this.terms[0];\n      fuzzyTerm.clearDegreeOfMembership();\n      return this;\n    }\n    /**\r\n    * Returns the degree of membership.\r\n    *\r\n    * @return {Number} Degree of membership.\r\n    */\n\n  }, {\n    key: \"getDegreeOfMembership\",\n    value: function getDegreeOfMembership() {\n      var fuzzyTerm = this.terms[0];\n      var dom = fuzzyTerm.getDegreeOfMembership();\n      return dom * dom;\n    }\n    /**\r\n    * Updates the degree of membership by the given value.\r\n    *\r\n    * @return {FuzzyVERY} A reference to this fuzzy hedge.\r\n    */\n\n  }, {\n    key: \"updateDegreeOfMembership\",\n    value: function updateDegreeOfMembership(value) {\n      var fuzzyTerm = this.terms[0];\n      fuzzyTerm.updateDegreeOfMembership(value * value);\n      return this;\n    }\n  }]);\n\n  return FuzzyVERY;\n}(FuzzyCompositeTerm);\n/**\r\n* Base class for fuzzy sets. This type of sets are defined by a membership function\r\n* which can be any arbitrary shape but are typically triangular or trapezoidal. They define\r\n* a gradual transition from regions completely outside the set to regions completely\r\n* within the set, thereby enabling a value to have partial membership to a set.\r\n*\r\n* This class is derived from {@link FuzzyTerm} so it can be directly used in fuzzy rules.\r\n* According to the composite design pattern, a fuzzy set can be considered as an atomic fuzzy term.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments FuzzyTerm\r\n*/\n\n\nvar FuzzySet =\n/*#__PURE__*/\nfunction (_FuzzyTerm2) {\n  _inherits(FuzzySet, _FuzzyTerm2);\n\n  /**\r\n  * Constructs a new fuzzy set with the given values.\r\n  *\r\n  * @param {Number} representativeValue - The maximum of the set's membership function.\r\n  */\n  function FuzzySet() {\n    var _this17;\n\n    var representativeValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    _classCallCheck(this, FuzzySet);\n\n    _this17 = _possibleConstructorReturn(this, _getPrototypeOf(FuzzySet).call(this));\n    /**\r\n    * Represents the degree of membership to this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this17.degreeOfMembership = 0;\n    /**\r\n    * The maximum of the set's membership function. For instance, if\r\n    * the set is triangular then this will be the peak point of the triangular.\r\n    * If the set has a plateau then this value will be the mid point of the\r\n    * plateau. Used to avoid runtime calculations.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this17.representativeValue = representativeValue;\n    /**\r\n    * Represents the left border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this17.left = 0;\n    /**\r\n    * Represents the right border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this17.right = 0; //\n\n    _this17._uuid = null;\n    return _this17;\n  }\n\n  _createClass(FuzzySet, [{\n    key: \"computeDegreeOfMembership\",\n\n    /**\r\n    * Computes the degree of membership for the given value. Notice that this method\r\n    * does not set {@link FuzzySet#degreeOfMembership} since other classes use it in\r\n    * order to calculate intermediate degree of membership values. This method be\r\n    * implemented by all concrete fuzzy set classes.\r\n    *\r\n    * @param {Number} value - The value used to calculate the degree of membership.\r\n    * @return {Number} The degree of membership.\r\n    */\n    value: function computeDegreeOfMembership()\n    /* value */\n    {} // FuzzyTerm API\n\n    /**\r\n    * Clears the degree of membership value.\r\n    *\r\n    * @return {FuzzySet} A reference to this fuzzy set.\r\n    */\n\n  }, {\n    key: \"clearDegreeOfMembership\",\n    value: function clearDegreeOfMembership() {\n      this.degreeOfMembership = 0;\n      return this;\n    }\n    /**\r\n    * Returns the degree of membership.\r\n    *\r\n    * @return {Number} Degree of membership.\r\n    */\n\n  }, {\n    key: \"getDegreeOfMembership\",\n    value: function getDegreeOfMembership() {\n      return this.degreeOfMembership;\n    }\n    /**\r\n    * Updates the degree of membership by the given value. This method is used when\r\n    * the set is part of a fuzzy rule's consequent.\r\n    *\r\n    * @return {FuzzySet} A reference to this fuzzy set.\r\n    */\n\n  }, {\n    key: \"updateDegreeOfMembership\",\n    value: function updateDegreeOfMembership(value) {\n      // update the degree of membership if the given value is greater than the\n      // existing one\n      if (value > this.degreeOfMembership) this.degreeOfMembership = value;\n      return this;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(FuzzySet.prototype), \"toJSON\", this).call(this);\n\n      json.degreeOfMembership = this.degreeOfMembership;\n      json.representativeValue = this.representativeValue;\n      json.left = this.left;\n      json.right = this.right;\n      json.uuid = this.uuid;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {FuzzySet} A reference to this fuzzy set.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.degreeOfMembership = json.degreeOfMembership;\n      this.representativeValue = json.representativeValue;\n      this.left = json.left;\n      this.right = json.right;\n      this.uuid = json.uuid;\n      return this;\n    }\n  }, {\n    key: \"uuid\",\n    get: function get() {\n      if (this._uuid === null) {\n        this._uuid = MathUtils.generateUUID();\n      }\n\n      return this._uuid;\n    },\n    set: function set(uuid) {\n      this._uuid = uuid;\n    }\n  }]);\n\n  return FuzzySet;\n}(FuzzyTerm);\n/**\r\n* Class for representing a fuzzy set that has a s-shape membership function with\r\n* values from highest to lowest.\r\n*\r\n* @author {@link https://github.com/robp94|robp94}\r\n* @augments FuzzySet\r\n*/\n\n\nvar LeftSCurveFuzzySet =\n/*#__PURE__*/\nfunction (_FuzzySet) {\n  _inherits(LeftSCurveFuzzySet, _FuzzySet);\n\n  /**\r\n  * Constructs a new S-curve fuzzy set with the given values.\r\n  *\r\n  * @param {Number} left - Represents the left border of this fuzzy set.\r\n  * @param {Number} midpoint - Represents the peak value of this fuzzy set.\r\n  * @param {Number} right - Represents the right border of this fuzzy set.\r\n  */\n  function LeftSCurveFuzzySet() {\n    var _this18;\n\n    var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var midpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var right = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, LeftSCurveFuzzySet);\n\n    // the representative value is the midpoint of the plateau of the shoulder\n    var representativeValue = (midpoint + left) / 2;\n    _this18 = _possibleConstructorReturn(this, _getPrototypeOf(LeftSCurveFuzzySet).call(this, representativeValue));\n    /**\r\n    * Represents the left border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this18.left = left;\n    /**\r\n    * Represents the peak value of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this18.midpoint = midpoint;\n    /**\r\n    * Represents the right border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this18.right = right;\n    return _this18;\n  }\n  /**\r\n  * Computes the degree of membership for the given value.\r\n  *\r\n  * @param {Number} value - The value used to calculate the degree of membership.\r\n  * @return {Number} The degree of membership.\r\n  */\n\n\n  _createClass(LeftSCurveFuzzySet, [{\n    key: \"computeDegreeOfMembership\",\n    value: function computeDegreeOfMembership(value) {\n      var midpoint = this.midpoint;\n      var left = this.left;\n      var right = this.right; // find DOM if the given value is left of the center or equal to the center\n\n      if (value >= left && value <= midpoint) {\n        return 1;\n      } // find DOM if the given value is right of the midpoint\n\n\n      if (value > midpoint && value <= right) {\n        if (value >= (midpoint + right) / 2) {\n          return 2 * Math.pow((value - right) / (midpoint - right), 2);\n        } else {\n          //todo test\n          return 1 - 2 * Math.pow((value - midpoint) / (midpoint - right), 2);\n        }\n      } // out of range\n\n\n      return 0;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(LeftSCurveFuzzySet.prototype), \"toJSON\", this).call(this);\n\n      json.midpoint = this.midpoint;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {LeftSCurveFuzzySet} A reference to this fuzzy set.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(LeftSCurveFuzzySet.prototype), \"fromJSON\", this).call(this, json);\n\n      this.midpoint = json.midpoint;\n      return this;\n    }\n  }]);\n\n  return LeftSCurveFuzzySet;\n}(FuzzySet);\n/**\r\n* Class for representing a fuzzy set that has a left shoulder shape. The range between\r\n* the midpoint and left border point represents the same DOM.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments FuzzySet\r\n*/\n\n\nvar LeftShoulderFuzzySet =\n/*#__PURE__*/\nfunction (_FuzzySet2) {\n  _inherits(LeftShoulderFuzzySet, _FuzzySet2);\n\n  /**\r\n  * Constructs a new left shoulder fuzzy set with the given values.\r\n  *\r\n  * @param {Number} left - Represents the left border of this fuzzy set.\r\n  * @param {Number} midpoint - Represents the peak value of this fuzzy set.\r\n  * @param {Number} right - Represents the right border of this fuzzy set.\r\n  */\n  function LeftShoulderFuzzySet() {\n    var _this19;\n\n    var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var midpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var right = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, LeftShoulderFuzzySet);\n\n    // the representative value is the midpoint of the plateau of the shoulder\n    var representativeValue = (midpoint + left) / 2;\n    _this19 = _possibleConstructorReturn(this, _getPrototypeOf(LeftShoulderFuzzySet).call(this, representativeValue));\n    /**\r\n    * Represents the left border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this19.left = left;\n    /**\r\n    * Represents the peak value of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this19.midpoint = midpoint;\n    /**\r\n    * Represents the right border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this19.right = right;\n    return _this19;\n  }\n  /**\r\n  * Computes the degree of membership for the given value.\r\n  *\r\n  * @param {Number} value - The value used to calculate the degree of membership.\r\n  * @return {Number} The degree of membership.\r\n  */\n\n\n  _createClass(LeftShoulderFuzzySet, [{\n    key: \"computeDegreeOfMembership\",\n    value: function computeDegreeOfMembership(value) {\n      var midpoint = this.midpoint;\n      var left = this.left;\n      var right = this.right; // find DOM if the given value is left of the center or equal to the center\n\n      if (value >= left && value <= midpoint) {\n        return 1;\n      } // find DOM if the given value is right of the midpoint\n\n\n      if (value > midpoint && value <= right) {\n        var grad = 1 / (right - midpoint);\n        return grad * (right - value);\n      } // out of range\n\n\n      return 0;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(LeftShoulderFuzzySet.prototype), \"toJSON\", this).call(this);\n\n      json.midpoint = this.midpoint;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {LeftShoulderFuzzySet} A reference to this fuzzy set.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(LeftShoulderFuzzySet.prototype), \"fromJSON\", this).call(this, json);\n\n      this.midpoint = json.midpoint;\n      return this;\n    }\n  }]);\n\n  return LeftShoulderFuzzySet;\n}(FuzzySet);\n/**\r\n* Class for representing a fuzzy set that has a normal distribution shape. It can be defined\r\n* by the mean and standard deviation.\r\n*\r\n* @author {@link https://github.com/robp94|robp94}\r\n* @augments FuzzySet\r\n*/\n\n\nvar NormalDistFuzzySet =\n/*#__PURE__*/\nfunction (_FuzzySet3) {\n  _inherits(NormalDistFuzzySet, _FuzzySet3);\n\n  /**\r\n  * Constructs a new triangular fuzzy set with the given values.\r\n  *\r\n  * @param {Number} left - Represents the left border of this fuzzy set.\r\n  * @param {Number} midpoint - Mean or expectation of the normal distribution.\r\n  * @param {Number} right - Represents the right border of this fuzzy set.\r\n  * @param {Number} standardDeviation - Standard deviation of the normal distribution.\r\n  */\n  function NormalDistFuzzySet() {\n    var _this20;\n\n    var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var midpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var right = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var standardDeviation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    _classCallCheck(this, NormalDistFuzzySet);\n\n    _this20 = _possibleConstructorReturn(this, _getPrototypeOf(NormalDistFuzzySet).call(this, midpoint));\n    /**\r\n    * Represents the left border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this20.left = left;\n    /**\r\n    * Represents the peak value of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this20.midpoint = midpoint;\n    /**\r\n    * Represents the right border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this20.right = right;\n    /**\r\n    * Represents the standard deviation of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this20.standardDeviation = standardDeviation; //\n\n    _this20._cache = {};\n    return _this20;\n  }\n  /**\r\n  * Computes the degree of membership for the given value.\r\n  *\r\n  * @param {Number} value - The value used to calculate the degree of membership.\r\n  * @return {Number} The degree of membership.\r\n  */\n\n\n  _createClass(NormalDistFuzzySet, [{\n    key: \"computeDegreeOfMembership\",\n    value: function computeDegreeOfMembership(value) {\n      this._updateCache();\n\n      if (value >= this.right || value <= this.left) return 0;\n      return probabilityDensity(value, this.midpoint, this._cache.variance) / this._cache.normalizationFactor;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(NormalDistFuzzySet.prototype), \"toJSON\", this).call(this);\n\n      json.midpoint = this.midpoint;\n      json.standardDeviation = this.standardDeviation;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {NormalDistFuzzySet} A reference to this fuzzy set.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(NormalDistFuzzySet.prototype), \"fromJSON\", this).call(this, json);\n\n      this.midpoint = json.midpoint;\n      this.standardDeviation = json.standardDeviation;\n      return this;\n    } //\n\n  }, {\n    key: \"_updateCache\",\n    value: function _updateCache() {\n      var cache = this._cache;\n      var midpoint = this.midpoint;\n      var standardDeviation = this.standardDeviation;\n\n      if (midpoint !== cache.midpoint || standardDeviation !== cache.standardDeviation) {\n        var variance = standardDeviation * standardDeviation;\n        cache.midpoint = midpoint;\n        cache.standardDeviation = standardDeviation;\n        cache.variance = variance; // this value is used to ensure the DOM lies in the range of [0,1]\n\n        cache.normalizationFactor = probabilityDensity(midpoint, midpoint, variance);\n      }\n\n      return this;\n    }\n  }]);\n\n  return NormalDistFuzzySet;\n}(FuzzySet); //\n\n\nfunction probabilityDensity(x, mean, variance) {\n  return 1 / Math.sqrt(2 * Math.PI * variance) * Math.exp(-Math.pow(x - mean, 2) / (2 * variance));\n}\n/**\r\n* Class for representing a fuzzy set that has a s-shape membership function with\r\n* values from lowest to highest.\r\n*\r\n* @author {@link https://github.com/robp94|robp94}\r\n* @augments FuzzySet\r\n*/\n\n\nvar RightSCurveFuzzySet =\n/*#__PURE__*/\nfunction (_FuzzySet4) {\n  _inherits(RightSCurveFuzzySet, _FuzzySet4);\n\n  /**\r\n  * Constructs a new S-curve fuzzy set with the given values.\r\n  *\r\n  * @param {Number} left - Represents the left border of this fuzzy set.\r\n  * @param {Number} midpoint - Represents the peak value of this fuzzy set.\r\n  * @param {Number} right - Represents the right border of this fuzzy set.\r\n  */\n  function RightSCurveFuzzySet() {\n    var _this21;\n\n    var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var midpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var right = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, RightSCurveFuzzySet);\n\n    // the representative value is the midpoint of the plateau of the shoulder\n    var representativeValue = (midpoint + right) / 2;\n    _this21 = _possibleConstructorReturn(this, _getPrototypeOf(RightSCurveFuzzySet).call(this, representativeValue));\n    /**\r\n    * Represents the left border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this21.left = left;\n    /**\r\n    * Represents the peak value of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this21.midpoint = midpoint;\n    /**\r\n    * Represents the right border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this21.right = right;\n    return _this21;\n  }\n  /**\r\n  * Computes the degree of membership for the given value.\r\n  *\r\n  * @param {Number} value - The value used to calculate the degree of membership.\r\n  * @return {Number} The degree of membership.\r\n  */\n\n\n  _createClass(RightSCurveFuzzySet, [{\n    key: \"computeDegreeOfMembership\",\n    value: function computeDegreeOfMembership(value) {\n      var midpoint = this.midpoint;\n      var left = this.left;\n      var right = this.right; // find DOM if the given value is left of the center or equal to the center\n\n      if (value >= left && value <= midpoint) {\n        if (value <= (left + midpoint) / 2) {\n          return 2 * Math.pow((value - left) / (midpoint - left), 2);\n        } else {\n          return 1 - 2 * Math.pow((value - midpoint) / (midpoint - left), 2);\n        }\n      } // find DOM if the given value is right of the midpoint\n\n\n      if (value > midpoint && value <= right) {\n        return 1;\n      } // out of range\n\n\n      return 0;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(RightSCurveFuzzySet.prototype), \"toJSON\", this).call(this);\n\n      json.midpoint = this.midpoint;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {RightSCurveFuzzySet} A reference to this fuzzy set.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(RightSCurveFuzzySet.prototype), \"fromJSON\", this).call(this, json);\n\n      this.midpoint = json.midpoint;\n      return this;\n    }\n  }]);\n\n  return RightSCurveFuzzySet;\n}(FuzzySet);\n/**\r\n* Class for representing a fuzzy set that has a right shoulder shape. The range between\r\n* the midpoint and right border point represents the same DOM.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments FuzzySet\r\n*/\n\n\nvar RightShoulderFuzzySet =\n/*#__PURE__*/\nfunction (_FuzzySet5) {\n  _inherits(RightShoulderFuzzySet, _FuzzySet5);\n\n  /**\r\n  * Constructs a new right shoulder fuzzy set with the given values.\r\n  *\r\n  * @param {Number} left - Represents the left border of this fuzzy set.\r\n  * @param {Number} midpoint - Represents the peak value of this fuzzy set.\r\n  * @param {Number} right - Represents the right border of this fuzzy set.\r\n  */\n  function RightShoulderFuzzySet() {\n    var _this22;\n\n    var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var midpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var right = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, RightShoulderFuzzySet);\n\n    // the representative value is the midpoint of the plateau of the shoulder\n    var representativeValue = (midpoint + right) / 2;\n    _this22 = _possibleConstructorReturn(this, _getPrototypeOf(RightShoulderFuzzySet).call(this, representativeValue));\n    /**\r\n    * Represents the left border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this22.left = left;\n    /**\r\n    * Represents the peak value of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this22.midpoint = midpoint;\n    /**\r\n    * Represents the right border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this22.right = right;\n    return _this22;\n  }\n  /**\r\n  * Computes the degree of membership for the given value.\r\n  *\r\n  * @param {Number} value - The value used to calculate the degree of membership.\r\n  * @return {Number} The degree of membership.\r\n  */\n\n\n  _createClass(RightShoulderFuzzySet, [{\n    key: \"computeDegreeOfMembership\",\n    value: function computeDegreeOfMembership(value) {\n      var midpoint = this.midpoint;\n      var left = this.left;\n      var right = this.right; // find DOM if the given value is left of the center or equal to the center\n\n      if (value >= left && value <= midpoint) {\n        var grad = 1 / (midpoint - left);\n        return grad * (value - left);\n      } // find DOM if the given value is right of the midpoint\n\n\n      if (value > midpoint && value <= right) {\n        return 1;\n      } // out of range\n\n\n      return 0;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(RightShoulderFuzzySet.prototype), \"toJSON\", this).call(this);\n\n      json.midpoint = this.midpoint;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {RightShoulderFuzzySet} A reference to this fuzzy set.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(RightShoulderFuzzySet.prototype), \"fromJSON\", this).call(this, json);\n\n      this.midpoint = json.midpoint;\n      return this;\n    }\n  }]);\n\n  return RightShoulderFuzzySet;\n}(FuzzySet);\n/**\r\n* Class for representing a fuzzy set that is a singleton. In its range, the degree of\r\n* membership is always one.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments FuzzySet\r\n*/\n\n\nvar SingletonFuzzySet =\n/*#__PURE__*/\nfunction (_FuzzySet6) {\n  _inherits(SingletonFuzzySet, _FuzzySet6);\n\n  /**\r\n  * Constructs a new singleton fuzzy set with the given values.\r\n  *\r\n  * @param {Number} left - Represents the left border of this fuzzy set.\r\n  * @param {Number} midpoint - Represents the peak value of this fuzzy set.\r\n  * @param {Number} right - Represents the right border of this fuzzy set.\r\n  */\n  function SingletonFuzzySet() {\n    var _this23;\n\n    var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var midpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var right = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, SingletonFuzzySet);\n\n    _this23 = _possibleConstructorReturn(this, _getPrototypeOf(SingletonFuzzySet).call(this, midpoint));\n    /**\r\n    * Represents the left border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this23.left = left;\n    /**\r\n    * Represents the peak value of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this23.midpoint = midpoint;\n    /**\r\n    * Represents the right border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this23.right = right;\n    return _this23;\n  }\n  /**\r\n  * Computes the degree of membership for the given value.\r\n  *\r\n  * @param {Number} value - The value used to calculate the degree of membership.\r\n  * @return {Number} The degree of membership.\r\n  */\n\n\n  _createClass(SingletonFuzzySet, [{\n    key: \"computeDegreeOfMembership\",\n    value: function computeDegreeOfMembership(value) {\n      var left = this.left;\n      var right = this.right;\n      return value >= left && value <= right ? 1 : 0;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(SingletonFuzzySet.prototype), \"toJSON\", this).call(this);\n\n      json.midpoint = this.midpoint;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {SingletonFuzzySet} A reference to this fuzzy set.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(SingletonFuzzySet.prototype), \"fromJSON\", this).call(this, json);\n\n      this.midpoint = json.midpoint;\n      return this;\n    }\n  }]);\n\n  return SingletonFuzzySet;\n}(FuzzySet);\n/**\r\n* Class for representing a fuzzy set that has a triangular shape. It can be defined\r\n* by a left point, a midpoint (peak) and a right point.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments FuzzySet\r\n*/\n\n\nvar TriangularFuzzySet =\n/*#__PURE__*/\nfunction (_FuzzySet7) {\n  _inherits(TriangularFuzzySet, _FuzzySet7);\n\n  /**\r\n  * Constructs a new triangular fuzzy set with the given values.\r\n  *\r\n  * @param {Number} left - Represents the left border of this fuzzy set.\r\n  * @param {Number} midpoint - Represents the peak value of this fuzzy set.\r\n  * @param {Number} right - Represents the right border of this fuzzy set.\r\n  */\n  function TriangularFuzzySet() {\n    var _this24;\n\n    var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var midpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var right = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, TriangularFuzzySet);\n\n    _this24 = _possibleConstructorReturn(this, _getPrototypeOf(TriangularFuzzySet).call(this, midpoint));\n    /**\r\n    * Represents the left border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this24.left = left;\n    /**\r\n    * Represents the peak value of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this24.midpoint = midpoint;\n    /**\r\n    * Represents the right border of this fuzzy set.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    _this24.right = right;\n    return _this24;\n  }\n  /**\r\n  * Computes the degree of membership for the given value.\r\n  *\r\n  * @param {Number} value - The value used to calculate the degree of membership.\r\n  * @return {Number} The degree of membership.\r\n  */\n\n\n  _createClass(TriangularFuzzySet, [{\n    key: \"computeDegreeOfMembership\",\n    value: function computeDegreeOfMembership(value) {\n      var midpoint = this.midpoint;\n      var left = this.left;\n      var right = this.right; // find DOM if the given value is left of the center or equal to the center\n\n      if (value >= left && value <= midpoint) {\n        var grad = 1 / (midpoint - left);\n        return grad * (value - left);\n      } // find DOM if the given value is right of the center\n\n\n      if (value > midpoint && value <= right) {\n        var _grad = 1 / (right - midpoint);\n\n        return _grad * (right - value);\n      } // out of range\n\n\n      return 0;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(TriangularFuzzySet.prototype), \"toJSON\", this).call(this);\n\n      json.midpoint = this.midpoint;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {TriangularFuzzySet} A reference to this fuzzy set.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(TriangularFuzzySet.prototype), \"fromJSON\", this).call(this, json);\n\n      this.midpoint = json.midpoint;\n      return this;\n    }\n  }]);\n\n  return TriangularFuzzySet;\n}(FuzzySet);\n/**\r\n* Class for representing a fuzzy rule. Fuzzy rules are comprised of an antecedent and\r\n* a consequent in the form: IF antecedent THEN consequent.\r\n*\r\n* Compared to ordinary if/else statements with discrete values, the consequent term\r\n* of a fuzzy rule can fire to a matter of degree.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar FuzzyRule =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new fuzzy rule with the given values.\r\n  *\r\n  * @param {FuzzyTerm} antecedent - Represents the condition of the rule.\r\n  * @param {FuzzyTerm} consequence - Describes the consequence if the condition is satisfied.\r\n  */\n  function FuzzyRule() {\n    var antecedent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var consequence = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, FuzzyRule);\n\n    /**\r\n    * Represents the condition of the rule.\r\n    * @type FuzzyTerm\r\n    * @default null\r\n    */\n    this.antecedent = antecedent;\n    /**\r\n    * Describes the consequence if the condition is satisfied.\r\n    * @type FuzzyTerm\r\n    * @default null\r\n    */\n\n    this.consequence = consequence;\n  }\n  /**\r\n  * Initializes the consequent term of this fuzzy rule.\r\n  *\r\n  * @return {FuzzyRule} A reference to this fuzzy rule.\r\n  */\n\n\n  _createClass(FuzzyRule, [{\n    key: \"initConsequence\",\n    value: function initConsequence() {\n      this.consequence.clearDegreeOfMembership();\n      return this;\n    }\n    /**\r\n    * Evaluates the rule and updates the degree of membership of the consequent term with\r\n    * the degree of membership of the antecedent term.\r\n    *\r\n    * @return {FuzzyRule} A reference to this fuzzy rule.\r\n    */\n\n  }, {\n    key: \"evaluate\",\n    value: function evaluate() {\n      this.consequence.updateDegreeOfMembership(this.antecedent.getDegreeOfMembership());\n      return this;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {};\n      var antecedent = this.antecedent;\n      var consequence = this.consequence;\n      json.type = this.constructor.name;\n      json.antecedent = antecedent instanceof FuzzyCompositeTerm ? antecedent.toJSON() : antecedent.uuid;\n      json.consequence = consequence instanceof FuzzyCompositeTerm ? consequence.toJSON() : consequence.uuid;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @param {Map} fuzzySets - Maps fuzzy sets to UUIDs.\r\n    * @return {FuzzyRule} A reference to this fuzzy rule.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json, fuzzySets) {\n      function parseTerm(termJSON) {\n        if (typeof termJSON === 'string') {\n          // atomic term -> FuzzySet\n          var uuid = termJSON;\n          return fuzzySets.get(uuid) || null;\n        } else {\n          // composite term\n          var type = termJSON.type;\n          var term;\n\n          switch (type) {\n            case 'FuzzyAND':\n              term = new FuzzyAND();\n              break;\n\n            case 'FuzzyOR':\n              term = new FuzzyOR();\n              break;\n\n            case 'FuzzyVERY':\n              term = new FuzzyVERY();\n              break;\n\n            case 'FuzzyFAIRLY':\n              term = new FuzzyFAIRLY();\n              break;\n\n            default:\n              Logger.error('YUKA.FuzzyRule: Unsupported operator type:', type);\n              return;\n          }\n\n          var termsJSON = termJSON.terms;\n\n          for (var _i52 = 0, l = termsJSON.length; _i52 < l; _i52++) {\n            // recursively parse all subordinate terms\n            term.terms.push(parseTerm(termsJSON[_i52]));\n          }\n\n          return term;\n        }\n      }\n\n      this.antecedent = parseTerm(json.antecedent);\n      this.consequence = parseTerm(json.consequence);\n      return this;\n    }\n  }]);\n\n  return FuzzyRule;\n}();\n/**\r\n* Class for representing a fuzzy linguistic variable (FLV). A FLV is the\r\n* composition of one or more fuzzy sets to represent a concept or domain\r\n* qualitatively. For example fuzzs sets \"Dumb\", \"Average\", and \"Clever\"\r\n* are members of the fuzzy linguistic variable \"IQ\".\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar FuzzyVariable =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new fuzzy linguistic variable.\r\n  */\n  function FuzzyVariable() {\n    _classCallCheck(this, FuzzyVariable);\n\n    /**\r\n    * An array of the fuzzy sets that comprise this FLV.\r\n    * @type Array\r\n    */\n    this.fuzzySets = new Array();\n    /**\r\n    * The minimum value range of this FLV. This value is\r\n    * automatically updated when adding/removing fuzzy sets.\r\n    * @type Number\r\n    * @default Infinity\r\n    */\n\n    this.minRange = Infinity;\n    /**\r\n    * The maximum value range of this FLV. This value is\r\n    * automatically updated when adding/removing fuzzy sets.\r\n    * @type Number\r\n    * @default - Infinity\r\n    */\n\n    this.maxRange = -Infinity;\n  }\n  /**\r\n  * Adds the given fuzzy set to this FLV.\r\n  *\r\n  * @param {FuzzySet} fuzzySet - The fuzzy set to add.\r\n  * @return {FuzzyVariable} A reference to this FLV.\r\n  */\n\n\n  _createClass(FuzzyVariable, [{\n    key: \"add\",\n    value: function add(fuzzySet) {\n      this.fuzzySets.push(fuzzySet); // adjust range\n\n      if (fuzzySet.left < this.minRange) this.minRange = fuzzySet.left;\n      if (fuzzySet.right > this.maxRange) this.maxRange = fuzzySet.right;\n      return this;\n    }\n    /**\r\n    * Removes the given fuzzy set from this FLV.\r\n    *\r\n    * @param {FuzzySet} fuzzySet - The fuzzy set to remove.\r\n    * @return {FuzzyVariable} A reference to this FLV.\r\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove(fuzzySet) {\n      var fuzzySets = this.fuzzySets;\n      var index = fuzzySets.indexOf(fuzzySet);\n      fuzzySets.splice(index, 1); // iterate over all fuzzy sets to recalculate the min/max range\n\n      this.minRange = Infinity;\n      this.maxRange = -Infinity;\n\n      for (var _i53 = 0, l = fuzzySets.length; _i53 < l; _i53++) {\n        var _fuzzySet = fuzzySets[_i53];\n        if (_fuzzySet.left < this.minRange) this.minRange = _fuzzySet.left;\n        if (_fuzzySet.right > this.maxRange) this.maxRange = _fuzzySet.right;\n      }\n\n      return this;\n    }\n    /**\r\n    * Fuzzifies a value by calculating its degree of membership in each of\r\n    * this variable's fuzzy sets.\r\n    *\r\n    * @param {Number} value - The crips value to fuzzify.\r\n    * @return {FuzzyVariable} A reference to this FLV.\r\n    */\n\n  }, {\n    key: \"fuzzify\",\n    value: function fuzzify(value) {\n      if (value < this.minRange || value > this.maxRange) {\n        Logger.warn('YUKA.FuzzyVariable: Value for fuzzification out of range.');\n        return;\n      }\n\n      var fuzzySets = this.fuzzySets;\n\n      for (var _i54 = 0, l = fuzzySets.length; _i54 < l; _i54++) {\n        var fuzzySet = fuzzySets[_i54];\n        fuzzySet.degreeOfMembership = fuzzySet.computeDegreeOfMembership(value);\n      }\n\n      return this;\n    }\n    /**\r\n    * Defuzzifies the FLV using the \"Average of Maxima\" (MaxAv) method.\r\n    *\r\n    * @return {Number} The defuzzified, crips value.\r\n    */\n\n  }, {\n    key: \"defuzzifyMaxAv\",\n    value: function defuzzifyMaxAv() {\n      // the average of maxima (MaxAv for short) defuzzification method scales the\n      // representative value of each fuzzy set by its DOM and takes the average\n      var fuzzySets = this.fuzzySets;\n      var bottom = 0;\n      var top = 0;\n\n      for (var _i55 = 0, l = fuzzySets.length; _i55 < l; _i55++) {\n        var fuzzySet = fuzzySets[_i55];\n        bottom += fuzzySet.degreeOfMembership;\n        top += fuzzySet.representativeValue * fuzzySet.degreeOfMembership;\n      }\n\n      return bottom === 0 ? 0 : top / bottom;\n    }\n    /**\r\n    * Defuzzifies the FLV using the \"Centroid\" method.\r\n    *\r\n    * @param {Number} samples - The amount of samples used for defuzzification.\r\n    * @return {Number} The defuzzified, crips value.\r\n    */\n\n  }, {\n    key: \"defuzzifyCentroid\",\n    value: function defuzzifyCentroid() {\n      var samples = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n      var fuzzySets = this.fuzzySets;\n      var stepSize = (this.maxRange - this.minRange) / samples;\n      var totalArea = 0;\n      var sumOfMoments = 0;\n\n      for (var s = 1; s <= samples; s++) {\n        var sample = this.minRange + s * stepSize;\n\n        for (var _i56 = 0, l = fuzzySets.length; _i56 < l; _i56++) {\n          var fuzzySet = fuzzySets[_i56];\n          var contribution = Math.min(fuzzySet.degreeOfMembership, fuzzySet.computeDegreeOfMembership(sample));\n          totalArea += contribution;\n          sumOfMoments += sample * contribution;\n        }\n      }\n\n      return totalArea === 0 ? 0 : sumOfMoments / totalArea;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        type: this.constructor.name,\n        fuzzySets: new Array(),\n        minRange: this.minRange.toString(),\n        maxRange: this.maxRange.toString()\n      };\n\n      for (var _i57 = 0, l = this.fuzzySets.length; _i57 < l; _i57++) {\n        var fuzzySet = this.fuzzySets[_i57];\n        json.fuzzySets.push(fuzzySet.toJSON());\n      }\n\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {FuzzyVariable} A reference to this fuzzy variable.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.minRange = parseFloat(json.minRange);\n      this.maxRange = parseFloat(json.maxRange);\n\n      for (var _i58 = 0, l = json.fuzzySets.length; _i58 < l; _i58++) {\n        var fuzzySetJson = json.fuzzySets[_i58];\n        var type = fuzzySetJson.type;\n\n        switch (type) {\n          case 'LeftShoulderFuzzySet':\n            this.fuzzySets.push(new LeftShoulderFuzzySet().fromJSON(fuzzySetJson));\n            break;\n\n          case 'RightShoulderFuzzySet':\n            this.fuzzySets.push(new RightShoulderFuzzySet().fromJSON(fuzzySetJson));\n            break;\n\n          case 'SingletonFuzzySet':\n            this.fuzzySets.push(new SingletonFuzzySet().fromJSON(fuzzySetJson));\n            break;\n\n          case 'TriangularFuzzySet':\n            this.fuzzySets.push(new TriangularFuzzySet().fromJSON(fuzzySetJson));\n            break;\n\n          default:\n            Logger.error('YUKA.FuzzyVariable: Unsupported fuzzy set type:', fuzzySetJson.type);\n        }\n      }\n\n      return this;\n    }\n  }]);\n\n  return FuzzyVariable;\n}();\n/**\r\n* Class for representing a fuzzy module. Instances of this class are used by\r\n* game entities for fuzzy inference. A fuzzy module is a collection of fuzzy variables\r\n* and the rules that operate on them.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar FuzzyModule =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new fuzzy module.\r\n  */\n  function FuzzyModule() {\n    _classCallCheck(this, FuzzyModule);\n\n    /**\r\n    * An array of the fuzzy rules.\r\n    * @type Array\r\n    */\n    this.rules = new Array();\n    /**\r\n    * A map of FLVs.\r\n    * @type Map\r\n    */\n\n    this.flvs = new Map();\n  }\n  /**\r\n  * Adds the given FLV under the given name to this fuzzy module.\r\n  *\r\n  * @param {String} name - The name of the FLV.\r\n  * @param {FuzzyVariable} flv - The FLV to add.\r\n  * @return {FuzzyModule} A reference to this fuzzy module.\r\n  */\n\n\n  _createClass(FuzzyModule, [{\n    key: \"addFLV\",\n    value: function addFLV(name, flv) {\n      this.flvs.set(name, flv);\n      return this;\n    }\n    /**\r\n    * Remove the FLV under the given name from this fuzzy module.\r\n    *\r\n    * @param {String} name - The name of the FLV to remove.\r\n    * @return {FuzzyModule} A reference to this fuzzy module.\r\n    */\n\n  }, {\n    key: \"removeFLV\",\n    value: function removeFLV(name) {\n      this.flvs.delete(name);\n      return this;\n    }\n    /**\r\n    * Adds the given fuzzy rule to this fuzzy module.\r\n    *\r\n    * @param {FuzzyRule} rule - The fuzzy rule to add.\r\n    * @return {FuzzyModule} A reference to this fuzzy module.\r\n    */\n\n  }, {\n    key: \"addRule\",\n    value: function addRule(rule) {\n      this.rules.push(rule);\n      return this;\n    }\n    /**\r\n    * Removes the given fuzzy rule from this fuzzy module.\r\n    *\r\n    * @param {FuzzyRule} rule - The fuzzy rule to remove.\r\n    * @return {FuzzyModule} A reference to this fuzzy module.\r\n    */\n\n  }, {\n    key: \"removeRule\",\n    value: function removeRule(rule) {\n      var rules = this.rules;\n      var index = rules.indexOf(rule);\n      rules.splice(index, 1);\n      return this;\n    }\n    /**\r\n    * Calls the fuzzify method of the defined FLV with the given value.\r\n    *\r\n    * @param {String} name - The name of the FLV\r\n    * @param {Number} value - The crips value to fuzzify.\r\n    * @return {FuzzyModule} A reference to this fuzzy module.\r\n    */\n\n  }, {\n    key: \"fuzzify\",\n    value: function fuzzify(name, value) {\n      var flv = this.flvs.get(name);\n      flv.fuzzify(value);\n      return this;\n    }\n    /**\r\n    * Given a fuzzy variable and a defuzzification method this returns a crisp value.\r\n    *\r\n    * @param {String} name - The name of the FLV\r\n    * @param {String} type - The type of defuzzification.\r\n    * @return {Number} The defuzzified, crips value.\r\n    */\n\n  }, {\n    key: \"defuzzify\",\n    value: function defuzzify(name) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FuzzyModule.DEFUZ_TYPE.MAXAV;\n      var flvs = this.flvs;\n      var rules = this.rules;\n\n      this._initConsequences();\n\n      for (var _i59 = 0, l = rules.length; _i59 < l; _i59++) {\n        var rule = rules[_i59];\n        rule.evaluate();\n      }\n\n      var flv = flvs.get(name);\n      var value;\n\n      switch (type) {\n        case FuzzyModule.DEFUZ_TYPE.MAXAV:\n          value = flv.defuzzifyMaxAv();\n          break;\n\n        case FuzzyModule.DEFUZ_TYPE.CENTROID:\n          value = flv.defuzzifyCentroid();\n          break;\n\n        default:\n          Logger.warn('YUKA.FuzzyModule: Unknown defuzzification method:', type);\n          value = flv.defuzzifyMaxAv();\n        // use MaxAv as fallback\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_initConsequences\",\n    value: function _initConsequences() {\n      var rules = this.rules; // initializes the consequences of all rules.\n\n      for (var _i60 = 0, l = rules.length; _i60 < l; _i60++) {\n        var rule = rules[_i60];\n        rule.initConsequence();\n      }\n\n      return this;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        rules: new Array(),\n        flvs: new Array()\n      }; // rules\n\n      var rules = this.rules;\n\n      for (var _i61 = 0, l = rules.length; _i61 < l; _i61++) {\n        json.rules.push(rules[_i61].toJSON());\n      } // flvs\n\n\n      var flvs = this.flvs;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = flvs[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              name = _step4$value[0],\n              flv = _step4$value[1];\n\n          json.flvs.push({\n            name: name,\n            flv: flv.toJSON()\n          });\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {FuzzyModule} A reference to this fuzzy module.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var fuzzySets = new Map(); // used for rules\n      // flvs\n\n      var flvsJSON = json.flvs;\n\n      for (var _i62 = 0, l = flvsJSON.length; _i62 < l; _i62++) {\n        var flvJSON = flvsJSON[_i62];\n        var name = flvJSON.name;\n        var flv = new FuzzyVariable().fromJSON(flvJSON.flv);\n        this.addFLV(name, flv);\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = flv.fuzzySets[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var fuzzySet = _step5.value;\n            fuzzySets.set(fuzzySet.uuid, fuzzySet);\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      } // rules\n\n\n      var rulesJSON = json.rules;\n\n      for (var _i63 = 0, _l5 = rulesJSON.length; _i63 < _l5; _i63++) {\n        var ruleJSON = rulesJSON[_i63];\n        var rule = new FuzzyRule().fromJSON(ruleJSON, fuzzySets);\n        this.addRule(rule);\n      }\n\n      return this;\n    }\n  }]);\n\n  return FuzzyModule;\n}();\n\nFuzzyModule.DEFUZ_TYPE = Object.freeze({\n  MAXAV: 0,\n  CENTROID: 1\n});\n/**\r\n* Base class for representing a goal in context of Goal-driven agent design.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar Goal =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new goal.\r\n  *\r\n  * @param {GameEntity} owner - The owner of this goal.\r\n  */\n  function Goal() {\n    var owner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, Goal);\n\n    /**\r\n    * The owner of this goal.\r\n    * @type GameEntity\r\n    */\n    this.owner = owner;\n    /**\r\n    * The status of this goal.\r\n    * @type Status\r\n    * @default INACTIVE\r\n    */\n\n    this.status = Goal.STATUS.INACTIVE;\n  }\n  /**\r\n  * Executed when this goal is activated.\r\n  */\n\n\n  _createClass(Goal, [{\n    key: \"activate\",\n    value: function activate() {}\n    /**\r\n    * Executed in each simulation step.\r\n    */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {}\n    /**\r\n    * Executed when this goal is satisfied.\r\n    */\n\n  }, {\n    key: \"terminate\",\n    value: function terminate() {}\n    /**\r\n    * Goals can handle messages. Many don't though, so this defines a default behavior\r\n    *\r\n    * @param {Telegram} telegram - The telegram with the message data.\r\n    * @return {Boolean} Whether the message was processed or not.\r\n    */\n\n  }, {\n    key: \"handleMessage\",\n    value: function handleMessage()\n    /* telegram */\n    {\n      return false;\n    }\n    /**\r\n    * Returns true if the status of this goal is *ACTIVE*.\r\n    *\r\n    * @return {Boolean} Whether the goal is active or not.\r\n    */\n\n  }, {\n    key: \"active\",\n    value: function active() {\n      return this.status === Goal.STATUS.ACTIVE;\n    }\n    /**\r\n    * Returns true if the status of this goal is *INACTIVE*.\r\n    *\r\n    * @return {Boolean} Whether the goal is inactive or not.\r\n    */\n\n  }, {\n    key: \"inactive\",\n    value: function inactive() {\n      return this.status === Goal.STATUS.INACTIVE;\n    }\n    /**\r\n    * Returns true if the status of this goal is *COMPLETED*.\r\n    *\r\n    * @return {Boolean} Whether the goal is completed or not.\r\n    */\n\n  }, {\n    key: \"completed\",\n    value: function completed() {\n      return this.status === Goal.STATUS.COMPLETED;\n    }\n    /**\r\n    * Returns true if the status of this goal is *FAILED*.\r\n    *\r\n    * @return {Boolean} Whether the goal is failed or not.\r\n    */\n\n  }, {\n    key: \"failed\",\n    value: function failed() {\n      return this.status === Goal.STATUS.FAILED;\n    }\n    /**\r\n    * Ensures the goal is replanned if it has failed.\r\n    *\r\n    * @return {Goal} A reference to this goal.\r\n    */\n\n  }, {\n    key: \"replanIfFailed\",\n    value: function replanIfFailed() {\n      if (this.failed() === true) {\n        this.status = Goal.STATUS.INACTIVE;\n      }\n\n      return this;\n    }\n    /**\r\n    * Ensures the goal is activated if it is inactive.\r\n    *\r\n    * @return {Goal} A reference to this goal.\r\n    */\n\n  }, {\n    key: \"activateIfInactive\",\n    value: function activateIfInactive() {\n      if (this.inactive() === true) {\n        this.status = Goal.STATUS.ACTIVE;\n        this.activate();\n      }\n\n      return this;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.constructor.name,\n        owner: this.owner.uuid,\n        status: this.status\n      };\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {Goal} A reference to this goal.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.owner = json.owner; // uuid\n\n      this.status = json.status;\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {Goal} A reference to this goal.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      this.owner = entities.get(this.owner) || null;\n      return this;\n    }\n  }]);\n\n  return Goal;\n}();\n\nGoal.STATUS = Object.freeze({\n  ACTIVE: 'active',\n  // the goal has been activated and will be processed each update step\n  INACTIVE: 'inactive',\n  // the goal is waiting to be activated\n  COMPLETED: 'completed',\n  // the goal has completed and will be removed on the next update\n  FAILED: 'failed' // the goal has failed and will either replan or be removed on the next update\n\n});\n/**\r\n* Class representing a composite goal. Essentially it's a goal which consists of subgoals.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments Goal\r\n*/\n\nvar CompositeGoal =\n/*#__PURE__*/\nfunction (_Goal) {\n  _inherits(CompositeGoal, _Goal);\n\n  /**\r\n  * Constructs a new composite goal.\r\n  *\r\n  * @param {GameEntity} owner - The owner of this composite goal.\r\n  */\n  function CompositeGoal() {\n    var _this25;\n\n    var owner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, CompositeGoal);\n\n    _this25 = _possibleConstructorReturn(this, _getPrototypeOf(CompositeGoal).call(this, owner));\n    /**\r\n    * A list of subgoals.\r\n    * @type Array\r\n    */\n\n    _this25.subgoals = new Array();\n    return _this25;\n  }\n  /**\r\n  * Adds a goal as a subgoal to this instance.\r\n  *\r\n  * @param {Goal} goal - The subgoal to add.\r\n  * @return {Goal} A reference to this goal.\r\n  */\n\n\n  _createClass(CompositeGoal, [{\n    key: \"addSubgoal\",\n    value: function addSubgoal(goal) {\n      this.subgoals.unshift(goal);\n      return this;\n    }\n    /**\r\n    * Removes a subgoal from this instance.\r\n    *\r\n    * @param {Goal} goal - The subgoal to remove.\r\n    * @return {Goal} A reference to this goal.\r\n    */\n\n  }, {\n    key: \"removeSubgoal\",\n    value: function removeSubgoal(goal) {\n      var index = this.subgoals.indexOf(goal);\n      this.subgoals.splice(index, 1);\n      return this;\n    }\n    /**\r\n    * Removes all subgoals and ensures {@link Goal#terminate} is called\r\n    * for each subgoal.\r\n    *\r\n    * @return {Goal} A reference to this goal.\r\n    */\n\n  }, {\n    key: \"clearSubgoals\",\n    value: function clearSubgoals() {\n      var subgoals = this.subgoals;\n\n      for (var _i64 = 0, l = subgoals.length; _i64 < l; _i64++) {\n        var subgoal = subgoals[_i64];\n        subgoal.terminate();\n      }\n\n      subgoals.length = 0;\n      return this;\n    }\n    /**\r\n    * Returns the current subgoal. If no subgoals are defined, *null* is returned.\r\n    *\r\n    * @return {Goal} The current subgoal.\r\n    */\n\n  }, {\n    key: \"currentSubgoal\",\n    value: function currentSubgoal() {\n      var length = this.subgoals.length;\n\n      if (length > 0) {\n        return this.subgoals[length - 1];\n      } else {\n        return null;\n      }\n    }\n    /**\r\n    * Executes the current subgoal of this composite goal.\r\n    *\r\n    * @return {Status} The status of this composite subgoal.\r\n    */\n\n  }, {\n    key: \"executeSubgoals\",\n    value: function executeSubgoals() {\n      var subgoals = this.subgoals; // remove all completed and failed goals from the back of the subgoal list\n\n      for (var _i65 = subgoals.length - 1; _i65 >= 0; _i65--) {\n        var _subgoal = subgoals[_i65];\n\n        if (_subgoal.completed() === true || _subgoal.failed() === true) {\n          // if the current subgoal is a composite goal, terminate its subgoals too\n          if (_subgoal instanceof CompositeGoal) {\n            _subgoal.clearSubgoals();\n          } // terminate the subgoal itself\n\n\n          _subgoal.terminate();\n\n          subgoals.pop();\n        } else {\n          break;\n        }\n      } // if any subgoals remain, process the one at the back of the list\n\n\n      var subgoal = this.currentSubgoal();\n\n      if (subgoal !== null) {\n        subgoal.activateIfInactive();\n        subgoal.execute(); // if subgoal is completed but more subgoals are in the list, return 'ACTIVE'\n        // status in order to keep processing the list of subgoals\n\n        if (subgoal.completed() === true && subgoals.length > 1) {\n          return Goal.STATUS.ACTIVE;\n        } else {\n          return subgoal.status;\n        }\n      } else {\n        return Goal.STATUS.COMPLETED;\n      }\n    }\n    /**\r\n    * Returns true if this composite goal has subgoals.\r\n    *\r\n    * @return {Boolean} Whether the composite goal has subgoals or not.\r\n    */\n\n  }, {\n    key: \"hasSubgoals\",\n    value: function hasSubgoals() {\n      return this.subgoals.length > 0;\n    }\n    /**\r\n    * Returns true if the given message was processed by the current subgoal.\r\n    *\r\n    * @return {Boolean} Whether the message was processed or not.\r\n    */\n\n  }, {\n    key: \"handleMessage\",\n    value: function handleMessage(telegram) {\n      var subgoal = this.currentSubgoal();\n\n      if (subgoal !== null) {\n        return subgoal.handleMessage(telegram);\n      }\n\n      return false;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(CompositeGoal.prototype), \"toJSON\", this).call(this);\n\n      json.subgoals = new Array();\n\n      for (var _i66 = 0, l = this.subgoals.length; _i66 < l; _i66++) {\n        var subgoal = this.subgoals[_i66];\n        json.subgoals.push(subgoal.toJSON());\n      }\n\n      return json;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {CompositeGoal} A reference to this composite goal.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      _get(_getPrototypeOf(CompositeGoal.prototype), \"resolveReferences\", this).call(this, entities);\n\n      for (var _i67 = 0, l = this.subgoals.length; _i67 < l; _i67++) {\n        var subgoal = this.subgoals[_i67];\n        subgoal.resolveReferences(entities);\n      }\n\n      return this;\n    }\n  }]);\n\n  return CompositeGoal;\n}(Goal);\n/**\r\n* Base class for representing a goal evaluator in context of Goal-driven agent design.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar GoalEvaluator =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new goal evaluator.\r\n  *\r\n  * @param {Number} characterBias - Can be used to adjust the preferences of agents.\r\n  */\n  function GoalEvaluator() {\n    var characterBias = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n    _classCallCheck(this, GoalEvaluator);\n\n    /**\r\n    * Can be used to adjust the preferences of agents. When the desirability score\r\n    * for a goal has been evaluated, it is multiplied by this value.\r\n    * @type Number\r\n    * @default 1\r\n    */\n    this.characterBias = characterBias;\n  }\n  /**\r\n  * Calculates the desirability. It's a score between 0 and 1 representing the desirability\r\n  * of a goal. This goal is considered as a top level strategy of the agent like *Explore* or\r\n  * *AttackTarget*. Must be implemented by all concrete goal evaluators.\r\n  *\r\n  * @param {GameEntity} owner - The owner of this goal evaluator.\r\n  * @return {Number} The desirability.\r\n  */\n\n\n  _createClass(GoalEvaluator, [{\n    key: \"calculateDesirability\",\n    value: function calculateDesirability()\n    /* owner */\n    {\n      return 0;\n    }\n    /**\r\n    * Executed if this goal evaluator produces the highest desirability. Must be implemented\r\n    * by all concrete goal evaluators.\r\n    *\r\n    * @param {GameEntity} owner - The owner of this goal evaluator.\r\n    */\n\n  }, {\n    key: \"setGoal\",\n    value: function setGoal()\n    /* owner */\n    {}\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.constructor.name,\n        characterBias: this.characterBias\n      };\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {GoalEvaluator} A reference to this goal evaluator.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.characterBias = json.characterBias;\n      return this;\n    }\n  }]);\n\n  return GoalEvaluator;\n}();\n/**\r\n* Class for representing the brain of a game entity.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments CompositeGoal\r\n*/\n\n\nvar Think =\n/*#__PURE__*/\nfunction (_CompositeGoal) {\n  _inherits(Think, _CompositeGoal);\n\n  /**\r\n  * Constructs a new *Think* object.\r\n  *\r\n  * @param {GameEntity} owner - The owner of this instance.\r\n  */\n  function Think() {\n    var _this26;\n\n    var owner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, Think);\n\n    _this26 = _possibleConstructorReturn(this, _getPrototypeOf(Think).call(this, owner));\n    /**\r\n    * A list of goal evaluators.\r\n    * @type Array\r\n    */\n\n    _this26.evaluators = new Array(); //\n\n    _this26._typesMap = new Map();\n    return _this26;\n  }\n  /**\r\n  * Executed when this goal is activated.\r\n  */\n\n\n  _createClass(Think, [{\n    key: \"activate\",\n    value: function activate() {\n      this.arbitrate();\n    }\n    /**\r\n    * Executed in each simulation step.\r\n    */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      this.activateIfInactive();\n      var subgoalStatus = this.executeSubgoals();\n\n      if (subgoalStatus === Goal.STATUS.COMPLETED || subgoalStatus === Goal.STATUS.FAILED) {\n        this.status = Goal.STATUS.INACTIVE;\n      }\n    }\n    /**\r\n    * Executed when this goal is satisfied.\r\n    */\n\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      this.clearSubgoals();\n    }\n    /**\r\n    * Adds the given goal evaluator to this instance.\r\n    *\r\n    * @param {GoalEvaluator} evaluator - The goal evaluator to add.\r\n    * @return {Think} A reference to this instance.\r\n    */\n\n  }, {\n    key: \"addEvaluator\",\n    value: function addEvaluator(evaluator) {\n      this.evaluators.push(evaluator);\n      return this;\n    }\n    /**\r\n    * Removes the given goal evaluator from this instance.\r\n    *\r\n    * @param {GoalEvaluator} evaluator - The goal evaluator to remove.\r\n    * @return {Think} A reference to this instance.\r\n    */\n\n  }, {\n    key: \"removeEvaluator\",\n    value: function removeEvaluator(evaluator) {\n      var index = this.evaluators.indexOf(evaluator);\n      this.evaluators.splice(index, 1);\n      return this;\n    }\n    /**\r\n    * This method represents the top level decision process of an agent.\r\n    * It iterates through each goal evaluator and selects the one that\r\n    * has the highest score as the current goal.\r\n    *\r\n    * @return {Think} A reference to this instance.\r\n    */\n\n  }, {\n    key: \"arbitrate\",\n    value: function arbitrate() {\n      var evaluators = this.evaluators;\n      var bestDesirability = -1;\n      var bestEvaluator = null; // try to find the best top-level goal/strategy for the entity\n\n      for (var _i68 = 0, l = evaluators.length; _i68 < l; _i68++) {\n        var evaluator = evaluators[_i68];\n        var desirability = evaluator.calculateDesirability(this.owner);\n        desirability *= evaluator.characterBias;\n\n        if (desirability >= bestDesirability) {\n          bestDesirability = desirability;\n          bestEvaluator = evaluator;\n        }\n      } // use the evaluator to set the respective goal\n\n\n      if (bestEvaluator !== null) {\n        bestEvaluator.setGoal(this.owner);\n      } else {\n        Logger.error('YUKA.Think: Unable to determine goal evaluator for game entity:', this.owner);\n      }\n\n      return this;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(Think.prototype), \"toJSON\", this).call(this);\n\n      json.evaluators = new Array();\n\n      for (var _i69 = 0, l = this.evaluators.length; _i69 < l; _i69++) {\n        var evaluator = this.evaluators[_i69];\n        json.evaluators.push(evaluator.toJSON());\n      }\n\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {Think} A reference to this instance.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(Think.prototype), \"fromJSON\", this).call(this, json);\n\n      var typesMap = this._typesMap;\n      this.evaluators.length = 0;\n      this.terminate(); // evaluators\n\n      for (var _i70 = 0, l = json.evaluators.length; _i70 < l; _i70++) {\n        var evaluatorJSON = json.evaluators[_i70];\n        var type = evaluatorJSON.type;\n        var ctor = typesMap.get(type);\n\n        if (ctor !== undefined) {\n          var evaluator = new ctor().fromJSON(evaluatorJSON);\n          this.evaluators.push(evaluator);\n        } else {\n          Logger.warn('YUKA.Think: Unsupported goal evaluator type:', type);\n          continue;\n        }\n      } // goals\n\n\n      function parseGoal(goalJSON) {\n        var type = goalJSON.type;\n        var ctor = typesMap.get(type);\n\n        if (ctor !== undefined) {\n          var goal = new ctor().fromJSON(goalJSON);\n          var subgoalsJSON = goalJSON.subgoals;\n\n          if (subgoalsJSON !== undefined) {\n            // composite goal\n            for (var _i71 = 0, _l6 = subgoalsJSON.length; _i71 < _l6; _i71++) {\n              var subgoal = parseGoal(subgoalsJSON[_i71]);\n              if (subgoal) goal.subgoals.push(subgoal);\n            }\n          }\n\n          return goal;\n        } else {\n          Logger.warn('YUKA.Think: Unsupported goal evaluator type:', type);\n          return;\n        }\n      }\n\n      for (var _i72 = 0, _l7 = json.subgoals.length; _i72 < _l7; _i72++) {\n        var subgoal = parseGoal(json.subgoals[_i72]);\n        if (subgoal) this.subgoals.push(subgoal);\n      }\n\n      return this;\n    }\n    /**\r\n    * Registers a custom type for deserialization. When calling {@link Think#fromJSON}\r\n    * this instance is able to pick the correct constructor in order to create custom\r\n    * goals or goal evaluators.\r\n    *\r\n    * @param {String} type - The name of the goal or goal evaluator.\r\n    * @param {Function} constructor - The constructor function.\r\n    * @return {Think} A reference to this instance.\r\n    */\n\n  }, {\n    key: \"registerType\",\n    value: function registerType(type, constructor) {\n      this._typesMap.set(type, constructor);\n\n      return this;\n    }\n  }]);\n\n  return Think;\n}(CompositeGoal);\n/**\r\n* Base class for graph edges.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar Edge =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new edge.\r\n  *\r\n  * @param {Number} from - The index of the from node.\r\n  * @param {Number} to - The index of the to node.\r\n  * @param {Number} cost - The cost of this edge.\r\n  */\n  function Edge() {\n    var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    var cost = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, Edge);\n\n    /**\r\n    * The index of the *from* node.\r\n    * @type Number\r\n    * @default -1\r\n    */\n    this.from = from;\n    /**\r\n    * The index of the *to* node.\r\n    * @type Number\r\n    * @default -1\r\n    */\n\n    this.to = to;\n    /**\r\n    * The cost of this edge. This could be for example a distance or time value.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    this.cost = cost;\n  }\n  /**\r\n  * Copies all values from the given edge to this edge.\r\n  *\r\n  * @param {Edge} edge - The edge to copy.\r\n  * @return {Edge} A reference to this edge.\r\n  */\n\n\n  _createClass(Edge, [{\n    key: \"copy\",\n    value: function copy(edge) {\n      this.from = edge.from;\n      this.to = edge.to;\n      this.cost = edge.cost;\n      return this;\n    }\n    /**\r\n    * Creates a new edge and copies all values from this edge.\r\n    *\r\n    * @return {Edge} A new edge.\r\n    */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.constructor.name,\n        from: this.from,\n        to: this.to,\n        cost: this.cost\n      };\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {Edge} A reference to this edge.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.from = json.from;\n      this.to = json.to;\n      this.cost = json.cost;\n      return this;\n    }\n  }]);\n\n  return Edge;\n}();\n/**\r\n* Base class for graph nodes.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new node.\r\n  *\r\n  * @param {Number} index - The unique index of this node.\r\n  */\n  function Node() {\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n\n    _classCallCheck(this, Node);\n\n    /**\r\n    * The unique index of this node. The default value *-1* means invalid index.\r\n    * @type Number\r\n    * @default -1\r\n    */\n    this.index = index;\n  }\n  /**\r\n  * Transforms this instance into a JSON object.\r\n  *\r\n  * @return {Object} The JSON object.\r\n  */\n\n\n  _createClass(Node, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.constructor.name,\n        index: this.index\n      };\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {Node} A reference to this node.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.index = json.index;\n      return this;\n    }\n  }]);\n\n  return Node;\n}();\n/**\r\n* Class representing a sparse graph implementation based on adjacency lists.\r\n* A sparse graph can be used to model many different types of graphs like navigation\r\n* graphs (pathfinding), dependency graphs (e.g. technology trees) or state graphs\r\n* (a representation of every possible state in a game).\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar Graph =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new graph.\r\n  */\n  function Graph() {\n    _classCallCheck(this, Graph);\n\n    /**\r\n    * Whether this graph is directed or not.\r\n    * @type Boolean\r\n    * @default false\r\n    */\n    this.digraph = false;\n    this._nodes = new Map(); // contains all nodes in a map: (nodeIndex => node)\n\n    this._edges = new Map(); // adjacency list for each node: (nodeIndex => edges)\n  }\n  /**\r\n  * Adds a node to the graph.\r\n  *\r\n  * @param {Node} node - The node to add.\r\n  * @return {Graph} A reference to this graph.\r\n  */\n\n\n  _createClass(Graph, [{\n    key: \"addNode\",\n    value: function addNode(node) {\n      var index = node.index;\n\n      this._nodes.set(index, node);\n\n      this._edges.set(index, new Array());\n\n      return this;\n    }\n    /**\r\n    * Adds an edge to the graph. If the graph is undirected, the method\r\n    * automatically creates the opponent edge.\r\n    *\r\n    * @param {Edge} edge - The edge to add.\r\n    * @return {Graph} A reference to this graph.\r\n    */\n\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(edge) {\n      var edges;\n      edges = this._edges.get(edge.from);\n      edges.push(edge);\n\n      if (this.digraph === false) {\n        var oppositeEdge = edge.clone();\n        oppositeEdge.from = edge.to;\n        oppositeEdge.to = edge.from;\n        edges = this._edges.get(edge.to);\n        edges.push(oppositeEdge);\n      }\n\n      return this;\n    }\n    /**\r\n    * Returns a node for the given node index. If no node is found,\r\n    * *null* is returned.\r\n    *\r\n    * @param {Number} index - The index of the node.\r\n    * @return {Node} The requested node.\r\n    */\n\n  }, {\n    key: \"getNode\",\n    value: function getNode(index) {\n      return this._nodes.get(index) || null;\n    }\n    /**\r\n    * Returns an edge for the given *from* and *to* node indices.\r\n    * If no node is found, *null* is returned.\r\n    *\r\n    * @param {Number} from - The index of the from node.\r\n    * @param {Number} to - The index of the to node.\r\n    * @return {Edge} The requested edge.\r\n    */\n\n  }, {\n    key: \"getEdge\",\n    value: function getEdge(from, to) {\n      if (this.hasNode(from) && this.hasNode(to)) {\n        var _edges = this._edges.get(from);\n\n        for (var _i73 = 0, l = _edges.length; _i73 < l; _i73++) {\n          var edge = _edges[_i73];\n\n          if (edge.to === to) {\n            return edge;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\r\n    * Gathers all nodes of the graph and stores them into the given array.\r\n    *\r\n    * @param {Array} result - The result array.\r\n    * @return {Array} The result array.\r\n    */\n\n  }, {\n    key: \"getNodes\",\n    value: function getNodes(result) {\n      result.length = 0;\n      result.push.apply(result, _toConsumableArray(this._nodes.values()));\n      return result;\n    }\n    /**\r\n    * Gathers all edges leading from the given node index and stores them\r\n    * into the given array.\r\n    *\r\n    * @param {Number} index - The node index.\r\n    * @param {Array} result - The result array.\r\n    * @return {Array} The result array.\r\n    */\n\n  }, {\n    key: \"getEdgesOfNode\",\n    value: function getEdgesOfNode(index, result) {\n      var edges = this._edges.get(index);\n\n      if (edges !== undefined) {\n        result.length = 0;\n        result.push.apply(result, _toConsumableArray(edges));\n      }\n\n      return result;\n    }\n    /**\r\n    * Returns the node count of the graph.\r\n    *\r\n    * @return {number} The amount of nodes.\r\n    */\n\n  }, {\n    key: \"getNodeCount\",\n    value: function getNodeCount() {\n      return this._nodes.size;\n    }\n    /**\r\n    * Returns the edge count of the graph.\r\n    *\r\n    * @return {number} The amount of edges.\r\n    */\n\n  }, {\n    key: \"getEdgeCount\",\n    value: function getEdgeCount() {\n      var count = 0;\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this._edges.values()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var _edges2 = _step6.value;\n          count += _edges2.length;\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      return count;\n    }\n    /**\r\n    * Removes the given node from the graph and all edges which are connected\r\n    * with this node.\r\n    *\r\n    * @param {Node} node - The node to remove.\r\n    * @return {Graph} A reference to this graph.\r\n    */\n\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(node) {\n      this._nodes.delete(node.index);\n\n      if (this.digraph === false) {\n        // if the graph is not directed, remove all edges leading to this node\n        var _edges3 = this._edges.get(node.index);\n\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = _edges3[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var edge = _step7.value;\n\n            var edgesOfNeighbor = this._edges.get(edge.to);\n\n            for (var _i74 = edgesOfNeighbor.length - 1; _i74 >= 0; _i74--) {\n              var edgeNeighbor = edgesOfNeighbor[_i74];\n\n              if (edgeNeighbor.to === node.index) {\n                var index = edgesOfNeighbor.indexOf(edgeNeighbor);\n                edgesOfNeighbor.splice(index, 1);\n                break;\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      } else {\n        // if the graph is directed, remove the edges the slow way\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = this._edges.values()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var _edges4 = _step8.value;\n\n            for (var _i75 = _edges4.length - 1; _i75 >= 0; _i75--) {\n              var _edge = _edges4[_i75];\n\n              if (!this.hasNode(_edge.to) || !this.hasNode(_edge.from)) {\n                var _index = _edges4.indexOf(_edge);\n\n                _edges4.splice(_index, 1);\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n              _iterator8.return();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n      } // delete edge list of node (edges leading from this node)\n\n\n      this._edges.delete(node.index);\n\n      return this;\n    }\n    /**\r\n    * Removes the given edge from the graph. If the graph is undirected, the\r\n    * method also removes the opponent edge.\r\n    *\r\n    * @param {Edge} edge - The edge to remove.\r\n    * @return {Graph} A reference to this graph.\r\n    */\n\n  }, {\n    key: \"removeEdge\",\n    value: function removeEdge(edge) {\n      // delete the edge from the node's edge list\n      var edges = this._edges.get(edge.from);\n\n      if (edges !== undefined) {\n        var index = edges.indexOf(edge);\n        edges.splice(index, 1); // if the graph is not directed, delete the edge connecting the node in the opposite direction\n\n        if (this.digraph === false) {\n          var _edges5 = this._edges.get(edge.to);\n\n          for (var _i76 = 0, l = _edges5.length; _i76 < l; _i76++) {\n            var e = _edges5[_i76];\n\n            if (e.to === edge.from) {\n              var _index2 = _edges5.indexOf(e);\n\n              _edges5.splice(_index2, 1);\n\n              break;\n            }\n          }\n        }\n      }\n\n      return this;\n    }\n    /**\r\n    * Return true if the graph has the given node index.\r\n    *\r\n    * @param {Number} index - The node index to test.\r\n    * @return {Boolean} Whether this graph has the node or not.\r\n    */\n\n  }, {\n    key: \"hasNode\",\n    value: function hasNode(index) {\n      return this._nodes.has(index);\n    }\n    /**\r\n    * Return true if the graph has an edge connecting the given\r\n    * *from* and *to* node indices.\r\n    *\r\n    * @param {Number} from - The index of the from node.\r\n    * @param {Number} to - The index of the to node.\r\n    * @return {Boolean} Whether this graph has the edge or not.\r\n    */\n\n  }, {\n    key: \"hasEdge\",\n    value: function hasEdge(from, to) {\n      if (this.hasNode(from) && this.hasNode(to)) {\n        var _edges6 = this._edges.get(from);\n\n        for (var _i77 = 0, l = _edges6.length; _i77 < l; _i77++) {\n          var edge = _edges6[_i77];\n\n          if (edge.to === to) {\n            return true;\n          }\n        }\n\n        return false;\n      } else {\n        return false;\n      }\n    }\n    /**\r\n    * Removes all nodes and edges from this graph.\r\n    *\r\n    * @return {Graph} A reference to this graph.\r\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._nodes.clear();\n\n      this._edges.clear();\n\n      return this;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        type: this.constructor.name,\n        digraph: this.digraph\n      };\n      var edges = new Array();\n      var nodes = new Array();\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = this._nodes.entries()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var _step9$value = _slicedToArray(_step9.value, 2),\n              key = _step9$value[0],\n              value = _step9$value[1];\n\n          var adjacencyList = new Array();\n          this.getEdgesOfNode(key, adjacencyList);\n\n          for (var _i78 = 0, l = adjacencyList.length; _i78 < l; _i78++) {\n            edges.push(adjacencyList[_i78].toJSON());\n          }\n\n          nodes.push(value.toJSON());\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      json._edges = edges;\n      json._nodes = nodes;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {Graph} A reference to this graph.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.digraph = json.digraph;\n\n      for (var _i79 = 0, l = json._nodes.length; _i79 < l; _i79++) {\n        this.addNode(new Node().fromJSON(json._nodes[_i79]));\n      }\n\n      for (var _i80 = 0, _l8 = json._edges.length; _i80 < _l8; _i80++) {\n        this.addEdge(new Edge().fromJSON(json._edges[_i80]));\n      }\n\n      return this;\n    }\n  }]);\n\n  return Graph;\n}();\n/**\r\n* Class for representing a heuristic for graph search algorithms based\r\n* on the euclidean distance. The heuristic assumes that the node have\r\n* a *position* property of type {@link Vector3}.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar HeuristicPolicyEuclid =\n/*#__PURE__*/\nfunction () {\n  function HeuristicPolicyEuclid() {\n    _classCallCheck(this, HeuristicPolicyEuclid);\n  }\n\n  _createClass(HeuristicPolicyEuclid, null, [{\n    key: \"calculate\",\n\n    /**\r\n    * Calculates the euclidean distance between two nodes.\r\n    *\r\n    * @param {Graph} graph - The graph.\r\n    * @param {Number} source - The index of the source node.\r\n    * @param {Number} target - The index of the target node.\r\n    * @return {Number} The euclidean distance between both nodes.\r\n    */\n    value: function calculate(graph, source, target) {\n      var sourceNode = graph.getNode(source);\n      var targetNode = graph.getNode(target);\n      return sourceNode.position.distanceTo(targetNode.position);\n    }\n  }]);\n\n  return HeuristicPolicyEuclid;\n}();\n/**\r\n* Class for representing a heuristic for graph search algorithms based\r\n* on the squared euclidean distance. The heuristic assumes that the node\r\n* have a *position* property of type {@link Vector3}.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar HeuristicPolicyEuclidSquared =\n/*#__PURE__*/\nfunction () {\n  function HeuristicPolicyEuclidSquared() {\n    _classCallCheck(this, HeuristicPolicyEuclidSquared);\n  }\n\n  _createClass(HeuristicPolicyEuclidSquared, null, [{\n    key: \"calculate\",\n\n    /**\r\n    * Calculates the squared euclidean distance between two nodes.\r\n    *\r\n    * @param {Graph} graph - The graph.\r\n    * @param {Number} source - The index of the source node.\r\n    * @param {Number} target - The index of the target node.\r\n    * @return {Number} The squared euclidean distance between both nodes.\r\n    */\n    value: function calculate(graph, source, target) {\n      var sourceNode = graph.getNode(source);\n      var targetNode = graph.getNode(target);\n      return sourceNode.position.squaredDistanceTo(targetNode.position);\n    }\n  }]);\n\n  return HeuristicPolicyEuclidSquared;\n}();\n/**\r\n* Class for representing a heuristic for graph search algorithms based\r\n* on the manhattan distance. The heuristic assumes that the node\r\n* have a *position* property of type {@link Vector3}.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar HeuristicPolicyManhattan =\n/*#__PURE__*/\nfunction () {\n  function HeuristicPolicyManhattan() {\n    _classCallCheck(this, HeuristicPolicyManhattan);\n  }\n\n  _createClass(HeuristicPolicyManhattan, null, [{\n    key: \"calculate\",\n\n    /**\r\n    * Calculates the manhattan distance between two nodes.\r\n    *\r\n    * @param {Graph} graph - The graph.\r\n    * @param {Number} source - The index of the source node.\r\n    * @param {Number} target - The index of the target node.\r\n    * @return {Number} The manhattan distance between both nodes.\r\n    */\n    value: function calculate(graph, source, target) {\n      var sourceNode = graph.getNode(source);\n      var targetNode = graph.getNode(target);\n      return sourceNode.position.manhattanDistanceTo(targetNode.position);\n    }\n  }]);\n\n  return HeuristicPolicyManhattan;\n}();\n/**\r\n* Class for representing a heuristic for graph search algorithms based\r\n* on Dijkstra's algorithm.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar HeuristicPolicyDijkstra =\n/*#__PURE__*/\nfunction () {\n  function HeuristicPolicyDijkstra() {\n    _classCallCheck(this, HeuristicPolicyDijkstra);\n  }\n\n  _createClass(HeuristicPolicyDijkstra, null, [{\n    key: \"calculate\",\n\n    /**\r\n    * This heuristic always returns *0*. The {@link AStar} algorithm\r\n    * behaves with this heuristic exactly like {@link Dijkstra}\r\n    *\r\n    * @param {Graph} graph - The graph.\r\n    * @param {Number} source - The index of the source node.\r\n    * @param {Number} target - The index of the target node.\r\n    * @return {Number} The value 0.\r\n    */\n    value: function calculate()\n    /* graph, source, target */\n    {\n      return 0;\n    }\n  }]);\n\n  return HeuristicPolicyDijkstra;\n}();\n/**\r\n * Class for representing a binary heap priority queue that enables\r\n * more efficient sorting of arrays. The implementation is based on\r\n * {@link https://github.com/mourner/tinyqueue tinyqueue}.\r\n *\r\n * @author {@link https://github.com/Mugen87|Mugen87}\r\n */\n\n\nvar PriorityQueue =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new priority queue.\r\n  *\r\n  * @param {Function} compare - The compare function used for sorting.\r\n  */\n  function PriorityQueue() {\n    var compare = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultCompare;\n\n    _classCallCheck(this, PriorityQueue);\n\n    /**\r\n    * The data items of the priority queue.\r\n    * @type Array\r\n    */\n    this.data = new Array();\n    /**\r\n    * The length of the priority queue.\r\n    * @type Number\r\n    * @default 0\r\n    */\n\n    this.length = 0;\n    /**\r\n    * The compare function used for sorting.\r\n    * @type Function\r\n    * @default defaultCompare\r\n    */\n\n    this.compare = compare;\n  }\n  /**\r\n  * Pushes an item to the priority queue.\r\n  *\r\n  * @param {Object} item - The item to add.\r\n  */\n\n\n  _createClass(PriorityQueue, [{\n    key: \"push\",\n    value: function push(item) {\n      this.data.push(item);\n      this.length++;\n\n      this._up(this.length - 1);\n    }\n    /**\r\n    * Returns the item with the highest priority and removes\r\n    * it from the priority queue.\r\n    *\r\n    * @return {Object} The item with the highest priority.\r\n    */\n\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      if (this.length === 0) return null;\n      var top = this.data[0];\n      this.length--;\n\n      if (this.length > 0) {\n        this.data[0] = this.data[this.length];\n\n        this._down(0);\n      }\n\n      this.data.pop();\n      return top;\n    }\n    /**\r\n    * Returns the item with the highest priority without removal.\r\n    *\r\n    * @return {Object} The item with the highest priority.\r\n    */\n\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.data[0] || null;\n    }\n  }, {\n    key: \"_up\",\n    value: function _up(index) {\n      var data = this.data;\n      var compare = this.compare;\n      var item = data[index];\n\n      while (index > 0) {\n        var parent = index - 1 >> 1;\n        var current = data[parent];\n        if (compare(item, current) >= 0) break;\n        data[index] = current;\n        index = parent;\n      }\n\n      data[index] = item;\n    }\n  }, {\n    key: \"_down\",\n    value: function _down(index) {\n      var data = this.data;\n      var compare = this.compare;\n      var item = data[index];\n      var halfLength = this.length >> 1;\n\n      while (index < halfLength) {\n        var left = (index << 1) + 1;\n        var right = left + 1;\n        var best = data[left];\n\n        if (right < this.length && compare(data[right], best) < 0) {\n          left = right;\n          best = data[right];\n        }\n\n        if (compare(best, item) >= 0) break;\n        data[index] = best;\n        index = left;\n      }\n\n      data[index] = item;\n    }\n  }]);\n\n  return PriorityQueue;\n}();\n/* istanbul ignore next */\n\n\nfunction defaultCompare(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n/**\r\n* Implementation of the AStar algorithm.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar AStar =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs an AStar algorithm object.\r\n  *\r\n  * @param {Graph} graph - The graph.\r\n  * @param {Number} source - The node index of the source node.\r\n  * @param {Number} target - The node index of the target node.\r\n  */\n  function AStar() {\n    var graph = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n    _classCallCheck(this, AStar);\n\n    /**\r\n    * The graph.\r\n    * @type Graph\r\n    */\n    this.graph = graph;\n    /**\r\n    * The node index of the source node.\r\n    * @type Number\r\n    */\n\n    this.source = source;\n    /**\r\n    * The node index of the target node.\r\n    * @type Number\r\n    */\n\n    this.target = target;\n    /**\r\n    * Whether the search was successful or not.\r\n    * @type Boolean\r\n    * @default false\r\n    */\n\n    this.found = false;\n    /**\r\n    * The heuristic of the search.\r\n    * @type Object\r\n    * @default HeuristicPolicyEuclid\r\n    */\n\n    this.heuristic = HeuristicPolicyEuclid;\n    this._cost = new Map(); // contains the \"real\" accumulative cost to a node\n\n    this._shortestPathTree = new Map();\n    this._searchFrontier = new Map();\n  }\n  /**\r\n  * Executes the graph search. If the search was successful, {@link AStar#found}\r\n  * is set to true.\r\n  *\r\n  * @return {AStar} A reference to this AStar object.\r\n  */\n\n\n  _createClass(AStar, [{\n    key: \"search\",\n    value: function search() {\n      var outgoingEdges = new Array();\n      var pQueue = new PriorityQueue(compare);\n      pQueue.push({\n        cost: 0,\n        index: this.source\n      }); // while the queue is not empty\n\n      while (pQueue.length > 0) {\n        var nextNode = pQueue.pop();\n        var nextNodeIndex = nextNode.index; // if the shortest path tree has the given node, we already found the shortest\n        // path to this particular one\n\n        if (this._shortestPathTree.has(nextNodeIndex)) continue; // move this edge from the frontier to the shortest path tree\n\n        if (this._searchFrontier.has(nextNodeIndex) === true) {\n          this._shortestPathTree.set(nextNodeIndex, this._searchFrontier.get(nextNodeIndex));\n        } // if the target has been found exit\n\n\n        if (nextNodeIndex === this.target) {\n          this.found = true;\n          return this;\n        } // now relax the edges\n\n\n        this.graph.getEdgesOfNode(nextNodeIndex, outgoingEdges);\n\n        for (var _i81 = 0, l = outgoingEdges.length; _i81 < l; _i81++) {\n          var edge = outgoingEdges[_i81]; // A* cost formula : F = G + H\n          // G is the cumulative cost to reach a node\n\n          var G = (this._cost.get(nextNodeIndex) || 0) + edge.cost; // H is the heuristic estimate of the distance to the target\n\n          var H = this.heuristic.calculate(this.graph, edge.to, this.target); // F is the sum of G and H\n\n          var F = G + H; // We enhance our search frontier in two cases:\n          // 1. If the node was never on the search frontier\n          // 2. If the cost to this node is better than before\n\n          if (this._searchFrontier.has(edge.to) === false || G < this._cost.get(edge.to)) {\n            this._cost.set(edge.to, G);\n\n            this._searchFrontier.set(edge.to, edge);\n\n            pQueue.push({\n              cost: F,\n              index: edge.to\n            });\n          }\n        }\n      }\n\n      this.found = false;\n      return this;\n    }\n    /**\r\n    * Returns the shortest path from the source to the target node as an array of node indices.\r\n    *\r\n    * @return {Array} The shortest path.\r\n    */\n\n  }, {\n    key: \"getPath\",\n    value: function getPath() {\n      // array of node indices that comprise the shortest path from the source to the target\n      var path = new Array(); // just return an empty path if no path to target found or if no target has been specified\n\n      if (this.found === false || this.target === -1) return path; // start with the target of the path\n\n      var currentNode = this.target;\n      path.push(currentNode); // while the current node is not the source node keep processing\n\n      while (currentNode !== this.source) {\n        // determine the parent of the current node\n        currentNode = this._shortestPathTree.get(currentNode).from; // push the new current node at the beginning of the array\n\n        path.unshift(currentNode);\n      }\n\n      return path;\n    }\n    /**\r\n    * Returns the search tree of the algorithm as an array of edges.\r\n    *\r\n    * @return {Array} The search tree.\r\n    */\n\n  }, {\n    key: \"getSearchTree\",\n    value: function getSearchTree() {\n      return _toConsumableArray(this._shortestPathTree.values());\n    }\n    /**\r\n    * Clears the internal state of the object. A new search is now possible.\r\n    *\r\n    * @return {AStar} A reference to this AStar object.\r\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.found = false;\n\n      this._cost.clear();\n\n      this._shortestPathTree.clear();\n\n      this._searchFrontier.clear();\n\n      return this;\n    }\n  }]);\n\n  return AStar;\n}();\n\nfunction compare(a, b) {\n  return a.cost < b.cost ? -1 : a.cost > b.cost ? 1 : 0;\n}\n/**\r\n* Implementation of Breadth-first Search.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar BFS =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a BFS algorithm object.\r\n  *\r\n  * @param {Graph} graph - The graph.\r\n  * @param {Number} source - The node index of the source node.\r\n  * @param {Number} target - The node index of the target node.\r\n  */\n  function BFS() {\n    var graph = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n    _classCallCheck(this, BFS);\n\n    /**\r\n    * The graph.\r\n    * @type Graph\r\n    */\n    this.graph = graph;\n    /**\r\n    * The node index of the source node.\r\n    * @type Number\r\n    */\n\n    this.source = source;\n    /**\r\n    * The node index of the target node.\r\n    * @type Number\r\n    */\n\n    this.target = target;\n    /**\r\n    * Whether the search was successful or not.\r\n    * @type Boolean\r\n    * @default false\r\n    */\n\n    this.found = false;\n    this._route = new Map(); // this holds the route taken to the target\n\n    this._visited = new Set(); // holds the visited nodes\n\n    this._spanningTree = new Set(); // for debugging purposes\n  }\n  /**\r\n  * Executes the graph search. If the search was successful, {@link BFS#found}\r\n  * is set to true.\r\n  *\r\n  * @return {BFS} A reference to this BFS object.\r\n  */\n\n\n  _createClass(BFS, [{\n    key: \"search\",\n    value: function search() {\n      // create a queue(FIFO) of edges, done via an array\n      var queue = new Array();\n      var outgoingEdges = new Array(); // create a dummy edge and put on the queue to begin the search\n\n      var startEdge = new Edge(this.source, this.source);\n      queue.push(startEdge); // mark the source node as visited\n\n      this._visited.add(this.source); // while there are edges in the queue keep searching\n\n\n      while (queue.length > 0) {\n        // grab the first edge and remove it from the queue\n        var nextEdge = queue.shift(); // make a note of the parent of the node this edge points to\n\n        this._route.set(nextEdge.to, nextEdge.from); // expand spanning tree\n\n\n        if (nextEdge !== startEdge) {\n          this._spanningTree.add(nextEdge);\n        } // if the target has been found the method can return success\n\n\n        if (nextEdge.to === this.target) {\n          this.found = true;\n          return this;\n        } // determine outgoing edges\n\n\n        this.graph.getEdgesOfNode(nextEdge.to, outgoingEdges); // push the edges leading from the node this edge points to onto the\n        // queue (provided the edge does not point to a previously visited node)\n\n        for (var _i82 = 0, l = outgoingEdges.length; _i82 < l; _i82++) {\n          var edge = outgoingEdges[_i82];\n\n          if (this._visited.has(edge.to) === false) {\n            queue.push(edge); // the node is marked as visited here, BEFORE it is examined,\n            // because it ensures a maximum of N edges are ever placed in the queue rather than E edges.\n            // (N = number of nodes, E = number of edges)\n\n            this._visited.add(edge.to);\n          }\n        }\n      }\n\n      this.found = false;\n      return this;\n    }\n    /**\r\n    * Returns the shortest path from the source to the target node as an array of node indices.\r\n    *\r\n    * @return {Array} The shortest path.\r\n    */\n\n  }, {\n    key: \"getPath\",\n    value: function getPath() {\n      // array of node indices that comprise the shortest path from the source to the target\n      var path = new Array(); // just return an empty path if no path to target found or if no target has been specified\n\n      if (this.found === false || this.target === -1) return path; // start with the target of the path\n\n      var currentNode = this.target;\n      path.push(currentNode); // while the current node is not the source node keep processing\n\n      while (currentNode !== this.source) {\n        // determine the parent of the current node\n        currentNode = this._route.get(currentNode); // push the new current node at the beginning of the array\n\n        path.unshift(currentNode);\n      }\n\n      return path;\n    }\n    /**\r\n    * Returns the search tree of the algorithm as an array of edges.\r\n    *\r\n    * @return {Array} The search tree.\r\n    */\n\n  }, {\n    key: \"getSearchTree\",\n    value: function getSearchTree() {\n      return _toConsumableArray(this._spanningTree);\n    }\n    /**\r\n    * Clears the internal state of the object. A new search is now possible.\r\n    *\r\n    * @return {BFS} A reference to this BFS object.\r\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.found = false;\n\n      this._route.clear();\n\n      this._visited.clear();\n\n      this._spanningTree.clear();\n\n      return this;\n    }\n  }]);\n\n  return BFS;\n}();\n/**\r\n* Implementation of Depth-first Search.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar DFS =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a DFS algorithm object.\r\n  *\r\n  * @param {Graph} graph - The graph.\r\n  * @param {Number} source - The node index of the source node.\r\n  * @param {Number} target - The node index of the target node.\r\n  */\n  function DFS() {\n    var graph = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n    _classCallCheck(this, DFS);\n\n    /**\r\n    * The graph.\r\n    * @type Graph\r\n    */\n    this.graph = graph;\n    /**\r\n    * The node index of the source node.\r\n    * @type Number\r\n    */\n\n    this.source = source;\n    /**\r\n    * The node index of the target node.\r\n    * @type Number\r\n    */\n\n    this.target = target;\n    /**\r\n    * Whether the search was successful or not.\r\n    * @type Boolean\r\n    * @default false\r\n    */\n\n    this.found = false;\n    this._route = new Map(); // this holds the route taken to the target\n\n    this._visited = new Set(); // holds the visited nodes\n\n    this._spanningTree = new Set(); // for debugging purposes\n  }\n  /**\r\n  * Executes the graph search. If the search was successful, {@link DFS#found}\r\n  * is set to true.\r\n  *\r\n  * @return {DFS} A reference to this DFS object.\r\n  */\n\n\n  _createClass(DFS, [{\n    key: \"search\",\n    value: function search() {\n      // create a stack(LIFO) of edges, done via an array\n      var stack = new Array();\n      var outgoingEdges = new Array(); // create a dummy edge and put on the stack to begin the search\n\n      var startEdge = new Edge(this.source, this.source);\n      stack.push(startEdge); // while there are edges in the stack keep searching\n\n      while (stack.length > 0) {\n        // grab the next edge and remove it from the stack\n        var nextEdge = stack.pop(); // make a note of the parent of the node this edge points to\n\n        this._route.set(nextEdge.to, nextEdge.from); // and mark it visited\n\n\n        this._visited.add(nextEdge.to); // expand spanning tree\n\n\n        if (nextEdge !== startEdge) {\n          this._spanningTree.add(nextEdge);\n        } // if the target has been found the method can return success\n\n\n        if (nextEdge.to === this.target) {\n          this.found = true;\n          return this;\n        } // determine outgoing edges\n\n\n        this.graph.getEdgesOfNode(nextEdge.to, outgoingEdges); // push the edges leading from the node this edge points to onto the\n        // stack (provided the edge does not point to a previously visited node)\n\n        for (var _i83 = 0, l = outgoingEdges.length; _i83 < l; _i83++) {\n          var edge = outgoingEdges[_i83];\n\n          if (this._visited.has(edge.to) === false) {\n            stack.push(edge);\n          }\n        }\n      }\n\n      this.found = false;\n      return this;\n    }\n    /**\r\n    * Returns the shortest path from the source to the target node as an array of node indices.\r\n    *\r\n    * @return {Array} The shortest path.\r\n    */\n\n  }, {\n    key: \"getPath\",\n    value: function getPath() {\n      // array of node indices that comprise the shortest path from the source to the target\n      var path = new Array(); // just return an empty path if no path to target found or if no target has been specified\n\n      if (this.found === false || this.target === -1) return path; // start with the target of the path\n\n      var currentNode = this.target;\n      path.push(currentNode); // while the current node is not the source node keep processing\n\n      while (currentNode !== this.source) {\n        // determine the parent of the current node\n        currentNode = this._route.get(currentNode); // push the new current node at the beginning of the array\n\n        path.unshift(currentNode);\n      }\n\n      return path;\n    }\n    /**\r\n    * Returns the search tree of the algorithm as an array of edges.\r\n    *\r\n    * @return {Array} The search tree.\r\n    */\n\n  }, {\n    key: \"getSearchTree\",\n    value: function getSearchTree() {\n      return _toConsumableArray(this._spanningTree);\n    }\n    /**\r\n    * Clears the internal state of the object. A new search is now possible.\r\n    *\r\n    * @return {DFS} A reference to this DFS object.\r\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.found = false;\n\n      this._route.clear();\n\n      this._visited.clear();\n\n      this._spanningTree.clear();\n\n      return this;\n    }\n  }]);\n\n  return DFS;\n}();\n/**\r\n* Implementation of Dijkstra's algorithm.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar Dijkstra =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a Dijkstra algorithm object.\r\n  *\r\n  * @param {Graph} graph - The graph.\r\n  * @param {Number} source - The node index of the source node.\r\n  * @param {Number} target - The node index of the target node.\r\n  */\n  function Dijkstra() {\n    var graph = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n    _classCallCheck(this, Dijkstra);\n\n    /**\r\n    * The graph.\r\n    * @type Graph\r\n    */\n    this.graph = graph;\n    /**\r\n    * The node index of the source node.\r\n    * @type Number\r\n    */\n\n    this.source = source;\n    /**\r\n    * The node index of the target node.\r\n    * @type Number\r\n    */\n\n    this.target = target;\n    /**\r\n    * Whether the search was successful or not.\r\n    * @type Boolean\r\n    * @default false\r\n    */\n\n    this.found = false;\n    this._cost = new Map(); // total cost of the bast path so far for a given node\n\n    this._shortestPathTree = new Map();\n    this._searchFrontier = new Map();\n  }\n  /**\r\n  * Executes the graph search. If the search was successful, {@link Dijkstra#found}\r\n  * is set to true.\r\n  *\r\n  * @return {Dijkstra} A reference to this Dijkstra object.\r\n  */\n\n\n  _createClass(Dijkstra, [{\n    key: \"search\",\n    value: function search() {\n      var outgoingEdges = new Array();\n      var pQueue = new PriorityQueue(compare$1);\n      pQueue.push({\n        cost: 0,\n        index: this.source\n      }); // while the queue is not empty\n\n      while (pQueue.length > 0) {\n        var nextNode = pQueue.pop();\n        var nextNodeIndex = nextNode.index; // if the shortest path tree has the given node, we already found the shortest\n        // path to this particular one\n\n        if (this._shortestPathTree.has(nextNodeIndex)) continue; // move this edge from the frontier to the shortest path tree\n\n        if (this._searchFrontier.has(nextNodeIndex) === true) {\n          this._shortestPathTree.set(nextNodeIndex, this._searchFrontier.get(nextNodeIndex));\n        } // if the target has been found exit\n\n\n        if (nextNodeIndex === this.target) {\n          this.found = true;\n          return this;\n        } // now relax the edges\n\n\n        this.graph.getEdgesOfNode(nextNodeIndex, outgoingEdges);\n\n        for (var _i84 = 0, l = outgoingEdges.length; _i84 < l; _i84++) {\n          var edge = outgoingEdges[_i84]; // the total cost to the node this edge points to is the cost to the\n          // current node plus the cost of the edge connecting them.\n\n          var newCost = (this._cost.get(nextNodeIndex) || 0) + edge.cost; // We enhance our search frontier in two cases:\n          // 1. If the node was never on the search frontier\n          // 2. If the cost to this node is better than before\n\n          if (this._searchFrontier.has(edge.to) === false || newCost < this._cost.get(edge.to)) {\n            this._cost.set(edge.to, newCost);\n\n            this._searchFrontier.set(edge.to, edge);\n\n            pQueue.push({\n              cost: newCost,\n              index: edge.to\n            });\n          }\n        }\n      }\n\n      this.found = false;\n      return this;\n    }\n    /**\r\n    * Returns the shortest path from the source to the target node as an array of node indices.\r\n    *\r\n    * @return {Array} The shortest path.\r\n    */\n\n  }, {\n    key: \"getPath\",\n    value: function getPath() {\n      // array of node indices that comprise the shortest path from the source to the target\n      var path = new Array(); // just return an empty path if no path to target found or if no target has been specified\n\n      if (this.found === false || this.target === -1) return path; // start with the target of the path\n\n      var currentNode = this.target;\n      path.push(currentNode); // while the current node is not the source node keep processing\n\n      while (currentNode !== this.source) {\n        // determine the parent of the current node\n        currentNode = this._shortestPathTree.get(currentNode).from; // push the new current node at the beginning of the array\n\n        path.unshift(currentNode);\n      }\n\n      return path;\n    }\n    /**\r\n    * Returns the search tree of the algorithm as an array of edges.\r\n    *\r\n    * @return {Array} The search tree.\r\n    */\n\n  }, {\n    key: \"getSearchTree\",\n    value: function getSearchTree() {\n      return _toConsumableArray(this._shortestPathTree.values());\n    }\n    /**\r\n    * Clears the internal state of the object. A new search is now possible.\r\n    *\r\n    * @return {Dijkstra} A reference to this Dijkstra object.\r\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.found = false;\n\n      this._cost.clear();\n\n      this._shortestPathTree.clear();\n\n      this._searchFrontier.clear();\n\n      return this;\n    }\n  }]);\n\n  return Dijkstra;\n}();\n\nfunction compare$1(a, b) {\n  return a.cost < b.cost ? -1 : a.cost > b.cost ? 1 : 0;\n}\n\nvar v1$3 = new Vector3();\nvar v2$1 = new Vector3();\nvar v3 = new Vector3();\nvar xAxis = new Vector3(1, 0, 0);\nvar yAxis = new Vector3(0, 1, 0);\nvar zAxis = new Vector3(0, 0, 1);\nvar triangle$1 = {\n  a: new Vector3(),\n  b: new Vector3(),\n  c: new Vector3()\n};\nvar intersection = new Vector3();\nvar intersections = new Array();\n/**\r\n* Class representing a bounding volume hierarchy. The current implementation\r\n* represents single BVH nodes as AABBs. It accepts arbitrary branching factors\r\n* and can subdivide the given geometry until a defined hierarchy depth has been reached.\r\n* Besides, the hierarchy construction is performed top-down and the algorithm only\r\n* performs splits along the cardinal axes.\r\n*\r\n* Reference: Bounding Volume Hierarchies in Real-Time Collision Detection\r\n* by Christer Ericson (chapter 6).\r\n*\r\n* @author {@link https://github.com/robp94|robp94}\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar BVH =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new BVH.\r\n  *\r\n  * @param {Number} branchingFactor - The branching factor.\r\n  * @param {Number} depth - The maximum hierarchical depth.\r\n  * @param {Number} primitivesPerNode - The minimum amount of primitives per BVH node.\r\n  */\n  function BVH() {\n    var branchingFactor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    var primitivesPerNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n\n    _classCallCheck(this, BVH);\n\n    /**\r\n    * The branching factor (how many nodes per level).\r\n    * @type Number\r\n    * @default 2\r\n    */\n    this.branchingFactor = branchingFactor;\n    /**\r\n    * The minimum amount of primitives per BVH node.\r\n    * @type Number\r\n    * @default 10\r\n    */\n\n    this.primitivesPerNode = primitivesPerNode;\n    /**\r\n    * The maximum hierarchical depth.\r\n    * @type Number\r\n    * @default 10\r\n    */\n\n    this.depth = depth;\n    /**\r\n    * The root BVH node.\r\n    * @type BVHNode\r\n    * @default null\r\n    */\n\n    this.root = null;\n  }\n  /**\r\n  * Computes a BVH for the given mesh geometry.\r\n  *\r\n  * @param {MeshGeometry} geometry - The mesh geometry.\r\n  * @return {BVH} A reference to this BVH.\r\n  */\n\n\n  _createClass(BVH, [{\n    key: \"fromMeshGeometry\",\n    value: function fromMeshGeometry(geometry) {\n      var _this$root$primitives;\n\n      this.root = new BVHNode(); // primitives\n\n      var nonIndexedGeometry = geometry.toTriangleSoup();\n      var vertices = nonIndexedGeometry.vertices;\n\n      (_this$root$primitives = this.root.primitives).push.apply(_this$root$primitives, _toConsumableArray(vertices)); // centroids\n\n\n      var primitives = this.root.primitives;\n\n      for (var _i85 = 0, l = primitives.length; _i85 < l; _i85 += 9) {\n        v1$3.fromArray(primitives, _i85);\n        v2$1.fromArray(primitives, _i85 + 3);\n        v3.fromArray(primitives, _i85 + 6);\n        v1$3.add(v2$1).add(v3).divideScalar(3);\n        this.root.centroids.push(v1$3.x, v1$3.y, v1$3.z);\n      } // build\n\n\n      this.root.build(this.branchingFactor, this.primitivesPerNode, this.depth, 1);\n      return this;\n    }\n    /**\r\n    * Executes the given callback for each node of the BVH.\r\n    *\r\n    * @param {Function} callback - The callback to execute.\r\n    * @return {BVH} A reference to this BVH.\r\n    */\n\n  }, {\n    key: \"traverse\",\n    value: function traverse(callback) {\n      this.root.traverse(callback);\n      return this;\n    }\n  }]);\n\n  return BVH;\n}();\n/**\r\n* A single node in a bounding volume hierarchy (BVH).\r\n*\r\n* @author {@link https://github.com/robp94|robp94}\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar BVHNode =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a BVH node.\r\n  */\n  function BVHNode() {\n    _classCallCheck(this, BVHNode);\n\n    /**\r\n    * The parent BVH node.\r\n    * @type BVHNode\r\n    * @default null\r\n    */\n    this.parent = null;\n    /**\r\n    * The child BVH nodes.\r\n    * @type Array\r\n    */\n\n    this.children = new Array();\n    /**\r\n    * The bounding volume of this BVH node.\r\n    * @type AABB\r\n    */\n\n    this.boundingVolume = new AABB();\n    /**\r\n    * The primitives (triangles) of this BVH node.\r\n    * Only filled for leaf nodes.\r\n    * @type Array\r\n    */\n\n    this.primitives = new Array();\n    /**\r\n    * The centroids of the node's triangles.\r\n    * Only filled for leaf nodes.\r\n    * @type Array\r\n    */\n\n    this.centroids = new Array();\n  }\n  /**\r\n  * Returns true if this BVH node is a root node.\r\n  *\r\n  * @return {Boolean} Whether this BVH node is a root node or not.\r\n  */\n\n\n  _createClass(BVHNode, [{\n    key: \"root\",\n    value: function root() {\n      return this.parent === null;\n    }\n    /**\r\n    * Returns true if this BVH node is a leaf node.\r\n    *\r\n    * @return {Boolean} Whether this BVH node is a leaf node or not.\r\n    */\n\n  }, {\n    key: \"leaf\",\n    value: function leaf() {\n      return this.children.length === 0;\n    }\n    /**\r\n    * Returns the depth of this BVH node in its hierarchy.\r\n    *\r\n    * @return {Number} The hierarchical depth of this BVH node.\r\n    */\n\n  }, {\n    key: \"getDepth\",\n    value: function getDepth() {\n      var depth = 0;\n      var parent = this.parent;\n\n      while (parent !== null) {\n        parent = parent.parent;\n        depth++;\n      }\n\n      return depth;\n    }\n    /**\r\n    * Executes the given callback for this BVH node and its ancestors.\r\n    *\r\n    * @param {Function} callback - The callback to execute.\r\n    * @return {BVHNode} A reference to this BVH node.\r\n    */\n\n  }, {\n    key: \"traverse\",\n    value: function traverse(callback) {\n      callback(this);\n\n      for (var _i86 = 0, l = this.children.length; _i86 < l; _i86++) {\n        this.children[_i86].traverse(callback);\n      }\n\n      return this;\n    }\n    /**\r\n    * Builds this BVH node. That means the respective bounding volume\r\n    * is computed and the node's primitives are distributed under new child nodes.\r\n    * This only happens if the maximum hierarchical depth is not yet reached and\r\n    * the node does contain enough primitives required for a split.\r\n    *\r\n    * @param {Number} branchingFactor - The branching factor.\r\n    * @param {Number} primitivesPerNode - The minimum amount of primitives per BVH node.\r\n    * @param {Number} maxDepth - The maximum  hierarchical depth.\r\n    * @param {Number} currentDepth - The current hierarchical depth.\r\n    * @return {BVHNode} A reference to this BVH node.\r\n    */\n\n  }, {\n    key: \"build\",\n    value: function build(branchingFactor, primitivesPerNode, maxDepth, currentDepth) {\n      this.computeBoundingVolume(); // check depth and primitive count\n\n      var primitiveCount = this.primitives.length / 9;\n      var newPrimitiveCount = Math.floor(primitiveCount / branchingFactor);\n\n      if (currentDepth <= maxDepth && newPrimitiveCount >= primitivesPerNode) {\n        // split (distribute primitives on new child BVH nodes)\n        this.split(branchingFactor); // proceed with build on the next hierarchy level\n\n        for (var _i87 = 0; _i87 < branchingFactor; _i87++) {\n          this.children[_i87].build(branchingFactor, primitivesPerNode, maxDepth, currentDepth + 1);\n        }\n      }\n\n      return this;\n    }\n    /**\r\n    * Computes the AABB for this BVH node.\r\n    *\r\n    * @return {BVHNode} A reference to this BVH node.\r\n    */\n\n  }, {\n    key: \"computeBoundingVolume\",\n    value: function computeBoundingVolume() {\n      var primitives = this.primitives;\n      var aabb = this.boundingVolume; // compute AABB\n\n      aabb.min.set(Infinity, Infinity, Infinity);\n      aabb.max.set(-Infinity, -Infinity, -Infinity);\n\n      for (var _i88 = 0, l = primitives.length; _i88 < l; _i88 += 3) {\n        v1$3.x = primitives[_i88];\n        v1$3.y = primitives[_i88 + 1];\n        v1$3.z = primitives[_i88 + 2];\n        aabb.expand(v1$3);\n      }\n\n      return this;\n    }\n    /**\r\n    * Computes the split axis. Right now, only the cardinal axes\r\n    * are potential split axes.\r\n    *\r\n    * @return {Vector3} The split axis.\r\n    */\n\n  }, {\n    key: \"computeSplitAxis\",\n    value: function computeSplitAxis() {\n      var maxX,\n          maxY,\n          maxZ = maxY = maxX = -Infinity;\n      var minX,\n          minY,\n          minZ = minY = minX = Infinity;\n      var centroids = this.centroids;\n\n      for (var _i89 = 0, l = centroids.length; _i89 < l; _i89 += 3) {\n        var x = centroids[_i89];\n        var y = centroids[_i89 + 1];\n        var z = centroids[_i89 + 2];\n\n        if (x > maxX) {\n          maxX = x;\n        }\n\n        if (y > maxY) {\n          maxY = y;\n        }\n\n        if (z > maxZ) {\n          maxZ = z;\n        }\n\n        if (x < minX) {\n          minX = x;\n        }\n\n        if (y < minY) {\n          minY = y;\n        }\n\n        if (z < minZ) {\n          minZ = z;\n        }\n      }\n\n      var rangeX = maxX - minX;\n      var rangeY = maxY - minY;\n      var rangeZ = maxZ - minZ;\n\n      if (rangeX > rangeY && rangeX > rangeZ) {\n        return xAxis;\n      } else if (rangeY > rangeZ) {\n        return yAxis;\n      } else {\n        return zAxis;\n      }\n    }\n    /**\r\n    * Splits the node and distributes node's primitives over new child nodes.\r\n    *\r\n    * @param {Number} branchingFactor - The branching factor.\r\n    * @return {BVHNode} A reference to this BVH node.\r\n    */\n\n  }, {\n    key: \"split\",\n    value: function split(branchingFactor) {\n      var centroids = this.centroids;\n      var primitives = this.primitives; // create (empty) child BVH nodes\n\n      for (var _i90 = 0; _i90 < branchingFactor; _i90++) {\n        this.children[_i90] = new BVHNode();\n        this.children[_i90].parent = this;\n      } // sort primitives along split axis\n\n\n      var axis = this.computeSplitAxis();\n      var sortedPrimitiveIndices = new Array();\n\n      for (var _i91 = 0, l = centroids.length; _i91 < l; _i91 += 3) {\n        v1$3.fromArray(centroids, _i91); // the result from the dot product is our sort criterion.\n        // it represents the projection of the centroid on the split axis\n\n        var p = v1$3.dot(axis);\n        var primitiveIndex = _i91 / 3;\n        sortedPrimitiveIndices.push({\n          index: primitiveIndex,\n          p: p\n        });\n      }\n\n      sortedPrimitiveIndices.sort(sortPrimitives); // distribute data\n\n      var primitveCount = sortedPrimitiveIndices.length;\n      var primitivesPerChild = Math.floor(primitveCount / branchingFactor);\n      var childIndex = 0;\n      var primitivesIndex = 0;\n\n      for (var _i92 = 0; _i92 < primitveCount; _i92++) {\n        // selected child\n        primitivesIndex++; // check if we try to add more primitives to a child than \"primitivesPerChild\" defines.\n        // move primitives to the next child\n\n        if (primitivesIndex > primitivesPerChild) {\n          // ensure \"childIndex\" does not overflow (meaning the last child takes all remaining primitives)\n          if (childIndex < branchingFactor - 1) {\n            primitivesIndex = 1; // reset primitive index\n\n            childIndex++; // raise child index\n          }\n        }\n\n        var child = this.children[childIndex]; // move data to the next level\n        // 1. primitives\n\n        var _primitiveIndex = sortedPrimitiveIndices[_i92].index;\n        var stride = _primitiveIndex * 9; // remember the \"primitives\" array holds raw vertex data defining triangles\n\n        v1$3.fromArray(primitives, stride);\n        v2$1.fromArray(primitives, stride + 3);\n        v3.fromArray(primitives, stride + 6);\n        child.primitives.push(v1$3.x, v1$3.y, v1$3.z);\n        child.primitives.push(v2$1.x, v2$1.y, v2$1.z);\n        child.primitives.push(v3.x, v3.y, v3.z); // 2. centroid\n\n        v1$3.fromArray(centroids, _primitiveIndex * 3);\n        child.centroids.push(v1$3.x, v1$3.y, v1$3.z);\n      } // remove centroids/primitives after split from this node\n\n\n      this.centroids.length = 0;\n      this.primitives.length = 0;\n      return this;\n    }\n    /**\r\n    * Performs a ray/BVH node intersection test and stores the closest intersection point\r\n    * to the given 3D vector. If no intersection is detected, *null* is returned.\r\n    *\r\n    * @param {Ray} ray - The ray.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"intersectRay\",\n    value: function intersectRay(ray, result) {\n      // gather all intersection points along the hierarchy\n      if (ray.intersectAABB(this.boundingVolume, result) !== null) {\n        if (this.leaf() === true) {\n          var vertices = this.primitives;\n\n          for (var _i93 = 0, l = vertices.length; _i93 < l; _i93 += 9) {\n            // remember: we assume primitives are triangles\n            triangle$1.a.fromArray(vertices, _i93);\n            triangle$1.b.fromArray(vertices, _i93 + 3);\n            triangle$1.c.fromArray(vertices, _i93 + 6);\n\n            if (ray.intersectTriangle(triangle$1, true, result) !== null) {\n              intersections.push(result.clone());\n            }\n          }\n        } else {\n          // process childs\n          for (var _i94 = 0, _l9 = this.children.length; _i94 < _l9; _i94++) {\n            this.children[_i94].intersectRay(ray, result);\n          }\n        }\n      } // determine the closest intersection point in the root node (so after\n      // the hierarchy was processed)\n\n\n      if (this.root() === true) {\n        if (intersections.length > 0) {\n          var minDistance = Infinity;\n\n          for (var _i95 = 0, _l10 = intersections.length; _i95 < _l10; _i95++) {\n            var squaredDistance = ray.origin.squaredDistanceTo(intersections[_i95]);\n\n            if (squaredDistance < minDistance) {\n              minDistance = squaredDistance;\n              result.copy(intersections[_i95]);\n            }\n          } // reset array\n\n\n          intersections.length = 0; // return closest intersection point\n\n          return result;\n        } else {\n          // no intersection detected\n          return null;\n        }\n      } else {\n        // always return null for non-root nodes\n        return null;\n      }\n    }\n    /**\r\n    * Performs a ray/BVH node intersection test. Returns either true or false if\r\n    * there is a intersection or not.\r\n    *\r\n    * @param {Ray} ray - The ray.\r\n    * @return {boolean} Whether there is an intersection or not.\r\n    */\n\n  }, {\n    key: \"intersectsRay\",\n    value: function intersectsRay(ray) {\n      if (ray.intersectAABB(this.boundingVolume, intersection) !== null) {\n        if (this.leaf() === true) {\n          var vertices = this.primitives;\n\n          for (var _i96 = 0, l = vertices.length; _i96 < l; _i96 += 9) {\n            // remember: we assume primitives are triangles\n            triangle$1.a.fromArray(vertices, _i96);\n            triangle$1.b.fromArray(vertices, _i96 + 3);\n            triangle$1.c.fromArray(vertices, _i96 + 6);\n\n            if (ray.intersectTriangle(triangle$1, true, intersection) !== null) {\n              return true;\n            }\n          }\n\n          return false;\n        } else {\n          // process child BVH nodes\n          for (var _i97 = 0, _l11 = this.children.length; _i97 < _l11; _i97++) {\n            if (this.children[_i97].intersectsRay(ray) === true) {\n              return true;\n            }\n          }\n\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  }]);\n\n  return BVHNode;\n}(); //\n\n\nfunction sortPrimitives(a, b) {\n  return a.p - b.p;\n}\n\nvar p1 = new Vector3();\nvar p2 = new Vector3();\n/**\r\n* Class representing a 3D line segment.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar LineSegment =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new line segment with the given values.\r\n  *\r\n  * @param {Vector3} from - The start point of the line segment.\r\n  * @param {Vector3} to - The end point of the line segment.\r\n  */\n  function LineSegment() {\n    var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n\n    _classCallCheck(this, LineSegment);\n\n    /**\r\n    * The start point of the line segment.\r\n    * @type Vector3\r\n    */\n    this.from = from;\n    /**\r\n    * The end point of the line segment.\r\n    * @type Vector3\r\n    */\n\n    this.to = to;\n  }\n  /**\r\n  * Sets the given values to this line segment.\r\n  *\r\n  * @param {Vector3} from - The start point of the line segment.\r\n  * @param {Vector3} to - The end point of the line segment.\r\n  * @return {LineSegment} A reference to this line segment.\r\n  */\n\n\n  _createClass(LineSegment, [{\n    key: \"set\",\n    value: function set(from, to) {\n      this.from = from;\n      this.to = to;\n      return this;\n    }\n    /**\r\n    * Copies all values from the given line segment to this line segment.\r\n    *\r\n    * @param {LineSegment} lineSegment - The line segment to copy.\r\n    * @return {LineSegment} A reference to this line segment.\r\n    */\n\n  }, {\n    key: \"copy\",\n    value: function copy(lineSegment) {\n      this.from.copy(lineSegment.from);\n      this.to.copy(lineSegment.to);\n      return this;\n    }\n    /**\r\n    * Creates a new line segment and copies all values from this line segment.\r\n    *\r\n    * @return {LineSegment} A new line segment.\r\n    */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\r\n    * Computes the difference vector between the end and start point of this\r\n    * line segment and stores the result in the given vector.\r\n    *\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"delta\",\n    value: function delta(result) {\n      return result.subVectors(this.to, this.from);\n    }\n    /**\r\n    * Computes a position on the line segment according to the given t value\r\n    * and stores the result in the given 3D vector. The t value has usually a range of\r\n    * [0, 1] where 0 means start position and 1 the end position.\r\n    *\r\n    * @param {Number} t - A scalar value representing a position on the line segment.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"at\",\n    value: function at(t, result) {\n      return this.delta(result).multiplyScalar(t).add(this.from);\n    }\n    /**\r\n    * Computes the closest point on an infinite line defined by the line segment.\r\n    * It's possible to clamp the closest point so it does not exceed the start and\r\n    * end position of the line segment.\r\n    *\r\n    * @param {Vector3} point - A point in 3D space.\r\n    * @param {Boolean} clampToLine - Indicates if the results should be clamped.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The closest point.\r\n    */\n\n  }, {\n    key: \"closestPointToPoint\",\n    value: function closestPointToPoint(point, clampToLine, result) {\n      var t = this.closestPointToPointParameter(point, clampToLine);\n      return this.at(t, result);\n    }\n    /**\r\n    * Computes a scalar value which represents the closest point on an infinite line\r\n    * defined by the line segment. It's possible to clamp this value so it does not\r\n    * exceed the start and end position of the line segment.\r\n    *\r\n    * @param {Vector3} point - A point in 3D space.\r\n    * @param {Boolean} clampToLine - Indicates if the results should be clamped.\r\n    * @return {Number} A scalar representing the closest point.\r\n    */\n\n  }, {\n    key: \"closestPointToPointParameter\",\n    value: function closestPointToPointParameter(point) {\n      var clampToLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      p1.subVectors(point, this.from);\n      p2.subVectors(this.to, this.from);\n      var dotP2P2 = p2.dot(p2);\n      var dotP2P1 = p2.dot(p1);\n      var t = dotP2P1 / dotP2P2;\n      if (clampToLine) t = MathUtils.clamp(t, 0, 1);\n      return t;\n    }\n    /**\r\n    * Returns true if the given line segment is deep equal with this line segment.\r\n    *\r\n    * @param {LineSegment} lineSegment - The line segment to test.\r\n    * @return {Boolean} The result of the equality test.\r\n    */\n\n  }, {\n    key: \"equals\",\n    value: function equals(lineSegment) {\n      return lineSegment.from.equals(this.from) && lineSegment.to.equals(this.to);\n    }\n  }]);\n\n  return LineSegment;\n}();\n\nvar normal$1 = new Vector3();\nvar oppositeNormal = new Vector3();\nvar directionA = new Vector3();\nvar directionB = new Vector3();\nvar c = new Vector3();\nvar d$1 = new Vector3();\nvar v = new Vector3();\n/**\r\n* Implementation of the separating axis theorem (SAT). Used to detect intersections\r\n* between convex polyhedra. The code is based on the presentation {@link http://twvideo01.ubm-us.net/o1/vault/gdc2013/slides/822403Gregorius_Dirk_TheSeparatingAxisTest.pdf The Separating Axis Test between convex polyhedra}\r\n* by Dirk Gregorius (Valve Software) from GDC 2013.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar SAT =\n/*#__PURE__*/\nfunction () {\n  function SAT() {\n    _classCallCheck(this, SAT);\n  }\n\n  _createClass(SAT, [{\n    key: \"intersects\",\n\n    /**\r\n    * Returns true if the given convex polyhedra intersect. A polyhedron is just\r\n    * an array of {@link Polygon} objects.\r\n    *\r\n    * @param {Polyhedron} polyhedronA - The first convex polyhedron.\r\n    * @param {Polyhedron} polyhedronB - The second convex polyhedron.\r\n    * @return {Boolean} Whether there is an intersection or not.\r\n    */\n    value: function intersects(polyhedronA, polyhedronB) {\n      var resultAB = this._checkFaceDirections(polyhedronA, polyhedronB);\n\n      if (resultAB) return false;\n\n      var resultBA = this._checkFaceDirections(polyhedronB, polyhedronA);\n\n      if (resultBA) return false;\n\n      var resultEdges = this._checkEdgeDirections(polyhedronA, polyhedronB);\n\n      if (resultEdges) return false; // no separating axis found, the polyhedra must intersect\n\n      return true;\n    } // check possible separating axes from the first given polyhedron. the axes\n    // are derived from the respective face normals\n\n  }, {\n    key: \"_checkFaceDirections\",\n    value: function _checkFaceDirections(polyhedronA, polyhedronB) {\n      var faces = polyhedronA.faces;\n\n      for (var _i98 = 0, l = faces.length; _i98 < l; _i98++) {\n        var face = faces[_i98];\n        var _plane2 = face.plane;\n        oppositeNormal.copy(_plane2.normal).multiplyScalar(-1);\n\n        var supportVertex = this._getSupportVertex(polyhedronB, oppositeNormal);\n\n        var distance = _plane2.distanceToPoint(supportVertex);\n\n        if (distance > 0) return true; // separating axis found\n      }\n\n      return false;\n    } // check with possible separating axes computed via the cross product between\n    // all edge combinations of both polyhedra\n\n  }, {\n    key: \"_checkEdgeDirections\",\n    value: function _checkEdgeDirections(polyhedronA, polyhedronB) {\n      var edgesA = polyhedronA.edges;\n      var edgesB = polyhedronB.edges;\n\n      for (var _i99 = 0, il = edgesA.length; _i99 < il; _i99++) {\n        var edgeA = edgesA[_i99];\n\n        for (var j = 0, jl = edgesB.length; j < jl; j++) {\n          var edgeB = edgesB[j];\n          edgeA.getDirection(directionA);\n          edgeB.getDirection(directionB); // edge pruning: only consider edges if they build a face on the minkowski difference\n\n          if (this._minkowskiFace(edgeA, directionA, edgeB, directionB)) {\n            // compute axis\n            var distance = this._distanceBetweenEdges(edgeA, directionA, edgeB, directionB, polyhedronA);\n\n            if (distance > 0) return true; // separating axis found\n          }\n        }\n      }\n\n      return false;\n    } // return the most extreme vertex into a given direction\n\n  }, {\n    key: \"_getSupportVertex\",\n    value: function _getSupportVertex(polyhedron, direction) {\n      var maxProjection = -Infinity;\n      var supportVertex = null; // iterate over all polygons\n\n      var vertices = polyhedron.vertices;\n\n      for (var _i100 = 0, l = vertices.length; _i100 < l; _i100++) {\n        var vertex = vertices[_i100];\n        var projection = vertex.dot(direction); // check vertex to find the best support point\n\n        if (projection > maxProjection) {\n          maxProjection = projection;\n          supportVertex = vertex;\n        }\n      }\n\n      return supportVertex;\n    } // returns true if the given edges build a face on the minkowski difference\n\n  }, {\n    key: \"_minkowskiFace\",\n    value: function _minkowskiFace(edgeA, directionA, edgeB, directionB) {\n      // get face normals which define the vertices of the arcs on the gauss map\n      var a = edgeA.polygon.plane.normal;\n      var b = edgeA.twin.polygon.plane.normal;\n      c.copy(edgeB.polygon.plane.normal);\n      d$1.copy(edgeB.twin.polygon.plane.normal); // negate normals c and d to account for minkowski difference\n\n      c.multiplyScalar(-1);\n      d$1.multiplyScalar(-1); // compute triple products\n      // it's not necessary to compute the cross product since edges of convex polyhedron\n      // have same direction as the cross product between their adjacent face normals\n\n      var cba = c.dot(directionA);\n      var dba = d$1.dot(directionA);\n      var adc = a.dot(directionB);\n      var bdc = b.dot(directionB); // check signs of plane test\n\n      return cba * dba < 0 && adc * bdc < 0 && cba * bdc > 0;\n    } // use gauss map to compute the distance between two edges\n\n  }, {\n    key: \"_distanceBetweenEdges\",\n    value: function _distanceBetweenEdges(edgeA, directionA, edgeB, directionB, polyhedronA) {\n      // skip parallel edges\n      if (Math.abs(directionA.dot(directionB)) === 1) return -Infinity; // build plane through one edge\n\n      normal$1.crossVectors(directionA, directionB).normalize(); // ensure normal points from polyhedron A to B\n\n      if (normal$1.dot(v.subVectors(edgeA.vertex, polyhedronA.centroid)) < 0) {\n        normal$1.multiplyScalar(-1);\n      } // compute the distance of any vertex on the other edge to that plane\n      // no need to compute support points => O(1)\n\n\n      return normal$1.dot(v.subVectors(edgeB.vertex, edgeA.vertex));\n    }\n  }]);\n\n  return SAT;\n}();\n/**\r\n* Implementation of a half-edge data structure, also known as\r\n* {@link https://en.wikipedia.org/wiki/Doubly_connected_edge_list Doubly connected edge list}.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar HalfEdge =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new half-edge.\r\n  *\r\n  * @param {Vector3} vertex - The vertex of this half-edge. It represents the head/destination of the respective full edge.\r\n  */\n  function HalfEdge() {\n    var vertex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n\n    _classCallCheck(this, HalfEdge);\n\n    /**\r\n    * The vertex of this half-edge. It represents the head/destination of the respective full edge.\r\n    * @type Vector3\r\n    */\n    this.vertex = vertex;\n    /**\r\n    * A reference to the next half-edge.\r\n    * @type HalfEdge\r\n    */\n\n    this.next = null;\n    /**\r\n    * A reference to the previous half-edge.\r\n    * @type HalfEdge\r\n    */\n\n    this.prev = null;\n    /**\r\n    * A reference to the opponent half-edge.\r\n    * @type HalfEdge\r\n    */\n\n    this.twin = null;\n    /**\r\n    * A reference to its polygon/face.\r\n    * @type Polygon\r\n    */\n\n    this.polygon = null;\n  }\n  /**\r\n  * Returns the tail of this half-edge. That's a reference to the previous\r\n  * half-edge vertex.\r\n  *\r\n  * @return {Vector3} The tail vertex.\r\n  */\n\n\n  _createClass(HalfEdge, [{\n    key: \"tail\",\n    value: function tail() {\n      return this.prev ? this.prev.vertex : null;\n    }\n    /**\r\n    * Returns the head of this half-edge. That's a reference to the own vertex.\r\n    *\r\n    * @return {Vector3} The head vertex.\r\n    */\n\n  }, {\n    key: \"head\",\n    value: function head() {\n      return this.vertex;\n    }\n    /**\r\n    * Computes the length of this half-edge.\r\n    *\r\n    * @return {Number} The length of this half-edge.\r\n    */\n\n  }, {\n    key: \"length\",\n    value: function length() {\n      var tail = this.tail();\n      var head = this.head();\n\n      if (tail !== null) {\n        return tail.distanceTo(head);\n      }\n\n      return -1;\n    }\n    /**\r\n    * Computes the squared length of this half-edge.\r\n    *\r\n    * @return {Number} The squared length of this half-edge.\r\n    */\n\n  }, {\n    key: \"squaredLength\",\n    value: function squaredLength() {\n      var tail = this.tail();\n      var head = this.head();\n\n      if (tail !== null) {\n        return tail.squaredDistanceTo(head);\n      }\n\n      return -1;\n    }\n    /**\r\n    * Links the given opponent half edge with this one.\r\n    *\r\n    * @param {HalfEdge} edge - The opponent edge to link.\r\n    * @return {HalfEdge} A reference to this half edge.\r\n    */\n\n  }, {\n    key: \"linkOpponent\",\n    value: function linkOpponent(edge) {\n      this.twin = edge;\n      edge.twin = this;\n      return this;\n    }\n    /**\r\n    * Computes the direction of this half edge. The method assumes the half edge\r\n    * has a valid reference to a previous half edge.\r\n    *\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"getDirection\",\n    value: function getDirection(result) {\n      return result.subVectors(this.vertex, this.prev.vertex).normalize();\n    }\n  }]);\n\n  return HalfEdge;\n}();\n/**\r\n* Class for representing a planar polygon with an arbitrary amount of edges.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @author {@link https://github.com/robp94|robp94}\r\n*/\n\n\nvar Polygon =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new polygon.\r\n  */\n  function Polygon() {\n    _classCallCheck(this, Polygon);\n\n    /**\r\n    * The centroid of this polygon.\r\n    * @type Vector3\r\n    */\n    this.centroid = new Vector3();\n    /**\r\n    * A reference to the first half-edge of this polygon.\r\n    * @type HalfEdge\r\n    */\n\n    this.edge = null;\n    /**\r\n    * A plane abstraction of this polygon.\r\n    * @type Plane\r\n    */\n\n    this.plane = new Plane();\n  }\n  /**\r\n  * Creates the polygon based on the given array of points in 3D space.\r\n  * The method assumes the contour (the sequence of points) is defined\r\n  * in CCW order.\r\n  *\r\n  * @param {Array} points - The array of points.\r\n  * @return {Polygon} A reference to this polygon.\r\n  */\n\n\n  _createClass(Polygon, [{\n    key: \"fromContour\",\n    value: function fromContour(points) {\n      var edges = new Array();\n\n      if (points.length < 3) {\n        Logger.error('YUKA.Polygon: Unable to create polygon from contour. It needs at least three points.');\n        return this;\n      }\n\n      for (var _i101 = 0, l = points.length; _i101 < l; _i101++) {\n        var edge = new HalfEdge(points[_i101]);\n        edges.push(edge);\n      } // link edges\n\n\n      for (var _i102 = 0, _l12 = edges.length; _i102 < _l12; _i102++) {\n        var current = void 0,\n            prev = void 0,\n            next = void 0;\n\n        if (_i102 === 0) {\n          current = edges[_i102];\n          prev = edges[_l12 - 1];\n          next = edges[_i102 + 1];\n        } else if (_i102 === _l12 - 1) {\n          current = edges[_i102];\n          prev = edges[_i102 - 1];\n          next = edges[0];\n        } else {\n          current = edges[_i102];\n          prev = edges[_i102 - 1];\n          next = edges[_i102 + 1];\n        }\n\n        current.prev = prev;\n        current.next = next;\n        current.polygon = this;\n      } //\n\n\n      this.edge = edges[0]; //\n\n      this.plane.fromCoplanarPoints(points[0], points[1], points[2]);\n      return this;\n    }\n    /**\r\n    * Computes the centroid for this polygon.\r\n    *\r\n    * @return {Polygon} A reference to this polygon.\r\n    */\n\n  }, {\n    key: \"computeCentroid\",\n    value: function computeCentroid() {\n      var centroid = this.centroid;\n      var edge = this.edge;\n      var count = 0;\n      centroid.set(0, 0, 0);\n\n      do {\n        centroid.add(edge.vertex);\n        count++;\n        edge = edge.next;\n      } while (edge !== this.edge);\n\n      centroid.divideScalar(count);\n      return this;\n    }\n    /**\r\n    * Returns true if the polygon contains the given point.\r\n    *\r\n    * @param {Vector3} point - The point to test.\r\n    * @param {Number} epsilon - A tolerance value.\r\n    * @return {Boolean} Whether this polygon contain the given point or not.\r\n    */\n\n  }, {\n    key: \"contains\",\n    value: function contains(point) {\n      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-3;\n      var plane = this.plane;\n      var edge = this.edge; // convex test\n\n      do {\n        var _v = edge.tail();\n\n        var _v2 = edge.head();\n\n        if (leftOn(_v, _v2, point) === false) {\n          return false;\n        }\n\n        edge = edge.next;\n      } while (edge !== this.edge); // ensure the given point lies within a defined tolerance range\n\n\n      var distance = plane.distanceToPoint(point);\n\n      if (Math.abs(distance) > epsilon) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\r\n    * Returns true if the polygon is convex.\r\n    *\r\n    * @param {Boolean} ccw - Whether the winding order is CCW or not.\r\n    * @return {Boolean} Whether this polygon is convex or not.\r\n    */\n\n  }, {\n    key: \"convex\",\n    value: function convex() {\n      var ccw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var edge = this.edge;\n\n      do {\n        var _v3 = edge.tail();\n\n        var _v4 = edge.head();\n\n        var _v5 = edge.next.head();\n\n        if (ccw) {\n          if (leftOn(_v3, _v4, _v5) === false) return false;\n        } else {\n          if (leftOn(_v5, _v4, _v3) === false) return false;\n        }\n\n        edge = edge.next;\n      } while (edge !== this.edge);\n\n      return true;\n    }\n    /**\r\n    * Returns true if the polygon is coplanar.\r\n    *\r\n    * @param {Number} epsilon - A tolerance value.\r\n    * @return {Boolean} Whether this polygon is coplanar or not.\r\n    */\n\n  }, {\n    key: \"coplanar\",\n    value: function coplanar() {\n      var epsilon = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1e-3;\n      var plane = this.plane;\n      var edge = this.edge;\n\n      do {\n        var distance = plane.distanceToPoint(edge.vertex);\n\n        if (Math.abs(distance) > epsilon) {\n          return false;\n        }\n\n        edge = edge.next;\n      } while (edge !== this.edge);\n\n      return true;\n    }\n    /**\r\n    * Computes the signed distance from the given 3D vector to this polygon. The method\r\n    * uses the polygon's plane abstraction in order to compute this value.\r\n    *\r\n    * @param {Vector3} point - A point in 3D space.\r\n    * @return {Number} The signed distance from the given point to this polygon.\r\n    */\n\n  }, {\n    key: \"distanceToPoint\",\n    value: function distanceToPoint(point) {\n      return this.plane.distanceToPoint(point);\n    }\n    /**\r\n    * Determines the contour (sequence of points) of this polygon and\r\n    * stores the result in the given array.\r\n    *\r\n    * @param {Array} result - The result array.\r\n    * @return {Array} The result array.\r\n    */\n\n  }, {\n    key: \"getContour\",\n    value: function getContour(result) {\n      var edge = this.edge;\n      result.length = 0;\n\n      do {\n        result.push(edge.vertex);\n        edge = edge.next;\n      } while (edge !== this.edge);\n\n      return result;\n    }\n  }]);\n\n  return Polygon;\n}(); // from the book \"Computational Geometry in C, Joseph O'Rourke\"\n\n\nfunction leftOn(a, b, c) {\n  return MathUtils.area(a, b, c) >= 0;\n}\n/**\r\n* Base class for polyhedra. It is primarily designed for the internal usage in Yuka.\r\n* Objects of this class are always build up from faces. The edges, vertices and\r\n* the polyhedron's centroid have to be derived from a valid face definition with the\r\n* respective methods.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar Polyhedron =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new polyhedron.\r\n  */\n  function Polyhedron() {\n    _classCallCheck(this, Polyhedron);\n\n    /**\r\n    * The faces of this polyhedron.\r\n    * @type Array\r\n    */\n    this.faces = new Array();\n    /**\r\n    * A list of unique edges (no opponent half edges).\r\n    * @type Array\r\n    */\n\n    this.edges = new Array();\n    /**\r\n    * A list of unique vertices.\r\n    * @type Array\r\n    */\n\n    this.vertices = new Array();\n    /**\r\n    * The centroid of this polyhedron.\r\n    * @type Vector3\r\n    */\n\n    this.centroid = new Vector3();\n  }\n  /**\r\n  * Computes the centroid of this polyhedron. Assumes its faces\r\n  * have valid centroids.\r\n  *\r\n  * @return {Polyhedron} A reference to this polyhedron.\r\n  */\n\n\n  _createClass(Polyhedron, [{\n    key: \"computeCentroid\",\n    value: function computeCentroid() {\n      var centroid = this.centroid;\n      var faces = this.faces;\n      centroid.set(0, 0, 0);\n\n      for (var _i103 = 0, l = faces.length; _i103 < l; _i103++) {\n        var face = faces[_i103];\n        centroid.add(face.centroid);\n      }\n\n      centroid.divideScalar(faces.length);\n      return this;\n    }\n    /**\r\n    * Computes unique vertices of this polyhedron. Assumes {@link Polyhedron#faces}\r\n    * is properly set.\r\n    *\r\n    * @return {Polyhedron} A reference to this polyhedron.\r\n    */\n\n  }, {\n    key: \"computeUniqueVertices\",\n    value: function computeUniqueVertices() {\n      var faces = this.faces;\n      var vertices = this.vertices;\n      vertices.length = 0;\n      var uniqueVertices = new Set(); // iterate over all faces\n\n      for (var _i104 = 0, l = faces.length; _i104 < l; _i104++) {\n        var face = faces[_i104];\n        var edge = face.edge; // process all edges of a faces\n\n        do {\n          // add vertex to set (assuming half edges share unique vertices)\n          uniqueVertices.add(edge.vertex);\n          edge = edge.next;\n        } while (edge !== face.edge);\n      }\n\n      vertices.push.apply(vertices, _toConsumableArray(uniqueVertices));\n      return this;\n    }\n    /**\r\n    * Computes unique edges of this polyhedron. Assumes {@link Polyhedron#faces}\r\n    * is properly set.\r\n    *\r\n    * @return {Polyhedron} A reference to this polyhedron.\r\n    */\n\n  }, {\n    key: \"computeUniqueEdges\",\n    value: function computeUniqueEdges() {\n      var faces = this.faces;\n      var edges = this.edges;\n      edges.length = 0; // iterate over all faces\n\n      for (var _i105 = 0, l = faces.length; _i105 < l; _i105++) {\n        var face = faces[_i105];\n        var edge = face.edge; // process all edges of a faces\n\n        do {\n          // only add the edge if the twin was not added before\n          if (edges.includes(edge.twin) === false) {\n            edges.push(edge);\n          }\n\n          edge = edge.next;\n        } while (edge !== face.edge);\n      }\n\n      return this;\n    }\n    /**\r\n    * Configures this polyhedron so it does represent the given AABB.\r\n    *\r\n    * @return {Polyhedron} A reference to this polyhedron.\r\n    */\n\n  }, {\n    key: \"fromAABB\",\n    value: function fromAABB(aabb) {\n      var _this$vertices;\n\n      this.faces.length = 0;\n      this.vertices.length = 0;\n      var min = aabb.min;\n      var max = aabb.max;\n      var vertices = [new Vector3(max.x, max.y, max.z), new Vector3(max.x, max.y, min.z), new Vector3(max.x, min.y, max.z), new Vector3(max.x, min.y, min.z), new Vector3(min.x, max.y, max.z), new Vector3(min.x, max.y, min.z), new Vector3(min.x, min.y, max.z), new Vector3(min.x, min.y, min.z)];\n\n      (_this$vertices = this.vertices).push.apply(_this$vertices, vertices);\n\n      var sideTop = new Polygon().fromContour([vertices[4], vertices[0], vertices[1], vertices[5]]);\n      var sideRight = new Polygon().fromContour([vertices[2], vertices[3], vertices[1], vertices[0]]);\n      var sideFront = new Polygon().fromContour([vertices[6], vertices[2], vertices[0], vertices[4]]);\n      var sideBack = new Polygon().fromContour([vertices[3], vertices[7], vertices[5], vertices[1]]);\n      var sideBottom = new Polygon().fromContour([vertices[3], vertices[2], vertices[6], vertices[7]]);\n      var sideLeft = new Polygon().fromContour([vertices[7], vertices[6], vertices[4], vertices[5]]); // link edges\n\n      sideTop.edge.linkOpponent(sideLeft.edge.prev);\n      sideTop.edge.next.linkOpponent(sideFront.edge.prev);\n      sideTop.edge.next.next.linkOpponent(sideRight.edge.prev);\n      sideTop.edge.prev.linkOpponent(sideBack.edge.prev);\n      sideBottom.edge.linkOpponent(sideBack.edge.next);\n      sideBottom.edge.next.linkOpponent(sideRight.edge.next);\n      sideBottom.edge.next.next.linkOpponent(sideFront.edge.next);\n      sideBottom.edge.prev.linkOpponent(sideLeft.edge.next);\n      sideLeft.edge.linkOpponent(sideBack.edge.next.next);\n      sideBack.edge.linkOpponent(sideRight.edge.next.next);\n      sideRight.edge.linkOpponent(sideFront.edge.next.next);\n      sideFront.edge.linkOpponent(sideLeft.edge.next.next); //\n\n      this.faces.push(sideTop, sideRight, sideFront, sideBack, sideBottom, sideLeft); // compute centroids\n\n      sideTop.computeCentroid();\n      sideRight.computeCentroid();\n      sideFront.computeCentroid();\n      sideBack.computeCentroid();\n      sideBottom.computeCentroid();\n      sideLeft.computeCentroid();\n      aabb.getCenter(this.centroid); //\n\n      this.computeUniqueEdges();\n      return this;\n    }\n  }]);\n\n  return Polyhedron;\n}();\n\nvar line = new LineSegment();\nvar plane$1 = new Plane();\nvar closestPoint = new Vector3();\nvar up = new Vector3(0, 1, 0);\nvar sat = new SAT();\nvar polyhedronAABB;\n/**\r\n* Class representing a convex hull. This is an implementation of the Quickhull algorithm\r\n* based on the presentation {@link http://media.steampowered.com/apps/valve/2014/DirkGregorius_ImplementingQuickHull.pdf Implementing QuickHull}\r\n* by Dirk Gregorius (Valve Software) from GDC 2014. The algorithm has an average runtime\r\n* complexity of O(nlog(n)), whereas in the worst case it takes O(n).\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments Polyhedron\r\n*/\n\nvar ConvexHull =\n/*#__PURE__*/\nfunction (_Polyhedron) {\n  _inherits(ConvexHull, _Polyhedron);\n\n  /**\r\n  * Constructs a new convex hull.\r\n  */\n  function ConvexHull() {\n    var _this27;\n\n    _classCallCheck(this, ConvexHull);\n\n    _this27 = _possibleConstructorReturn(this, _getPrototypeOf(ConvexHull).call(this)); // tolerance value for various (float) compare operations\n\n    _this27._tolerance = -1; // this array represents the vertices which will be enclosed by the convex hull\n\n    _this27._vertices = new Array(); // two doubly linked lists for easier vertex processing\n\n    _this27._assigned = new VertexList();\n    _this27._unassigned = new VertexList(); // this array holds the new faces generated in a single iteration of the algorithm\n\n    _this27._newFaces = new Array();\n    return _this27;\n  }\n  /**\r\n  * Returns true if the given point is inside this convex hull.\r\n  *\r\n  * @param {Vector3} point - A point in 3D space.\r\n  * @return {Boolean} Whether the given point is inside this convex hull or not.\r\n  */\n\n\n  _createClass(ConvexHull, [{\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      var faces = this.faces; // use the internal plane abstraction of each face in order to test\n      // on what half space the point lies\n\n      for (var _i106 = 0, l = faces.length; _i106 < l; _i106++) {\n        // if the signed distance is greater than the tolerance value, the point\n        // is outside and we can stop processing\n        if (faces[_i106].distanceToPoint(point) > this._tolerance) return false;\n      }\n\n      return true;\n    }\n    /**\r\n    * Returns true if this convex hull intersects with the given AABB.\r\n    *\r\n    * @param {AABB} aabb - The AABB to test.\r\n    * @return {Boolean} Whether this convex hull intersects with the given AABB or not.\r\n    */\n\n  }, {\n    key: \"intersectsAABB\",\n    value: function intersectsAABB(aabb) {\n      if (polyhedronAABB === undefined) {\n        // lazily create the (proxy) polyhedron if necessary\n        polyhedronAABB = new Polyhedron().fromAABB(aabb);\n      } else {\n        // otherwise just ensure up-to-date vertex data.\n        // the topology of the polyhedron is equal for all AABBs\n        var min = aabb.min;\n        var max = aabb.max;\n        var vertices = polyhedronAABB.vertices;\n        vertices[0].set(max.x, max.y, max.z);\n        vertices[1].set(max.x, max.y, min.z);\n        vertices[2].set(max.x, min.y, max.z);\n        vertices[3].set(max.x, min.y, min.z);\n        vertices[4].set(min.x, max.y, max.z);\n        vertices[5].set(min.x, max.y, min.z);\n        vertices[6].set(min.x, min.y, max.z);\n        vertices[7].set(min.x, min.y, min.z);\n        aabb.getCenter(polyhedronAABB.centroid);\n      }\n\n      return sat.intersects(this, polyhedronAABB);\n    }\n    /**\r\n    * Returns true if this convex hull intersects with the given one.\r\n    *\r\n    * @param {ConvexHull} convexHull - The convex hull to test.\r\n    * @return {Boolean} Whether this convex hull intersects with the given one or not.\r\n    */\n\n  }, {\n    key: \"intersectsConvexHull\",\n    value: function intersectsConvexHull(convexHull) {\n      return sat.intersects(this, convexHull);\n    }\n    /**\r\n    * Computes a convex hull that encloses the given set of points. The computation requires\r\n    * at least four points.\r\n    *\r\n    * @param {Array} points - An array of 3D vectors representing points in 3D space.\r\n    * @return {ConvexHull} A reference to this convex hull.\r\n    */\n\n  }, {\n    key: \"fromPoints\",\n    value: function fromPoints(points) {\n      if (points.length < 4) {\n        Logger.error('YUKA.ConvexHull: The given points array needs at least four points.');\n        return this;\n      } // wrap all points into the internal vertex data structure\n\n\n      for (var _i107 = 0, l = points.length; _i107 < l; _i107++) {\n        this._vertices.push(new Vertex(points[_i107]));\n      } // generate the convex hull\n\n\n      this._generate();\n\n      return this;\n    } // private API\n    // adds a single face to the convex hull by connecting it with the respective horizon edge\n\n  }, {\n    key: \"_addAdjoiningFace\",\n    value: function _addAdjoiningFace(vertex, horizonEdge) {\n      // all the half edges are created in ccw order thus the face is always pointing outside the hull\n      var face = new Face(vertex.point, horizonEdge.prev.vertex, horizonEdge.vertex);\n      this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n      face.getEdge(-1).linkOpponent(horizonEdge.twin);\n      return face.getEdge(0); // the half edge whose vertex is the given one\n    } // adds new faces by connecting the horizon with the new point of the convex hull\n\n  }, {\n    key: \"_addNewFaces\",\n    value: function _addNewFaces(vertex, horizon) {\n      this._newFaces = [];\n      var firstSideEdge = null;\n      var previousSideEdge = null;\n\n      for (var _i108 = 0, l = horizon.length; _i108 < l; _i108++) {\n        // returns the right side edge\n        var sideEdge = this._addAdjoiningFace(vertex, horizon[_i108]);\n\n        if (firstSideEdge === null) {\n          firstSideEdge = sideEdge;\n        } else {\n          // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n          sideEdge.next.linkOpponent(previousSideEdge);\n        }\n\n        this._newFaces.push(sideEdge.polygon);\n\n        previousSideEdge = sideEdge;\n      } // perform final join of new faces\n\n\n      firstSideEdge.next.linkOpponent(previousSideEdge);\n      return this;\n    } // assigns a single vertex to the given face. that means this face can \"see\"\n    // the vertex and its distance to the vertex is greater than all other faces\n\n  }, {\n    key: \"_addVertexToFace\",\n    value: function _addVertexToFace(vertex, face) {\n      vertex.face = face;\n\n      if (face.outside === null) {\n        this._assigned.append(vertex);\n\n        face.outside = vertex;\n      } else {\n        this._assigned.insertAfter(face.outside, vertex);\n      }\n\n      return this;\n    } // the base iteration of the algorithm. adds a new vertex to the convex hull by\n    // connecting faces from the horizon with it.\n\n  }, {\n    key: \"_addVertexToHull\",\n    value: function _addVertexToHull(vertex) {\n      var horizon = [];\n\n      this._unassigned.clear();\n\n      this._computeHorizon(vertex.point, null, vertex.face, horizon);\n\n      this._addNewFaces(vertex, horizon); // reassign 'unassigned' vertices to the new faces\n\n\n      this._resolveUnassignedPoints(this._newFaces);\n\n      return this;\n    } // frees memory by resetting internal data structures\n\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      this._vertices.length = 0;\n\n      this._assigned.clear();\n\n      this._unassigned.clear();\n\n      this._newFaces.length = 0;\n      return this;\n    } // computes the initial hull of the algorithm. it's a tetrahedron created\n    // with the extreme vertices of the given set of points\n\n  }, {\n    key: \"_computeInitialHull\",\n    value: function _computeInitialHull() {\n      var v0, v1, v2, v3;\n      var vertices = this._vertices;\n\n      var extremes = this._computeExtremes();\n\n      var min = extremes.min;\n      var max = extremes.max; // 1. Find the two points 'p0' and 'p1' with the greatest 1d separation\n      // (max.x - min.x)\n      // (max.y - min.y)\n      // (max.z - min.z)\n      // check x\n\n      var distance, maxDistance;\n      maxDistance = max.x.point.x - min.x.point.x;\n      v0 = min.x;\n      v1 = max.x; // check y\n\n      distance = max.y.point.y - min.y.point.y;\n\n      if (distance > maxDistance) {\n        v0 = min.y;\n        v1 = max.y;\n        maxDistance = distance;\n      } // check z\n\n\n      distance = max.z.point.z - min.z.point.z;\n\n      if (distance > maxDistance) {\n        v0 = min.z;\n        v1 = max.z;\n      } // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n\n      maxDistance = -Infinity;\n      line.set(v0.point, v1.point);\n\n      for (var _i109 = 0, l = vertices.length; _i109 < l; _i109++) {\n        var vertex = vertices[_i109];\n\n        if (vertex !== v0 && vertex !== v1) {\n          line.closestPointToPoint(vertex.point, true, closestPoint);\n          distance = closestPoint.squaredDistanceTo(vertex.point);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            v2 = vertex;\n          }\n        }\n      } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\n      maxDistance = -Infinity;\n      plane$1.fromCoplanarPoints(v0.point, v1.point, v2.point);\n\n      for (var _i110 = 0, _l13 = vertices.length; _i110 < _l13; _i110++) {\n        var _vertex = vertices[_i110];\n\n        if (_vertex !== v0 && _vertex !== v1 && _vertex !== v2) {\n          distance = Math.abs(plane$1.distanceToPoint(_vertex.point));\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            v3 = _vertex;\n          }\n        }\n      } // handle case where all points lie in one plane\n\n\n      if (plane$1.distanceToPoint(v3.point) === 0) {\n        throw 'ERROR: YUKA.ConvexHull: All extreme points lie in a single plane. Unable to compute convex hull.';\n      } // build initial tetrahedron\n\n\n      var faces = this.faces;\n\n      if (plane$1.distanceToPoint(v3.point) < 0) {\n        // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n        faces.push(new Face(v0.point, v1.point, v2.point), new Face(v3.point, v1.point, v0.point), new Face(v3.point, v2.point, v1.point), new Face(v3.point, v0.point, v2.point)); // set the twin edge\n        // join face[ i ] i > 0, with the first face\n\n        faces[1].getEdge(2).linkOpponent(faces[0].getEdge(1));\n        faces[2].getEdge(2).linkOpponent(faces[0].getEdge(2));\n        faces[3].getEdge(2).linkOpponent(faces[0].getEdge(0)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n        faces[1].getEdge(1).linkOpponent(faces[2].getEdge(0));\n        faces[2].getEdge(1).linkOpponent(faces[3].getEdge(0));\n        faces[3].getEdge(1).linkOpponent(faces[1].getEdge(0));\n      } else {\n        // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n        faces.push(new Face(v0.point, v2.point, v1.point), new Face(v3.point, v0.point, v1.point), new Face(v3.point, v1.point, v2.point), new Face(v3.point, v2.point, v0.point)); // set the twin edge\n        // join face[ i ] i > 0, with the first face\n\n        faces[1].getEdge(2).linkOpponent(faces[0].getEdge(0));\n        faces[2].getEdge(2).linkOpponent(faces[0].getEdge(2));\n        faces[3].getEdge(2).linkOpponent(faces[0].getEdge(1)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n        faces[1].getEdge(0).linkOpponent(faces[2].getEdge(1));\n        faces[2].getEdge(0).linkOpponent(faces[3].getEdge(1));\n        faces[3].getEdge(0).linkOpponent(faces[1].getEdge(1));\n      } // initial assignment of vertices to the faces of the tetrahedron\n\n\n      for (var _i111 = 0, _l14 = vertices.length; _i111 < _l14; _i111++) {\n        var _vertex2 = vertices[_i111];\n\n        if (_vertex2 !== v0 && _vertex2 !== v1 && _vertex2 !== v2 && _vertex2 !== v3) {\n          maxDistance = this._tolerance;\n          var maxFace = null;\n\n          for (var j = 0; j < 4; j++) {\n            distance = faces[j].distanceToPoint(_vertex2.point);\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              maxFace = faces[j];\n            }\n          }\n\n          if (maxFace !== null) {\n            this._addVertexToFace(_vertex2, maxFace);\n          }\n        }\n      }\n\n      return this;\n    } // computes the extreme vertices of used to compute the initial convex hull\n\n  }, {\n    key: \"_computeExtremes\",\n    value: function _computeExtremes() {\n      var min = new Vector3(Infinity, Infinity, Infinity);\n      var max = new Vector3(-Infinity, -Infinity, -Infinity);\n      var minVertices = {\n        x: null,\n        y: null,\n        z: null\n      };\n      var maxVertices = {\n        x: null,\n        y: null,\n        z: null\n      }; // compute the min/max points on all six directions\n\n      for (var _i112 = 0, l = this._vertices.length; _i112 < l; _i112++) {\n        var vertex = this._vertices[_i112];\n        var point = vertex.point; // update the min coordinates\n\n        if (point.x < min.x) {\n          min.x = point.x;\n          minVertices.x = vertex;\n        }\n\n        if (point.y < min.y) {\n          min.y = point.y;\n          minVertices.y = vertex;\n        }\n\n        if (point.z < min.z) {\n          min.z = point.z;\n          minVertices.z = vertex;\n        } // update the max coordinates\n\n\n        if (point.x > max.x) {\n          max.x = point.x;\n          maxVertices.x = vertex;\n        }\n\n        if (point.y > max.y) {\n          max.y = point.y;\n          maxVertices.y = vertex;\n        }\n\n        if (point.z > max.z) {\n          max.z = point.z;\n          maxVertices.z = vertex;\n        }\n      } // use min/max vectors to compute an optimal epsilon\n\n\n      this._tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n      return {\n        min: minVertices,\n        max: maxVertices\n      };\n    } // computes the horizon, an array of edges enclosing the faces that are able\n    // to see the new vertex\n\n  }, {\n    key: \"_computeHorizon\",\n    value: function _computeHorizon(eyePoint, crossEdge, face, horizon) {\n      if (face.outside) {\n        var startVertex = face.outside; // remove all vertices from the given face\n\n        this._removeAllVerticesFromFace(face); // mark the face vertices to be reassigned to other faces\n\n\n        this._unassigned.appendChain(startVertex);\n      }\n\n      face.active = false;\n      var edge;\n\n      if (crossEdge === null) {\n        edge = crossEdge = face.getEdge(0);\n      } else {\n        // start from the next edge since 'crossEdge' was already analyzed\n        // (actually 'crossEdge.twin' was the edge who called this method recursively)\n        edge = crossEdge.next;\n      }\n\n      do {\n        var twinEdge = edge.twin;\n        var oppositeFace = twinEdge.polygon;\n\n        if (oppositeFace.active) {\n          if (oppositeFace.distanceToPoint(eyePoint) > this._tolerance) {\n            // the opposite face can see the vertex, so proceed with next edge\n            this._computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n          } else {\n            // the opposite face can't see the vertex, so this edge is part of the horizon\n            horizon.push(edge);\n          }\n        }\n\n        edge = edge.next;\n      } while (edge !== crossEdge);\n\n      return this;\n    } // this method controls the basic flow of the algorithm\n\n  }, {\n    key: \"_generate\",\n    value: function _generate() {\n      this.faces.length = 0;\n\n      this._computeInitialHull();\n\n      var vertex;\n\n      while (vertex = this._nextVertexToAdd()) {\n        this._addVertexToHull(vertex);\n      }\n\n      this._updateFaces();\n\n      this._mergeFaces();\n\n      this._reset();\n\n      return this;\n    } // merges faces if the result is still convex and coplanar\n\n  }, {\n    key: \"_mergeFaces\",\n    value: function _mergeFaces() {\n      var faces = this.faces;\n      var edges = this.edges;\n      var cache = {\n        leftPrev: null,\n        leftNext: null,\n        rightPrev: null,\n        rightNext: null\n      }; // gather unique edges and temporarily sort them\n\n      this.computeUniqueEdges();\n      edges.sort(function (a, b) {\n        return b.length() - a.length();\n      }); // process edges from longest to shortest\n\n      for (var _i113 = 0, l = edges.length; _i113 < l; _i113++) {\n        var entry = edges[_i113];\n        var candidate = entry; // cache current references for possible restore\n\n        cache.prev = candidate.prev;\n        cache.next = candidate.next;\n        cache.prevTwin = candidate.twin.prev;\n        cache.nextTwin = candidate.twin.next; // temporarily change the first polygon in order to represent both polygons\n\n        candidate.prev.next = candidate.twin.next;\n        candidate.next.prev = candidate.twin.prev;\n        candidate.twin.prev.next = candidate.next;\n        candidate.twin.next.prev = candidate.prev;\n        var polygon = candidate.polygon;\n        polygon.edge = candidate.prev;\n        var ccw = polygon.plane.normal.dot(up) >= 0;\n\n        if (polygon.convex(ccw) === true && polygon.coplanar(this._tolerance) === true) {\n          // correct polygon reference of all edges\n          var edge = polygon.edge;\n\n          do {\n            edge.polygon = polygon;\n            edge = edge.next;\n          } while (edge !== polygon.edge); // delete obsolete polygon\n\n\n          var index = faces.indexOf(entry.twin.polygon);\n          faces.splice(index, 1);\n        } else {\n          // restore\n          cache.prev.next = candidate;\n          cache.next.prev = candidate;\n          cache.prevTwin.next = candidate.twin;\n          cache.nextTwin.prev = candidate.twin;\n          polygon.edge = candidate;\n        }\n      } // recompute centroid of faces\n\n\n      for (var _i114 = 0, _l15 = faces.length; _i114 < _l15; _i114++) {\n        faces[_i114].computeCentroid();\n      } // compute centroid of convex hull and the final edge and vertex list\n\n\n      this.computeCentroid();\n      this.computeUniqueEdges();\n      this.computeUniqueVertices();\n      return this;\n    } // determines the next vertex that should added to the convex hull\n\n  }, {\n    key: \"_nextVertexToAdd\",\n    value: function _nextVertexToAdd() {\n      var nextVertex = null; // if the 'assigned' list of vertices is empty, no vertices are left\n\n      if (this._assigned.empty() === false) {\n        var maxDistance = 0; // grap the first available vertex and save the respective face\n\n        var vertex = this._assigned.first();\n\n        var face = vertex.face; // now calculate the farthest vertex that face can see\n\n        do {\n          var distance = face.distanceToPoint(vertex.point);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            nextVertex = vertex;\n          }\n\n          vertex = vertex.next;\n        } while (vertex !== null && vertex.face === face);\n      }\n\n      return nextVertex;\n    } // updates the faces array after the computation of the convex hull\n    // it ensures only visible faces are in the result set\n\n  }, {\n    key: \"_updateFaces\",\n    value: function _updateFaces() {\n      var _this$faces;\n\n      var faces = this.faces;\n      var activeFaces = new Array();\n\n      for (var _i115 = 0, l = faces.length; _i115 < l; _i115++) {\n        var face = faces[_i115]; // only respect visible but not deleted or merged faces\n\n        if (face.active) {\n          activeFaces.push(face);\n        }\n      }\n\n      this.faces.length = 0;\n\n      (_this$faces = this.faces).push.apply(_this$faces, activeFaces);\n\n      return this;\n    } // removes all vertices from the given face. necessary when deleting a face\n    // which is necessary when the hull is going to be expanded\n\n  }, {\n    key: \"_removeAllVerticesFromFace\",\n    value: function _removeAllVerticesFromFace(face) {\n      if (face.outside !== null) {\n        // reference to the first and last vertex of this face\n        var firstVertex = face.outside;\n        firstVertex.face = null;\n        var lastVertex = face.outside;\n\n        while (lastVertex.next !== null && lastVertex.next.face === face) {\n          lastVertex = lastVertex.next;\n          lastVertex.face = null;\n        }\n\n        face.outside = null;\n\n        this._assigned.removeChain(firstVertex, lastVertex);\n      }\n\n      return this;\n    } // removes a single vertex from the given face\n\n  }, {\n    key: \"_removeVertexFromFace\",\n    value: function _removeVertexFromFace(vertex, face) {\n      vertex.face = null;\n\n      if (vertex === face.outside) {\n        // fix face.outside link\n        if (vertex.next !== null && vertex.next.face === face) {\n          // face has at least 2 outside vertices, move the 'outside' reference\n          face.outside = vertex.next;\n        } else {\n          // vertex was the only outside vertex that face had\n          face.outside = null;\n        }\n      }\n\n      this._assigned.remove(vertex);\n\n      return this;\n    } // ensure that all unassigned points are reassigned to other faces of the\n    // current convex hull. this method is always executed after the hull was\n    // expanded\n\n  }, {\n    key: \"_resolveUnassignedPoints\",\n    value: function _resolveUnassignedPoints(newFaces) {\n      if (this._unassigned.empty() === false) {\n        var vertex = this._unassigned.first();\n\n        do {\n          // buffer 'next' reference since addVertexToFace() can change it\n          var nextVertex = vertex.next;\n          var maxDistance = this._tolerance;\n          var maxFace = null;\n\n          for (var _i116 = 0, l = newFaces.length; _i116 < l; _i116++) {\n            var face = newFaces[_i116];\n\n            if (face.active) {\n              var distance = face.distanceToPoint(vertex.point);\n\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = face;\n              }\n            }\n          }\n\n          if (maxFace !== null) {\n            this._addVertexToFace(vertex, maxFace);\n          }\n\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n\n      return this;\n    }\n  }]);\n\n  return ConvexHull;\n}(Polyhedron);\n\nvar Face =\n/*#__PURE__*/\nfunction (_Polygon) {\n  _inherits(Face, _Polygon);\n\n  function Face() {\n    var _this28;\n\n    var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n    var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n\n    _classCallCheck(this, Face);\n\n    _this28 = _possibleConstructorReturn(this, _getPrototypeOf(Face).call(this));\n    _this28.outside = null; // reference to a vertex in a vertex list this face can see\n\n    _this28.active = true;\n\n    _this28.fromContour([a, b, c]);\n\n    _this28.computeCentroid();\n\n    return _this28;\n  }\n\n  _createClass(Face, [{\n    key: \"getEdge\",\n    value: function getEdge(i) {\n      var edge = this.edge;\n\n      while (i > 0) {\n        edge = edge.next;\n        i--;\n      }\n\n      while (i < 0) {\n        edge = edge.prev;\n        i++;\n      }\n\n      return edge;\n    }\n  }]);\n\n  return Face;\n}(Polygon); // special data structures for the quick hull implementation\n\n\nvar Vertex = function Vertex() {\n  var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n\n  _classCallCheck(this, Vertex);\n\n  this.point = point;\n  this.prev = null;\n  this.next = null;\n  this.face = null; // the face that is able to see this vertex\n};\n\nvar VertexList =\n/*#__PURE__*/\nfunction () {\n  function VertexList() {\n    _classCallCheck(this, VertexList);\n\n    this.head = null;\n    this.tail = null;\n  }\n\n  _createClass(VertexList, [{\n    key: \"first\",\n    value: function first() {\n      return this.head;\n    }\n  }, {\n    key: \"last\",\n    value: function last() {\n      return this.tail;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      return this;\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(target, vertex) {\n      vertex.prev = target;\n      vertex.next = target.next;\n\n      if (!vertex.next) {\n        this.tail = vertex;\n      } else {\n        vertex.next.prev = vertex;\n      }\n\n      target.next = vertex;\n      return this;\n    }\n  }, {\n    key: \"append\",\n    value: function append(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n\n      vertex.prev = this.tail;\n      vertex.next = null; // the tail has no subsequent vertex\n\n      this.tail = vertex;\n      return this;\n    }\n  }, {\n    key: \"appendChain\",\n    value: function appendChain(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n\n      vertex.prev = this.tail;\n\n      while (vertex.next !== null) {\n        vertex = vertex.next;\n      }\n\n      this.tail = vertex;\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(vertex) {\n      if (vertex.prev === null) {\n        this.head = vertex.next;\n      } else {\n        vertex.prev.next = vertex.next;\n      }\n\n      if (vertex.next === null) {\n        this.tail = vertex.prev;\n      } else {\n        vertex.next.prev = vertex.prev;\n      }\n\n      vertex.prev = null;\n      vertex.next = null;\n      return this;\n    }\n  }, {\n    key: \"removeChain\",\n    value: function removeChain(a, b) {\n      if (a.prev === null) {\n        this.head = b.next;\n      } else {\n        a.prev.next = b.next;\n      }\n\n      if (b.next === null) {\n        this.tail = a.prev;\n      } else {\n        b.next.prev = a.prev;\n      }\n\n      a.prev = null;\n      b.next = null;\n      return this;\n    }\n  }, {\n    key: \"empty\",\n    value: function empty() {\n      return this.head === null;\n    }\n  }]);\n\n  return VertexList;\n}();\n\nvar eigenDecomposition = {\n  unitary: new Matrix3(),\n  diagonal: new Matrix3()\n};\nvar a = {\n  c: null,\n  // center\n  u: [new Vector3(), new Vector3(), new Vector3()],\n  // basis vectors\n  e: [] // half width\n\n};\nvar b = {\n  c: null,\n  // center\n  u: [new Vector3(), new Vector3(), new Vector3()],\n  // basis vectors\n  e: [] // half width\n\n};\nvar R = [[], [], []];\nvar AbsR = [[], [], []];\nvar t = [];\nvar xAxis$1 = new Vector3();\nvar yAxis$1 = new Vector3();\nvar zAxis$1 = new Vector3();\nvar v1$4 = new Vector3();\nvar closestPoint$1 = new Vector3();\n/**\r\n* Class representing an oriented bounding box (OBB). Similar to an AABB, it's a\r\n* rectangular block but with an arbitrary orientation. When using {@link OBB#fromPoints},\r\n* the implementation tries to provide a tight-fitting oriented bounding box. In\r\n* many cases, the result is better than an AABB or bounding sphere but worse than a\r\n* convex hull. However, it's more efficient to work with OBBs compared to convex hulls.\r\n* In general, OBB's are a good compromise between performance and tightness.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar OBB =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new OBB with the given values.\r\n  *\r\n  * @param {Vector3} center - The center of this OBB.\r\n  * @param {Vector3} halfSizes - The half sizes of the OBB (defines its width, height and depth).\r\n  * @param {Quaternion} rotation - The rotation of this OBB.\r\n  */\n  function OBB() {\n    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var halfSizes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n    var rotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Matrix3();\n\n    _classCallCheck(this, OBB);\n\n    /**\r\n    * The center of this OBB.\r\n    * @type Vector3\r\n    */\n    this.center = center;\n    /**\r\n    * The half sizes of the OBB (defines its width, height and depth).\r\n    * @type Vector3\r\n    */\n\n    this.halfSizes = halfSizes;\n    /**\r\n    * The rotation of this OBB.\r\n    * @type Matrix3\r\n    */\n\n    this.rotation = rotation;\n  }\n  /**\r\n  * Sets the given values to this OBB.\r\n  *\r\n  * @param {Vector3} center - The center of this OBB\r\n  * @param {Vector3} halfSizes - The half sizes of the OBB (defines its width, height and depth).\r\n  * @param {Quaternion} rotation - The rotation of this OBB.\r\n  * @return {OBB} A reference to this OBB.\r\n  */\n\n\n  _createClass(OBB, [{\n    key: \"set\",\n    value: function set(center, halfSizes, rotation) {\n      this.center = center;\n      this.halfSizes = halfSizes;\n      this.rotation = rotation;\n      return this;\n    }\n    /**\r\n    * Copies all values from the given OBB to this OBB.\r\n    *\r\n    * @param {OBB} obb - The OBB to copy.\r\n    * @return {OBB} A reference to this OBB.\r\n    */\n\n  }, {\n    key: \"copy\",\n    value: function copy(obb) {\n      this.center.copy(obb.center);\n      this.halfSizes.copy(obb.halfSizes);\n      this.rotation.copy(obb.rotation);\n      return this;\n    }\n    /**\r\n    * Creates a new OBB and copies all values from this OBB.\r\n    *\r\n    * @return {OBB} A new OBB.\r\n    */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n    /**\r\n    * Computes the size (width, height, depth) of this OBB and stores it into the given vector.\r\n    *\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"getSize\",\n    value: function getSize(result) {\n      return result.copy(this.halfSizes).multiplyScalar(2);\n    }\n    /**\r\n    * Ensures the given point is inside this OBB and stores\r\n    * the result in the given vector.\r\n    *\r\n    * Reference: Closest Point on OBB to Point in Real-Time Collision Detection\r\n    * by Christer Ericson (chapter 5.1.4)\r\n    *\r\n    * @param {Vector3} point - A point in 3D space.\r\n    * @param {Vector3} result - The result vector.\r\n    * @return {Vector3} The result vector.\r\n    */\n\n  }, {\n    key: \"clampPoint\",\n    value: function clampPoint(point, result) {\n      var halfSizes = this.halfSizes;\n      v1$4.subVectors(point, this.center);\n      this.rotation.extractBasis(xAxis$1, yAxis$1, zAxis$1); // start at the center position of the OBB\n\n      result.copy(this.center); // project the target onto the OBB axes and walk towards that point\n\n      var x = MathUtils.clamp(v1$4.dot(xAxis$1), -halfSizes.x, halfSizes.x);\n      result.add(xAxis$1.multiplyScalar(x));\n      var y = MathUtils.clamp(v1$4.dot(yAxis$1), -halfSizes.y, halfSizes.y);\n      result.add(yAxis$1.multiplyScalar(y));\n      var z = MathUtils.clamp(v1$4.dot(zAxis$1), -halfSizes.z, halfSizes.z);\n      result.add(zAxis$1.multiplyScalar(z));\n      return result;\n    }\n    /**\r\n    * Returns true if the given point is inside this OBB.\r\n    *\r\n    * @param {Vector3} point - A point in 3D space.\r\n    * @return {Boolean} Whether the given point is inside this OBB or not.\r\n    */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      v1$4.subVectors(point, this.center);\n      this.rotation.extractBasis(xAxis$1, yAxis$1, zAxis$1); // project v1 onto each axis and check if these points lie inside the OBB\n\n      return Math.abs(v1$4.dot(xAxis$1)) <= this.halfSizes.x && Math.abs(v1$4.dot(yAxis$1)) <= this.halfSizes.y && Math.abs(v1$4.dot(zAxis$1)) <= this.halfSizes.z;\n    }\n    /**\r\n    * Returns true if the given AABB intersects this OBB.\r\n    *\r\n    * @param {AABB} aabb - The AABB to test.\r\n    * @return {Boolean} The result of the intersection test.\r\n    */\n\n  }, {\n    key: \"intersectsAABB\",\n    value: function intersectsAABB(aabb) {\n      return this.intersectsOBB(obb.fromAABB(aabb));\n    }\n    /**\r\n    * Returns true if the given bounding sphere intersects this OBB.\r\n    *\r\n    * @param {BoundingSphere} sphere - The bounding sphere to test.\r\n    * @return {Boolean} The result of the intersection test.\r\n    */\n\n  }, {\n    key: \"intersectsBoundingSphere\",\n    value: function intersectsBoundingSphere(sphere) {\n      // find the point on the OBB closest to the sphere center\n      this.clampPoint(sphere.center, closestPoint$1); // if that point is inside the sphere, the OBB and sphere intersect\n\n      return closestPoint$1.squaredDistanceTo(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    /**\r\n    * Returns true if the given OBB intersects this OBB.\r\n    *\r\n    * Reference: OBB-OBB Intersection in Real-Time Collision Detection\r\n    * by Christer Ericson (chapter 4.4.1)\r\n    *\r\n    * @param {OBB} obb - The OBB to test.\r\n    * @param {Number} epsilon - The epsilon (tolerance) value.\r\n    * @return {Boolean} The result of the intersection test.\r\n    */\n\n  }, {\n    key: \"intersectsOBB\",\n    value: function intersectsOBB(obb) {\n      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.EPSILON;\n      // prepare data structures (the code uses the same nomenclature like the reference)\n      a.c = this.center;\n      a.e[0] = this.halfSizes.x;\n      a.e[1] = this.halfSizes.y;\n      a.e[2] = this.halfSizes.z;\n      this.rotation.extractBasis(a.u[0], a.u[1], a.u[2]);\n      b.c = obb.center;\n      b.e[0] = obb.halfSizes.x;\n      b.e[1] = obb.halfSizes.y;\n      b.e[2] = obb.halfSizes.z;\n      obb.rotation.extractBasis(b.u[0], b.u[1], b.u[2]); // compute rotation matrix expressing b in as coordinate frame\n\n      for (var _i117 = 0; _i117 < 3; _i117++) {\n        for (var j = 0; j < 3; j++) {\n          R[_i117][j] = a.u[_i117].dot(b.u[j]);\n        }\n      } // compute translation vector\n\n\n      v1$4.subVectors(b.c, a.c); // bring translation into as coordinate frame\n\n      t[0] = v1$4.dot(a.u[0]);\n      t[1] = v1$4.dot(a.u[1]);\n      t[2] = v1$4.dot(a.u[2]); // compute common subexpressions. Add in an epsilon term to\n      // counteract arithmetic errors when two edges are parallel and\n      // their cross product is (near) null\n\n      for (var _i118 = 0; _i118 < 3; _i118++) {\n        for (var _j = 0; _j < 3; _j++) {\n          AbsR[_i118][_j] = Math.abs(R[_i118][_j]) + epsilon;\n        }\n      }\n\n      var ra, rb; // test axes L = A0, L = A1, L = A2\n\n      for (var _i119 = 0; _i119 < 3; _i119++) {\n        ra = a.e[_i119];\n        rb = b.e[0] * AbsR[_i119][0] + b.e[1] * AbsR[_i119][1] + b.e[2] * AbsR[_i119][2];\n        if (Math.abs(t[_i119]) > ra + rb) return false;\n      } // test axes L = B0, L = B1, L = B2\n\n\n      for (var _i120 = 0; _i120 < 3; _i120++) {\n        ra = a.e[0] * AbsR[0][_i120] + a.e[1] * AbsR[1][_i120] + a.e[2] * AbsR[2][_i120];\n        rb = b.e[_i120];\n        if (Math.abs(t[0] * R[0][_i120] + t[1] * R[1][_i120] + t[2] * R[2][_i120]) > ra + rb) return false;\n      } // test axis L = A0 x B0\n\n\n      ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0];\n      rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];\n      if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb) return false; // test axis L = A0 x B1\n\n      ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1];\n      rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];\n      if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb) return false; // test axis L = A0 x B2\n\n      ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2];\n      rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];\n      if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb) return false; // test axis L = A1 x B0\n\n      ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0];\n      rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];\n      if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb) return false; // test axis L = A1 x B1\n\n      ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1];\n      rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];\n      if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb) return false; // test axis L = A1 x B2\n\n      ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2];\n      rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];\n      if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb) return false; // test axis L = A2 x B0\n\n      ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0];\n      rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];\n      if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb) return false; // test axis L = A2 x B1\n\n      ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1];\n      rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];\n      if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb) return false; // test axis L = A2 x B2\n\n      ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2];\n      rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];\n      if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb) return false; // since no separating axis is found, the OBBs must be intersecting\n\n      return true;\n    }\n    /**\r\n    * Returns true if the given plane intersects this OBB.\r\n    *\r\n    * Reference: Testing Box Against Plane in Real-Time Collision Detection\r\n    * by Christer Ericson (chapter 5.2.3)\r\n    *\r\n    * @param {Plane} plane - The plane to test.\r\n    * @return {Boolean} The result of the intersection test.\r\n    */\n\n  }, {\n    key: \"intersectsPlane\",\n    value: function intersectsPlane(plane) {\n      this.rotation.extractBasis(xAxis$1, yAxis$1, zAxis$1); // compute the projection interval radius of this OBB onto L(t) = this->center + t * p.normal;\n\n      var r = this.halfSizes.x * Math.abs(plane.normal.dot(xAxis$1)) + this.halfSizes.y * Math.abs(plane.normal.dot(yAxis$1)) + this.halfSizes.z * Math.abs(plane.normal.dot(zAxis$1)); // compute distance of the OBB's center from the plane\n\n      var d = plane.normal.dot(this.center) - plane.constant; // Intersection occurs when distance d falls within [-r,+r] interval\n\n      return Math.abs(d) <= r;\n    }\n    /**\r\n    * Computes the OBB from an AABB.\r\n    *\r\n    * @param {AABB} aabb - The AABB.\r\n    * @return {OBB} A reference to this OBB.\r\n    */\n\n  }, {\n    key: \"fromAABB\",\n    value: function fromAABB(aabb) {\n      aabb.getCenter(this.center);\n      aabb.getSize(this.halfSizes).multiplyScalar(0.5);\n      this.rotation.identity();\n      return this;\n    }\n    /**\r\n    * Computes the minimum enclosing OBB for the given set of points. The method is an\r\n    * implementation of {@link http://gamma.cs.unc.edu/users/gottschalk/main.pdf Collision Queries using Oriented Bounding Boxes}\r\n    * by Stefan Gottschalk.\r\n    * According to the dissertation, the quality of the fitting process varies from\r\n    * the respective input. This method uses the best approach by computing the\r\n    * covariance matrix based on the triangles of the convex hull (chapter 3.4.3).\r\n    *\r\n    * However, the implementation is susceptible to {@link https://en.wikipedia.org/wiki/Regular_polygon regular polygons}\r\n    * like cubes or spheres. For such shapes, it's recommended to verify the quality\r\n    * of the produced OBB. Consider to use an AABB or bounding sphere if the result\r\n    * is not satisfying.\r\n    *\r\n    * @param {Array} points - An array of 3D vectors representing points in 3D space.\r\n    * @return {OBB} A reference to this OBB.\r\n    */\n\n  }, {\n    key: \"fromPoints\",\n    value: function fromPoints(points) {\n      var convexHull = new ConvexHull().fromPoints(points); // 1. iterate over all faces of the convex hull and triangulate\n\n      var faces = convexHull.faces;\n      var edges = new Array();\n      var triangles = new Array();\n\n      for (var _i121 = 0, il = faces.length; _i121 < il; _i121++) {\n        var face = faces[_i121];\n        var edge = face.edge;\n        edges.length = 0; // gather edges\n\n        do {\n          edges.push(edge);\n          edge = edge.next;\n        } while (edge !== face.edge); // triangulate\n\n\n        var triangleCount = edges.length - 2;\n\n        for (var j = 1, jl = triangleCount; j <= jl; j++) {\n          var _v6 = edges[0].vertex;\n          var _v7 = edges[j + 0].vertex;\n          var _v8 = edges[j + 1].vertex;\n          triangles.push(_v6.x, _v6.y, _v6.z);\n          triangles.push(_v7.x, _v7.y, _v7.z);\n          triangles.push(_v8.x, _v8.y, _v8.z);\n        }\n      } // 2. build covariance matrix\n\n\n      var p = new Vector3();\n      var q = new Vector3();\n      var r = new Vector3();\n      var qp = new Vector3();\n      var rp = new Vector3();\n      var v = new Vector3();\n      var mean = new Vector3();\n      var weightedMean = new Vector3();\n      var areaSum = 0;\n      var cxx, cxy, cxz, cyy, cyz, czz;\n      cxx = cxy = cxz = cyy = cyz = czz = 0;\n\n      for (var _i122 = 0, l = triangles.length; _i122 < l; _i122 += 9) {\n        p.fromArray(triangles, _i122);\n        q.fromArray(triangles, _i122 + 3);\n        r.fromArray(triangles, _i122 + 6);\n        mean.set(0, 0, 0);\n        mean.add(p).add(q).add(r).divideScalar(3);\n        qp.subVectors(q, p);\n        rp.subVectors(r, p);\n        var area = v.crossVectors(qp, rp).length() / 2; // .length() represents the frobenius norm here\n\n        weightedMean.add(v.copy(mean).multiplyScalar(area));\n        areaSum += area;\n        cxx += (9.0 * mean.x * mean.x + p.x * p.x + q.x * q.x + r.x * r.x) * (area / 12);\n        cxy += (9.0 * mean.x * mean.y + p.x * p.y + q.x * q.y + r.x * r.y) * (area / 12);\n        cxz += (9.0 * mean.x * mean.z + p.x * p.z + q.x * q.z + r.x * r.z) * (area / 12);\n        cyy += (9.0 * mean.y * mean.y + p.y * p.y + q.y * q.y + r.y * r.y) * (area / 12);\n        cyz += (9.0 * mean.y * mean.z + p.y * p.z + q.y * q.z + r.y * r.z) * (area / 12);\n        czz += (9.0 * mean.z * mean.z + p.z * p.z + q.z * q.z + r.z * r.z) * (area / 12);\n      }\n\n      weightedMean.divideScalar(areaSum);\n      cxx /= areaSum;\n      cxy /= areaSum;\n      cxz /= areaSum;\n      cyy /= areaSum;\n      cyz /= areaSum;\n      czz /= areaSum;\n      cxx -= weightedMean.x * weightedMean.x;\n      cxy -= weightedMean.x * weightedMean.y;\n      cxz -= weightedMean.x * weightedMean.z;\n      cyy -= weightedMean.y * weightedMean.y;\n      cyz -= weightedMean.y * weightedMean.z;\n      czz -= weightedMean.z * weightedMean.z;\n      var covarianceMatrix = new Matrix3();\n      covarianceMatrix.elements[0] = cxx;\n      covarianceMatrix.elements[1] = cxy;\n      covarianceMatrix.elements[2] = cxz;\n      covarianceMatrix.elements[3] = cxy;\n      covarianceMatrix.elements[4] = cyy;\n      covarianceMatrix.elements[5] = cyz;\n      covarianceMatrix.elements[6] = cxz;\n      covarianceMatrix.elements[7] = cyz;\n      covarianceMatrix.elements[8] = czz; // 3. compute rotation, center and half sizes\n\n      covarianceMatrix.eigenDecomposition(eigenDecomposition);\n      var unitary = eigenDecomposition.unitary;\n      var v1 = new Vector3();\n      var v2 = new Vector3();\n      var v3 = new Vector3();\n      unitary.extractBasis(v1, v2, v3);\n      var u1 = -Infinity;\n      var u2 = -Infinity;\n      var u3 = -Infinity;\n      var l1 = Infinity;\n      var l2 = Infinity;\n      var l3 = Infinity;\n\n      for (var _i123 = 0, _l16 = points.length; _i123 < _l16; _i123++) {\n        var _p = points[_i123];\n        u1 = Math.max(v1.dot(_p), u1);\n        u2 = Math.max(v2.dot(_p), u2);\n        u3 = Math.max(v3.dot(_p), u3);\n        l1 = Math.min(v1.dot(_p), l1);\n        l2 = Math.min(v2.dot(_p), l2);\n        l3 = Math.min(v3.dot(_p), l3);\n      }\n\n      v1.multiplyScalar(0.5 * (l1 + u1));\n      v2.multiplyScalar(0.5 * (l2 + u2));\n      v3.multiplyScalar(0.5 * (l3 + u3)); // center\n\n      this.center.add(v1).add(v2).add(v3);\n      this.halfSizes.x = u1 - l1;\n      this.halfSizes.y = u2 - l2;\n      this.halfSizes.z = u3 - l3; // halfSizes\n\n      this.halfSizes.multiplyScalar(0.5); // rotation\n\n      this.rotation.copy(unitary);\n      return this;\n    }\n    /**\r\n    * Returns true if the given OBB is deep equal with this OBB.\r\n    *\r\n    * @param {OBB} aabb - The OBB to test.\r\n    * @return {Boolean} The result of the equality test.\r\n    */\n\n  }, {\n    key: \"equals\",\n    value: function equals(obb) {\n      return obb.center.equals(this.center) && obb.halfSizes.equals(this.halfSizes) && obb.rotation.equals(this.rotation);\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.constructor.name,\n        center: this.center.toArray(new Array()),\n        halfSizes: this.halfSizes.toArray(new Array()),\n        rotation: this.rotation.toArray(new Array())\n      };\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {OBB} A reference to this OBB.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.center.fromArray(json.center);\n      this.halfSizes.fromArray(json.halfSizes);\n      this.rotation.fromArray(json.rotation);\n      return this;\n    }\n  }]);\n\n  return OBB;\n}();\n\nvar obb = new OBB();\n/**\r\n* Class for representing navigation edges.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments Edge\r\n*/\n\nvar NavEdge =\n/*#__PURE__*/\nfunction (_Edge) {\n  _inherits(NavEdge, _Edge);\n\n  /**\r\n  * Constructs a navigation edge.\r\n  *\r\n  * @param {Number} from - The index of the from node.\r\n  * @param {Number} to - The index of the to node.\r\n  * @param {Number} cost - The cost of this edge.\r\n  */\n  function NavEdge() {\n    var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    var cost = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, NavEdge);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NavEdge).call(this, from, to, cost));\n  }\n\n  return NavEdge;\n}(Edge);\n/**\r\n* Class for representing navigation nodes.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments Node\r\n*/\n\n\nvar NavNode =\n/*#__PURE__*/\nfunction (_Node) {\n  _inherits(NavNode, _Node);\n\n  /**\r\n  * Constructs a new navigation node.\r\n  *\r\n  * @param {Number} index - The unique index of this node.\r\n  * @param {Vector3} position - The position of the node in 3D space.\r\n  * @param {Object} userData - Custom user data connected to this node.\r\n  */\n  function NavNode() {\n    var _this29;\n\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n    var userData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, NavNode);\n\n    _this29 = _possibleConstructorReturn(this, _getPrototypeOf(NavNode).call(this, index));\n    /**\r\n    * The position of the node in 3D space.\r\n    * @type Vector3\r\n    */\n\n    _this29.position = position;\n    /**\r\n    * Custom user data connected to this node.\r\n    * @type Object\r\n    */\n\n    _this29.userData = userData;\n    return _this29;\n  }\n\n  return NavNode;\n}(Node);\n/**\r\n* Class with graph helpers.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar GraphUtils =\n/*#__PURE__*/\nfunction () {\n  function GraphUtils() {\n    _classCallCheck(this, GraphUtils);\n  }\n\n  _createClass(GraphUtils, null, [{\n    key: \"createGridLayout\",\n\n    /**\r\n    * Generates a navigation graph with a planar grid layout based on the given parameters.\r\n    *\r\n    * @param {Number} size - The size (width and depth) in x and z direction\r\n    * @param {Number} segments - The amount of segments in x and z direction.\r\n    * @return {Graph} The new graph.\r\n    */\n    value: function createGridLayout(size, segments) {\n      var graph = new Graph();\n      graph.digraph = true;\n      var halfSize = size / 2;\n      var segmentSize = size / segments; // nodes\n\n      var index = 0;\n\n      for (var _i124 = 0; _i124 <= segments; _i124++) {\n        var z = _i124 * segmentSize - halfSize;\n\n        for (var j = 0; j <= segments; j++) {\n          var x = j * segmentSize - halfSize;\n          var position = new Vector3(x, 0, z);\n          var node = new NavNode(index, position);\n          graph.addNode(node);\n          index++;\n        }\n      } // edges\n\n\n      var count = graph.getNodeCount();\n      var range = Math.pow(segmentSize + segmentSize / 2, 2);\n\n      for (var _i125 = 0; _i125 < count; _i125++) {\n        var _node = graph.getNode(_i125); // check distance to all other nodes\n\n\n        for (var _j2 = 0; _j2 < count; _j2++) {\n          if (_i125 !== _j2) {\n            var neighbor = graph.getNode(_j2);\n            var distanceSquared = neighbor.position.squaredDistanceTo(_node.position);\n\n            if (distanceSquared <= range) {\n              var distance = Math.sqrt(distanceSquared);\n              var edge = new NavEdge(_i125, _j2, distance);\n              graph.addEdge(edge);\n            }\n          }\n        }\n      }\n\n      return graph;\n    }\n  }]);\n\n  return GraphUtils;\n}();\n/**\r\n* A corridor is a sequence of portal edges representing a walkable way within a navigation mesh. The class is able\r\n* to find the shortest path through this corridor as a sequence of waypoints. It's an implementation of the so called\r\n* {@link http://digestingduck.blogspot.com/2010/03/simple-stupid-funnel-algorithm.html Funnel Algorithm}. Read\r\n* the paper {@link https://aaai.org/Papers/AAAI/2006/AAAI06-148.pdf Efficient Triangulation-Based Pathfinding} for\r\n* more detailed information.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @author {@link https://github.com/robp94|robp94}\r\n*/\n\n\nvar Corridor =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Creates a new corridor.\r\n  */\n  function Corridor() {\n    _classCallCheck(this, Corridor);\n\n    /**\r\n    * The portal edges of the corridor.\r\n    * @type Array\r\n    */\n    this.portalEdges = new Array();\n  }\n  /**\r\n  * Adds a portal edge defined by its left and right vertex to this corridor.\r\n  *\r\n  * @param {Vector3} left - The left point (origin) of the portal edge.\r\n  * @param {Vector3} right - The right point (destination) of the portal edge.\r\n  * @return {Corridor} A reference to this corridor.\r\n  */\n\n\n  _createClass(Corridor, [{\n    key: \"push\",\n    value: function push(left, right) {\n      this.portalEdges.push({\n        left: left,\n        right: right\n      });\n      return this;\n    }\n    /**\r\n    * Generates the shortest path through the corridor as an array of 3D vectors.\r\n    *\r\n    * @return {Array} An array of 3D waypoints.\r\n    */\n\n  }, {\n    key: \"generate\",\n    value: function generate() {\n      var portalEdges = this.portalEdges;\n      var path = new Array(); // init scan state\n\n      var portalApex, portalLeft, portalRight;\n      var apexIndex = 0,\n          leftIndex = 0,\n          rightIndex = 0;\n      portalApex = portalEdges[0].left;\n      portalLeft = portalEdges[0].left;\n      portalRight = portalEdges[0].right; // add start point\n\n      path.push(portalApex);\n\n      for (var _i126 = 1, l = portalEdges.length; _i126 < l; _i126++) {\n        var left = portalEdges[_i126].left;\n        var right = portalEdges[_i126].right; // update right vertex\n\n        if (MathUtils.area(portalApex, portalRight, right) <= 0) {\n          if (portalApex === portalRight || MathUtils.area(portalApex, portalLeft, right) > 0) {\n            // tighten the funnel\n            portalRight = right;\n            rightIndex = _i126;\n          } else {\n            // right over left, insert left to path and restart scan from portal left point\n            path.push(portalLeft); // make current left the new apex\n\n            portalApex = portalLeft;\n            apexIndex = leftIndex; // review eset portal\n\n            portalLeft = portalApex;\n            portalRight = portalApex;\n            leftIndex = apexIndex;\n            rightIndex = apexIndex; // restart scan\n\n            _i126 = apexIndex;\n            continue;\n          }\n        } // update left vertex\n\n\n        if (MathUtils.area(portalApex, portalLeft, left) >= 0) {\n          if (portalApex === portalLeft || MathUtils.area(portalApex, portalRight, left) < 0) {\n            // tighten the funnel\n            portalLeft = left;\n            leftIndex = _i126;\n          } else {\n            // left over right, insert right to path and restart scan from portal right point\n            path.push(portalRight); // make current right the new apex\n\n            portalApex = portalRight;\n            apexIndex = rightIndex; // reset portal\n\n            portalLeft = portalApex;\n            portalRight = portalApex;\n            leftIndex = apexIndex;\n            rightIndex = apexIndex; // restart scan\n\n            _i126 = apexIndex;\n            continue;\n          }\n        }\n      }\n\n      if (path.length === 0 || path[path.length - 1] !== portalEdges[portalEdges.length - 1].left) {\n        // append last point to path\n        path.push(portalEdges[portalEdges.length - 1].left);\n      }\n\n      return path;\n    }\n  }]);\n\n  return Corridor;\n}();\n/**\r\n* A lookup table representing the cost associated from traveling from one\r\n* node to every other node in the navgiation mesh's graph.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar CostTable =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Creates a new cost table.\r\n  */\n  function CostTable() {\n    _classCallCheck(this, CostTable);\n\n    this._nodeMap = new Map();\n  }\n  /**\r\n  * Inits the cost table for the given navigation mesh.\r\n  *\r\n  * @param {NavMesh} navMesh - The navigation mesh.\r\n  * @return {CostTable} A reference to this cost table.\r\n  */\n\n\n  _createClass(CostTable, [{\n    key: \"init\",\n    value: function init(navMesh) {\n      var graph = navMesh.graph;\n      var nodes = new Array();\n      this.clear(); // iterate over all nodes\n\n      graph.getNodes(nodes);\n\n      for (var _i127 = 0, il = nodes.length; _i127 < il; _i127++) {\n        var from = nodes[_i127]; // compute the distance to all other nodes\n\n        for (var j = 0, jl = nodes.length; j < jl; j++) {\n          var to = nodes[j];\n          var path = navMesh.findPath(from.position, to.position);\n          var cost = computeDistanceOfPath(path);\n          this.set(from.index, to.index, cost);\n        }\n      }\n\n      return this;\n    }\n    /**\r\n    * Clears the cost table.\r\n    *\r\n    * @return {CostTable} A reference to this cost table.\r\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._nodeMap.clear();\n\n      return this;\n    }\n    /**\r\n    * Sets the cost for the given pair of navigation nodes.\r\n    *\r\n    * @param {Number} from - The start node index.\r\n    * @param {Number} to - The destintation node index.\r\n    * @param {Number} cost - The cost.\r\n    * @return {CostTable} A reference to this cost table.\r\n    */\n\n  }, {\n    key: \"set\",\n    value: function set(from, to, cost) {\n      var nodeMap = this._nodeMap;\n      if (nodeMap.has(from) === false) nodeMap.set(from, new Map());\n      var nodeCostMap = nodeMap.get(from);\n      nodeCostMap.set(to, cost);\n      return this;\n    }\n    /**\r\n    * Returns the cost for the given pair of navigation nodes.\r\n    *\r\n    * @param {Number} from - The start node index.\r\n    * @param {Number} to - The destintation node index.\r\n    * @return {Number} The cost.\r\n    */\n\n  }, {\n    key: \"get\",\n    value: function get(from, to) {\n      var nodeCostMap = this._nodeMap.get(from);\n\n      return nodeCostMap.get(to);\n    }\n    /**\r\n    * Returns the size of the cost table (amount of entries).\r\n    *\r\n    * @return {Number} The size of the cost table.\r\n    */\n\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this._nodeMap.size;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        nodes: new Array()\n      };\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = this._nodeMap.entries()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var _step10$value = _slicedToArray(_step10.value, 2),\n              key = _step10$value[0],\n              value = _step10$value[1];\n\n          json.nodes.push({\n            index: key,\n            costs: Array.from(value)\n          });\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {CostTable} A reference to this cost table.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var nodes = json.nodes;\n\n      for (var _i128 = 0, l = nodes.length; _i128 < l; _i128++) {\n        var node = nodes[_i128];\n        var index = node.index;\n        var costs = new Map(node.costs);\n\n        this._nodeMap.set(index, costs);\n      }\n\n      return this;\n    }\n  }]);\n\n  return CostTable;\n}(); //\n\n\nfunction computeDistanceOfPath(path) {\n  var distance = 0;\n\n  for (var _i129 = 0, l = path.length - 1; _i129 < l; _i129++) {\n    var from = path[_i129];\n    var to = path[_i129 + 1];\n    distance += from.distanceTo(to);\n  }\n\n  return distance;\n}\n\nvar pointOnLineSegment = new Vector3();\nvar edgeDirection = new Vector3();\nvar movementDirection = new Vector3();\nvar newPosition = new Vector3();\nvar lineSegment = new LineSegment();\nvar edges = new Array();\nvar closestBorderEdge = {\n  edge: null,\n  closestPoint: new Vector3()\n};\n/**\r\n* Implementation of a navigation mesh. A navigation mesh is a network of convex polygons\r\n* which define the walkable areas of a game environment. A convex polygon allows unobstructed travel\r\n* from any point in the polygon to any other. This is useful because it enables the navigation mesh\r\n* to be represented using a graph where each node represents a convex polygon and their respective edges\r\n* represent the neighborly relations to other polygons. More compact navigation graphs leads\r\n* to faster graph search execution.\r\n*\r\n* This particular implementation is able to merge convex polygons into bigger ones as long\r\n* as they keep their convexity and coplanarity. The performance of the path finding process and convex region tests\r\n* for complex navigation meshes can be improved by using a spatial index like {@link CellSpacePartitioning}.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @author {@link https://github.com/robp94|robp94}\r\n*/\n\nvar NavMesh =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new navigation mesh.\r\n  */\n  function NavMesh() {\n    _classCallCheck(this, NavMesh);\n\n    /**\r\n    * The internal navigation graph of this navigation mesh representing neighboring polygons.\r\n    * @type Graph\r\n    */\n    this.graph = new Graph();\n    this.graph.digraph = true;\n    /**\r\n    * The list of convex regions.\r\n    * @type Array\r\n    */\n\n    this.regions = new Array();\n    /**\r\n    * A reference to a spatial index.\r\n    * @type CellSpacePartitioning\r\n    * @default null\r\n    */\n\n    this.spatialIndex = null;\n    /**\r\n    * The tolerance value for the coplanar test.\r\n    * @type Number\r\n    * @default 1e-3\r\n    */\n\n    this.epsilonCoplanarTest = 1e-3;\n    /**\r\n    * The tolerance value for the containment test.\r\n    * @type Number\r\n    * @default 1\r\n    */\n\n    this.epsilonContainsTest = 1; //\n\n    this._borderEdges = new Array();\n  }\n  /**\r\n  * Creates the navigation mesh from an array of convex polygons.\r\n  *\r\n  * @param {Array} polygons - An array of convex polygons.\r\n  * @return {NavMesh} A reference to this navigation mesh.\r\n  */\n\n\n  _createClass(NavMesh, [{\n    key: \"fromPolygons\",\n    value: function fromPolygons(polygons) {\n      this.clear(); //\n\n      var initialEdgeList = new Array();\n      var sortedEdgeList = new Array(); // setup list with all edges\n\n      for (var _i130 = 0, l = polygons.length; _i130 < l; _i130++) {\n        var polygon = polygons[_i130];\n        var edge = polygon.edge;\n\n        do {\n          initialEdgeList.push(edge);\n          edge = edge.next;\n        } while (edge !== polygon.edge); //\n\n\n        this.regions.push(polygon);\n      } // setup twin references and sorted list of edges\n\n\n      for (var _i131 = 0, il = initialEdgeList.length; _i131 < il; _i131++) {\n        var edge0 = initialEdgeList[_i131];\n        if (edge0.twin !== null) continue;\n\n        for (var j = _i131 + 1, jl = initialEdgeList.length; j < jl; j++) {\n          var _edge2 = initialEdgeList[j];\n\n          if (edge0.tail().equals(_edge2.head()) && edge0.head().equals(_edge2.tail())) {\n            // opponent edge found, set twin references\n            edge0.linkOpponent(_edge2); // add edge to list\n\n            var cost = edge0.squaredLength();\n            sortedEdgeList.push({\n              cost: cost,\n              edge: edge0\n            }); // there can only be a single twin\n\n            break;\n          }\n        }\n      }\n\n      sortedEdgeList.sort(descending); // half-edge data structure is now complete, begin build of convex regions\n\n      this._buildRegions(sortedEdgeList); // now build the navigation graph\n\n\n      this._buildGraph();\n\n      return this;\n    }\n    /**\r\n    * Clears the internal state of this navigation mesh.\r\n    *\r\n    * @return {NavMesh} A reference to this navigation mesh.\r\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.graph.clear();\n      this.regions.length = 0;\n      this.spatialIndex = null;\n      return this;\n    }\n    /**\r\n    * Returns the closest convex region for the given point in 3D space.\r\n    *\r\n    * @param {Vector3} point - A point in 3D space.\r\n    * @return {Polygon} The closest convex region.\r\n    */\n\n  }, {\n    key: \"getClosestRegion\",\n    value: function getClosestRegion(point) {\n      var regions = this.regions;\n      var closesRegion = null;\n      var minDistance = Infinity;\n\n      for (var _i132 = 0, l = regions.length; _i132 < l; _i132++) {\n        var region = regions[_i132];\n        var distance = point.squaredDistanceTo(region.centroid);\n\n        if (distance < minDistance) {\n          minDistance = distance;\n          closesRegion = region;\n        }\n      }\n\n      return closesRegion;\n    }\n    /**\r\n    * Returns at random a convex region from the navigation mesh.\r\n    *\r\n    * @return {Polygon} The convex region.\r\n    */\n\n  }, {\n    key: \"getRandomRegion\",\n    value: function getRandomRegion() {\n      var regions = this.regions;\n      var index = Math.floor(Math.random() * regions.length);\n      if (index === regions.length) index = regions.length - 1;\n      return regions[index];\n    }\n    /**\r\n    * Returns the region that contains the given point. The computational overhead\r\n    * of this method for complex navigation meshes can be reduced by using a spatial index.\r\n    * If no convex region contains the point, *null* is returned.\r\n    *\r\n    * @param {Vector3} point - A point in 3D space.\r\n    * @param {Number} epsilon - Tolerance value for the containment test.\r\n    * @return {Polygon} The convex region that contains the point.\r\n    */\n\n  }, {\n    key: \"getRegionForPoint\",\n    value: function getRegionForPoint(point) {\n      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-3;\n      var regions;\n\n      if (this.spatialIndex !== null) {\n        var index = this.spatialIndex.getIndexForPosition(point);\n        regions = this.spatialIndex.cells[index].entries;\n      } else {\n        regions = this.regions;\n      } //\n\n\n      for (var _i133 = 0, l = regions.length; _i133 < l; _i133++) {\n        var region = regions[_i133];\n\n        if (region.contains(point, epsilon) === true) {\n          return region;\n        }\n      }\n\n      return null;\n    }\n    /**\r\n    * Returns the node index for the given region. The index represents\r\n    * the navigation node of a region in the navigation graph.\r\n    *\r\n    * @param {Polygon} region - The convex region.\r\n    * @return {Number} The respective node index.\r\n    */\n\n  }, {\n    key: \"getNodeIndex\",\n    value: function getNodeIndex(region) {\n      return this.regions.indexOf(region);\n    }\n    /**\r\n    * Returns the shortest path that leads from the given start position to the end position.\r\n    * The computational overhead of this method for complex navigation meshes can greatly\r\n    * reduced by using a spatial index.\r\n    *\r\n    * @param {Vector3} from - The start/source position.\r\n    * @param {Vector3} to - The end/destination position.\r\n    * @return {Array} The shortest path as an array of points.\r\n    */\n\n  }, {\n    key: \"findPath\",\n    value: function findPath(from, to) {\n      var graph = this.graph;\n      var path = new Array();\n      var fromRegion = this.getRegionForPoint(from, this.epsilonContainsTest);\n      var toRegion = this.getRegionForPoint(to, this.epsilonContainsTest);\n\n      if (fromRegion === null || toRegion === null) {\n        // if source or target are outside the navmesh, choose the nearest convex region\n        if (fromRegion === null) fromRegion = this.getClosestRegion(from);\n        if (toRegion === null) toRegion = this.getClosestRegion(to);\n      } // check if both convex region are identical\n\n\n      if (fromRegion === toRegion) {\n        // no search necessary, directly create the path\n        path.push(new Vector3().copy(from));\n        path.push(new Vector3().copy(to));\n        return path;\n      } else {\n        // source and target are not in same region, perform search\n        var source = this.getNodeIndex(fromRegion);\n\n        var _target = this.getNodeIndex(toRegion);\n\n        var astar = new AStar(graph, source, _target);\n        astar.search();\n\n        if (astar.found === true) {\n          var polygonPath = astar.getPath();\n          var corridor = new Corridor();\n          corridor.push(from, from); // push sequence of portal edges to corridor\n\n          var portalEdge = {\n            left: null,\n            right: null\n          };\n\n          for (var _i134 = 0, l = polygonPath.length - 1; _i134 < l; _i134++) {\n            var region = this.regions[polygonPath[_i134]];\n            var nextRegion = this.regions[polygonPath[_i134 + 1]];\n\n            this._getPortalEdge(region, nextRegion, portalEdge);\n\n            corridor.push(portalEdge.left, portalEdge.right);\n          }\n\n          corridor.push(to, to);\n          path.push.apply(path, _toConsumableArray(corridor.generate()));\n        }\n\n        return path;\n      }\n    }\n    /**\r\n    * This method can be used to restrict the movement of a game entity on the navigation mesh.\r\n    * Instead of preventing any form of translation when a game entity hits a border edge, the\r\n    * movement is clamped along the contour of the navigation mesh. The computational overhead\r\n    * of this method for complex navigation meshes can be reduced by using a spatial index.\r\n    *\r\n    * @param {Polygon} currentRegion - The current convex region of the game entity.\r\n    * @param {Vector3} startPosition - The original start position of the entity for the current simulation step.\r\n    * @param {Vector3} endPosition - The original end position of the entity for the current simulation step.\r\n    * @param {Vector3} clampPosition - The clamped position of the entity for the current simulation step.\r\n    * @return {Polygon} The new convex region the game entity is in.\r\n    */\n\n  }, {\n    key: \"clampMovement\",\n    value: function clampMovement(currentRegion, startPosition, endPosition, clampPosition) {\n      var newRegion = this.getRegionForPoint(endPosition, this.epsilonContainsTest); // if newRegion is null, \"endPosition\" lies outside of the navMesh\n\n      if (newRegion === null) {\n        if (currentRegion === null) throw new Error('YUKA.NavMesh.clampMovement(): No current region available.'); // determine closest border edge\n\n        this._getClosestBorderEdge(startPosition, closestBorderEdge);\n\n        var closestEdge = closestBorderEdge.edge;\n        var _closestPoint = closestBorderEdge.closestPoint; // calculate movement and edge direction\n\n        closestEdge.getDirection(edgeDirection);\n        var length = movementDirection.subVectors(endPosition, startPosition).length(); // this value influences the speed at which the entity moves along the edge\n\n        var f = 0; // if startPosition and endPosition are equal, length becomes zero.\n        // it's important to test this edge case in order to avoid NaN values.\n\n        if (length !== 0) {\n          movementDirection.divideScalar(length);\n          f = edgeDirection.dot(movementDirection);\n        } // calculate new position on the edge\n\n\n        newPosition.copy(_closestPoint).add(edgeDirection.multiplyScalar(f * length)); // the following value \"t\" tells us if the point exceeds the line segment\n\n        lineSegment.set(closestEdge.prev.vertex, closestEdge.vertex);\n\n        var _t5 = lineSegment.closestPointToPointParameter(newPosition, false); //\n\n\n        if (_t5 >= 0 && _t5 <= 1) {\n          // point is within line segment, we can safely use the new position\n          clampPosition.copy(newPosition);\n        } else {\n          // check, if the new point lies outside the navMesh\n          newRegion = this.getRegionForPoint(newPosition, this.epsilonContainsTest);\n\n          if (newRegion !== null) {\n            // if not, everything is fine\n            clampPosition.copy(newPosition);\n            return newRegion;\n          } // otherwise prevent movement\n\n\n          clampPosition.copy(startPosition);\n        }\n\n        return currentRegion;\n      } else {\n        // return the new region\n        return newRegion;\n      }\n    }\n    /**\r\n    * Updates the spatial index by assigning all convex regions to the\r\n    * partitions of the spatial index.\r\n    *\r\n    * @return {NavMesh} A reference to this navigation mesh.\r\n    */\n\n  }, {\n    key: \"updateSpatialIndex\",\n    value: function updateSpatialIndex() {\n      if (this.spatialIndex !== null) {\n        this.spatialIndex.makeEmpty();\n        var regions = this.regions;\n\n        for (var _i135 = 0, l = regions.length; _i135 < l; _i135++) {\n          var region = regions[_i135];\n          this.spatialIndex.addPolygon(region);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_buildRegions\",\n    value: function _buildRegions(edgeList) {\n      var regions = this.regions;\n      var cache = {\n        leftPrev: null,\n        leftNext: null,\n        rightPrev: null,\n        rightNext: null\n      }; // process edges from longest to shortest\n\n      for (var _i136 = 0, l = edgeList.length; _i136 < l; _i136++) {\n        var entry = edgeList[_i136];\n        var candidate = entry.edge; // cache current references for possible restore\n\n        cache.prev = candidate.prev;\n        cache.next = candidate.next;\n        cache.prevTwin = candidate.twin.prev;\n        cache.nextTwin = candidate.twin.next; // temporarily change the first polygon in order to represent both polygons\n\n        candidate.prev.next = candidate.twin.next;\n        candidate.next.prev = candidate.twin.prev;\n        candidate.twin.prev.next = candidate.next;\n        candidate.twin.next.prev = candidate.prev;\n        var polygon = candidate.polygon;\n        polygon.edge = candidate.prev;\n\n        if (polygon.convex() === true && polygon.coplanar(this.epsilonCoplanarTest) === true) {\n          // correct polygon reference of all edges\n          var edge = polygon.edge;\n\n          do {\n            edge.polygon = polygon;\n            edge = edge.next;\n          } while (edge !== polygon.edge); // delete obsolete polygon\n\n\n          var index = regions.indexOf(entry.edge.twin.polygon);\n          regions.splice(index, 1);\n        } else {\n          // restore\n          cache.prev.next = candidate;\n          cache.next.prev = candidate;\n          cache.prevTwin.next = candidate.twin;\n          cache.nextTwin.prev = candidate.twin;\n          polygon.edge = candidate;\n        }\n      } // after the merging of convex regions, do some post-processing\n\n\n      for (var _i137 = 0, _l17 = regions.length; _i137 < _l17; _i137++) {\n        var region = regions[_i137]; // compute the centroid of the region which can be used as\n        // a destination point in context of path finding\n\n        region.computeCentroid(); // gather all border edges used by clampMovement()\n\n        var _edge3 = region.edge;\n\n        do {\n          if (_edge3.twin === null) this._borderEdges.push(_edge3);\n          _edge3 = _edge3.next;\n        } while (_edge3 !== region.edge);\n      }\n    }\n  }, {\n    key: \"_buildGraph\",\n    value: function _buildGraph() {\n      var graph = this.graph;\n      var regions = this.regions; // for each region, the code creates an array of directly accessible regions\n\n      var regionNeighbourhood = new Array();\n\n      for (var _i138 = 0, l = regions.length; _i138 < l; _i138++) {\n        var region = regions[_i138];\n        var nodeIndices = new Array();\n        regionNeighbourhood.push(nodeIndices);\n        var edge = region.edge; // iterate through all egdes of the region (in other words: along its contour)\n\n        do {\n          // check for a portal edge\n          if (edge.twin !== null) {\n            var nodeIndex = this.getNodeIndex(edge.twin.polygon);\n            nodeIndices.push(nodeIndex); // the node index of the adjacent region\n            // add node for this region to the graph if necessary\n\n            if (graph.hasNode(this.getNodeIndex(edge.polygon)) === false) {\n              var node = new NavNode(this.getNodeIndex(edge.polygon), edge.polygon.centroid);\n              graph.addNode(node);\n            }\n          }\n\n          edge = edge.next;\n        } while (edge !== region.edge);\n      } // add navigation edges\n\n\n      for (var _i139 = 0, il = regionNeighbourhood.length; _i139 < il; _i139++) {\n        var indices = regionNeighbourhood[_i139];\n        var from = _i139;\n\n        for (var j = 0, jl = indices.length; j < jl; j++) {\n          var to = indices[j];\n\n          if (from !== to) {\n            if (graph.hasEdge(from, to) === false) {\n              var nodeFrom = graph.getNode(from);\n              var nodeTo = graph.getNode(to);\n              var cost = nodeFrom.position.distanceTo(nodeTo.position);\n              graph.addEdge(new NavEdge(from, to, cost));\n            }\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_getClosestBorderEdge\",\n    value: function _getClosestBorderEdge(point, closestBorderEdge) {\n      var borderEdges;\n      var minDistance = Infinity;\n\n      if (this.spatialIndex !== null) {\n        edges.length = 0;\n        var index = this.spatialIndex.getIndexForPosition(point);\n        var regions = this.spatialIndex.cells[index].entries;\n\n        for (var _i140 = 0, l = regions.length; _i140 < l; _i140++) {\n          var region = regions[_i140];\n          var edge = region.edge;\n\n          do {\n            if (edge.twin === null) edges.push(edge);\n            edge = edge.next;\n          } while (edge !== region.edge);\n        } // use only border edges from adjacent convex regions (fast)\n\n\n        borderEdges = edges;\n      } else {\n        // use all border edges (slow)\n        borderEdges = this._borderEdges;\n      } //\n\n\n      for (var _i141 = 0, _l18 = borderEdges.length; _i141 < _l18; _i141++) {\n        var _edge4 = borderEdges[_i141];\n        lineSegment.set(_edge4.prev.vertex, _edge4.vertex);\n\n        var _t6 = lineSegment.closestPointToPointParameter(point);\n\n        lineSegment.at(_t6, pointOnLineSegment);\n        var distance = pointOnLineSegment.squaredDistanceTo(point);\n\n        if (distance < minDistance) {\n          minDistance = distance;\n          closestBorderEdge.edge = _edge4;\n          closestBorderEdge.closestPoint.copy(pointOnLineSegment);\n        }\n      }\n\n      return this;\n    } // Determines the portal edge that can be used to reach the given polygon over its twin reference.\n\n  }, {\n    key: \"_getPortalEdge\",\n    value: function _getPortalEdge(region1, region2, portalEdge) {\n      var edge = region1.edge;\n\n      do {\n        if (edge.twin !== null) {\n          if (edge.twin.polygon === region2) {\n            // the direction of portal edges are reversed. so \"left\" is the edge's origin vertex and \"right\"\n            // is the destintation vertex. More details in issue #5\n            portalEdge.left = edge.prev.vertex;\n            portalEdge.right = edge.vertex;\n            return portalEdge;\n          }\n        }\n\n        edge = edge.next;\n      } while (edge !== region1.edge);\n\n      portalEdge.left = null;\n      portalEdge.right = null;\n      return portalEdge;\n    }\n  }]);\n\n  return NavMesh;\n}(); //\n\n\nfunction descending(a, b) {\n  return a.cost < b.cost ? 1 : a.cost > b.cost ? -1 : 0;\n}\n/**\r\n* Class for loading navigation meshes as glTF assets. The loader supports\r\n* *glTF* and *glb* files, embedded buffers, index and non-indexed geometries.\r\n* Interleaved geometry data are not yet supported.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar NavMeshLoader =\n/*#__PURE__*/\nfunction () {\n  function NavMeshLoader() {\n    _classCallCheck(this, NavMeshLoader);\n  }\n\n  _createClass(NavMeshLoader, [{\n    key: \"load\",\n\n    /**\r\n    * Loads a {@link NavMesh navigation mesh} from the given URL. The second parameter can be used\r\n    * to influence the parsing of the navigation mesh.\r\n    *\r\n    * @param {String} url - The URL of the glTF asset.\r\n    * @param {Object} options - The configuration object.\r\n    * @return {Promise} A promise representing the loading and parsing process.\r\n    */\n    value: function load(url, options) {\n      return new Promise(function (resolve, reject) {\n        fetch(url).then(function (response) {\n          if (response.status >= 200 && response.status < 300) {\n            return response.arrayBuffer();\n          } else {\n            var error = new Error(response.statusText || response.status);\n            error.response = response;\n            return Promise.reject(error);\n          }\n        }).then(function (arrayBuffer) {\n          var parser = new Parser();\n          var decoder = new TextDecoder();\n          var data;\n          var magic = decoder.decode(new Uint8Array(arrayBuffer, 0, 4));\n\n          if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n            parser.parseBinary(arrayBuffer);\n            data = parser.extensions.get('BINARY').content;\n          } else {\n            data = decoder.decode(new Uint8Array(arrayBuffer));\n          }\n\n          var json = JSON.parse(data);\n\n          if (json.asset === undefined || json.asset.version[0] < 2) {\n            throw new Error('YUKA.NavMeshLoader: Unsupported asset version.');\n          } else {\n            var path = extractUrlBase(url);\n            return parser.parse(json, path, options);\n          }\n        }).then(function (data) {\n          resolve(data);\n        }).catch(function (error) {\n          Logger.error('YUKA.NavMeshLoader: Unable to load navigation mesh.', error);\n          reject(error);\n        });\n      });\n    }\n  }]);\n\n  return NavMeshLoader;\n}();\n\nvar Parser =\n/*#__PURE__*/\nfunction () {\n  function Parser() {\n    _classCallCheck(this, Parser);\n\n    this.json = null;\n    this.path = null;\n    this.cache = new Map();\n    this.extensions = new Map();\n  }\n\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse(json, path, options) {\n      var _this30 = this;\n\n      this.json = json;\n      this.path = path; // read the first mesh in the glTF file\n\n      return this.getDependency('mesh', 0).then(function (data) {\n        // parse the raw geometry data into a bunch of polygons\n        var polygons = _this30.parseGeometry(data); // create and config navMesh\n\n\n        var navMesh = new NavMesh();\n\n        if (options) {\n          if (options.epsilonCoplanarTest) navMesh.epsilonCoplanarTest = options.epsilonCoplanarTest;\n        } // use polygons to setup the nav mesh\n\n\n        return navMesh.fromPolygons(polygons);\n      });\n    }\n  }, {\n    key: \"parseGeometry\",\n    value: function parseGeometry(data) {\n      var index = data.index;\n      var position = data.position;\n      var vertices = new Array();\n      var polygons = new Array(); // vertices\n\n      for (var _i142 = 0, l = position.length; _i142 < l; _i142 += 3) {\n        var _v9 = new Vector3();\n\n        _v9.x = position[_i142 + 0];\n        _v9.y = position[_i142 + 1];\n        _v9.z = position[_i142 + 2];\n        vertices.push(_v9);\n      } // polygons\n\n\n      if (index) {\n        // indexed geometry\n        for (var _i143 = 0, _l19 = index.length; _i143 < _l19; _i143 += 3) {\n          var _a3 = index[_i143 + 0];\n          var _b2 = index[_i143 + 1];\n          var _c2 = index[_i143 + 2];\n          var _contour = [vertices[_a3], vertices[_b2], vertices[_c2]];\n          var polygon = new Polygon().fromContour(_contour);\n          polygons.push(polygon);\n        }\n      } else {\n        // non-indexed geometry //todo test\n        for (var _i144 = 0, _l20 = vertices.length; _i144 < _l20; _i144 += 3) {\n          var _contour2 = [vertices[_i144 + 0], vertices[_i144 + 1], vertices[_i144 + 2]];\n\n          var _polygon = new Polygon().fromContour(_contour2);\n\n          polygons.push(_polygon);\n        }\n      }\n\n      return polygons;\n    }\n  }, {\n    key: \"getDependencies\",\n    value: function getDependencies(type) {\n      var _this31 = this;\n\n      var cache = this.cache;\n      var dependencies = cache.get(type);\n\n      if (!dependencies) {\n        var definitions = this.json[type + (type === 'mesh' ? 'es' : 's')] || new Array();\n        dependencies = Promise.all(definitions.map(function (definition, index) {\n          return _this31.getDependency(type, index);\n        }));\n        cache.set(type, dependencies);\n      }\n\n      return dependencies;\n    }\n  }, {\n    key: \"getDependency\",\n    value: function getDependency(type, index) {\n      var cache = this.cache;\n      var key = type + ':' + index;\n      var dependency = cache.get(key);\n\n      if (dependency === undefined) {\n        switch (type) {\n          case 'accessor':\n            dependency = this.loadAccessor(index);\n            break;\n\n          case 'buffer':\n            dependency = this.loadBuffer(index);\n            break;\n\n          case 'bufferView':\n            dependency = this.loadBufferView(index);\n            break;\n\n          case 'mesh':\n            dependency = this.loadMesh(index);\n            break;\n\n          default:\n            throw new Error('Unknown type: ' + type);\n        }\n\n        cache.set(key, dependency);\n      }\n\n      return dependency;\n    }\n  }, {\n    key: \"loadBuffer\",\n    value: function loadBuffer(index) {\n      var _this32 = this;\n\n      var json = this.json;\n      var definition = json.buffers[index];\n\n      if (definition.uri === undefined && index === 0) {\n        return Promise.resolve(this.extensions.get('BINARY').body);\n      }\n\n      return new Promise(function (resolve, reject) {\n        var url = resolveURI(definition.uri, _this32.path);\n        fetch(url).then(function (response) {\n          return response.arrayBuffer();\n        }).then(function (arrayBuffer) {\n          resolve(arrayBuffer);\n        }).catch(function (error) {\n          Logger.error('YUKA.NavMeshLoader: Unable to load buffer.', error);\n          reject(error);\n        });\n      });\n    }\n  }, {\n    key: \"loadBufferView\",\n    value: function loadBufferView(index) {\n      var json = this.json;\n      var definition = json.bufferViews[index];\n      return this.getDependency('buffer', definition.buffer).then(function (buffer) {\n        var byteLength = definition.byteLength || 0;\n        var byteOffset = definition.byteOffset || 0;\n        return buffer.slice(byteOffset, byteOffset + byteLength);\n      });\n    }\n  }, {\n    key: \"loadAccessor\",\n    value: function loadAccessor(index) {\n      var json = this.json;\n      var definition = json.accessors[index];\n      return this.getDependency('bufferView', definition.bufferView).then(function (bufferView) {\n        var itemSize = WEBGL_TYPE_SIZES[definition.type];\n        var TypedArray = WEBGL_COMPONENT_TYPES[definition.componentType];\n        var byteOffset = definition.byteOffset || 0;\n        return new TypedArray(bufferView, byteOffset, definition.count * itemSize);\n      });\n    }\n  }, {\n    key: \"loadMesh\",\n    value: function loadMesh(index) {\n      var json = this.json;\n      var definition = json.meshes[index];\n      return this.getDependencies('accessor').then(function (accessors) {\n        // assuming a single primitive\n        var primitive = definition.primitives[0];\n\n        if (primitive.mode !== undefined && primitive.mode !== 4) {\n          throw new Error('YUKA.NavMeshLoader: Invalid geometry format. Please ensure to represent your geometry as triangles.');\n        }\n\n        return {\n          index: accessors[primitive.indices],\n          position: accessors[primitive.attributes.POSITION],\n          normal: accessors[primitive.attributes.NORMAL]\n        };\n      });\n    }\n  }, {\n    key: \"parseBinary\",\n    value: function parseBinary(data) {\n      var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n      var chunkIndex = 0;\n      var decoder = new TextDecoder();\n      var content = null;\n      var body = null;\n\n      while (chunkIndex < chunkView.byteLength) {\n        var chunkLength = chunkView.getUint32(chunkIndex, true);\n        chunkIndex += 4;\n        var chunkType = chunkView.getUint32(chunkIndex, true);\n        chunkIndex += 4;\n\n        if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n          var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n          content = decoder.decode(contentArray);\n        } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n          var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n          body = data.slice(byteOffset, byteOffset + chunkLength);\n        }\n\n        chunkIndex += chunkLength;\n      }\n\n      this.extensions.set('BINARY', {\n        content: content,\n        body: body\n      });\n    }\n  }]);\n\n  return Parser;\n}(); // helper functions\n\n\nfunction extractUrlBase(url) {\n  var index = url.lastIndexOf('/');\n  if (index === -1) return './';\n  return url.substr(0, index + 1);\n}\n\nfunction resolveURI(uri, path) {\n  if (typeof uri !== 'string' || uri === '') return '';\n  if (/^(https?:)?\\/\\//i.test(uri)) return uri;\n  if (/^data:.*,.*$/i.test(uri)) return uri;\n  if (/^blob:.*$/i.test(uri)) return uri;\n  return path + uri;\n} //\n\n\nvar WEBGL_TYPE_SIZES = {\n  'SCALAR': 1,\n  'VEC2': 2,\n  'VEC3': 3,\n  'VEC4': 4,\n  'MAT2': 4,\n  'MAT3': 9,\n  'MAT4': 16\n};\nvar WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nvar BINARY_EXTENSION_HEADER_LENGTH = 12;\nvar BINARY_EXTENSION_CHUNK_TYPES = {\n  JSON: 0x4E4F534A,\n  BIN: 0x004E4942\n};\n/**\r\n* Class for representing a single partition in context of cell-space partitioning.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar Cell =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new cell with the given values.\r\n  *\r\n  * @param {AABB} aabb - The bounding volume of the cell.\r\n  */\n  function Cell() {\n    var aabb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new AABB();\n\n    _classCallCheck(this, Cell);\n\n    /**\r\n    * The bounding volume of the cell.\r\n    * @type AABB\r\n    */\n    this.aabb = aabb;\n    /**\r\n    * The list of entries which belong to this cell.\r\n    * @type Array\r\n    */\n\n    this.entries = new Array();\n  }\n  /**\r\n  * Adds an entry to this cell.\r\n  *\r\n  * @param {Any} entry - The entry to add.\r\n  * @return {Cell} A reference to this cell.\r\n  */\n\n\n  _createClass(Cell, [{\n    key: \"add\",\n    value: function add(entry) {\n      this.entries.push(entry);\n      return this;\n    }\n    /**\r\n    * Removes an entry from this cell.\r\n    *\r\n    * @param {Any} entry - The entry to remove.\r\n    * @return {Cell} A reference to this cell.\r\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove(entry) {\n      var index = this.entries.indexOf(entry);\n      this.entries.splice(index, 1);\n      return this;\n    }\n    /**\r\n    * Removes all entries from this cell.\r\n    *\r\n    * @return {Cell} A reference to this cell.\r\n    */\n\n  }, {\n    key: \"makeEmpty\",\n    value: function makeEmpty() {\n      this.entries.length = 0;\n      return this;\n    }\n    /**\r\n    * Returns true if this cell is empty.\r\n    *\r\n    * @return {Boolean} Whether this cell is empty or not.\r\n    */\n\n  }, {\n    key: \"empty\",\n    value: function empty() {\n      return this.entries.length === 0;\n    }\n    /**\r\n    * Returns true if the given AABB intersects the internal bounding volume of this cell.\r\n    *\r\n    * @param {AABB} aabb - The AABB to test.\r\n    * @return {Boolean} Whether this cell intersects with the given AABB or not.\r\n    */\n\n  }, {\n    key: \"intersects\",\n    value: function intersects(aabb) {\n      return this.aabb.intersectsAABB(aabb);\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        type: this.constructor.name,\n        aabb: this.aabb.toJSON(),\n        entries: new Array()\n      };\n      var entries = this.entries;\n\n      for (var _i145 = 0, l = entries.length; _i145 < l; _i145++) {\n        json.entries.push(entries[_i145].uuid);\n      }\n\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {Cell} A reference to this game entity.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.aabb.fromJSON(json.aabb);\n      this.entries = json.entries.slice();\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {Cell} A reference to this cell.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      var entries = this.entries;\n\n      for (var _i146 = 0, l = entries.length; _i146 < l; _i146++) {\n        entries[_i146] = entities.get(entries[_i146]);\n      }\n\n      return this;\n    }\n  }]);\n\n  return Cell;\n}();\n\nvar clampedPosition = new Vector3();\nvar aabb$2 = new AABB();\nvar contour = new Array();\n/**\r\n* This class is used for cell-space partitioning, a basic approach for implementing\r\n* a spatial index. The 3D space is divided up into a number of cells. A cell contains a\r\n* list of references to all the entities it contains. Compared to other spatial indices like\r\n* octrees, the division of the 3D space is coarse and often not balanced but the computational\r\n* overhead for calculating the index of a specific cell based on a position vector is very fast.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\nvar CellSpacePartitioning =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new spatial index with the given values.\r\n  *\r\n  * @param {Number} width - The width of the entire spatial index.\r\n  * @param {Number} height - The height of the entire spatial index.\r\n  * @param {Number} depth - The depth of the entire spatial index.\r\n  * @param {Number} cellsX - The amount of cells along the x-axis.\r\n  * @param {Number} cellsY - The amount of cells along the y-axis.\r\n  * @param {Number} cellsZ - The amount of cells along the z-axis.\r\n  */\n  function CellSpacePartitioning(width, height, depth, cellsX, cellsY, cellsZ) {\n    _classCallCheck(this, CellSpacePartitioning);\n\n    /**\r\n    * The list of partitions.\r\n    * @type Array\r\n    */\n    this.cells = new Array();\n    /**\r\n    * The width of the entire spatial index.\r\n    * @type Number\r\n    */\n\n    this.width = width;\n    /**\r\n    * The height of the entire spatial index.\r\n    * @type Number\r\n    */\n\n    this.height = height;\n    /**\r\n    * The depth of the entire spatial index.\r\n    * @type Number\r\n    */\n\n    this.depth = depth;\n    /**\r\n    * The amount of cells along the x-axis.\r\n    * @type Number\r\n    */\n\n    this.cellsX = cellsX;\n    /**\r\n    * The amount of cells along the y-axis.\r\n    * @type Number\r\n    */\n\n    this.cellsY = cellsY;\n    /**\r\n    * The amount of cells along the z-axis.\r\n    * @type Number\r\n    */\n\n    this.cellsZ = cellsZ;\n    this._halfWidth = this.width / 2;\n    this._halfHeight = this.height / 2;\n    this._halfDepth = this.depth / 2;\n    this._min = new Vector3(-this._halfWidth, -this._halfHeight, -this._halfDepth);\n    this._max = new Vector3(this._halfWidth, this._halfHeight, this._halfDepth); //\n\n    var cellSizeX = this.width / this.cellsX;\n    var cellSizeY = this.height / this.cellsY;\n    var cellSizeZ = this.depth / this.cellsZ;\n\n    for (var _i147 = 0; _i147 < this.cellsX; _i147++) {\n      var x = _i147 * cellSizeX - this._halfWidth;\n\n      for (var j = 0; j < this.cellsY; j++) {\n        var y = j * cellSizeY - this._halfHeight;\n\n        for (var k = 0; k < this.cellsZ; k++) {\n          var z = k * cellSizeZ - this._halfDepth;\n          var min = new Vector3();\n          var max = new Vector3();\n          min.set(x, y, z);\n          max.x = min.x + cellSizeX;\n          max.y = min.y + cellSizeY;\n          max.z = min.z + cellSizeZ;\n\n          var _aabb = new AABB(min, max);\n\n          var cell = new Cell(_aabb);\n          this.cells.push(cell);\n        }\n      }\n    }\n  }\n  /**\r\n  * Updates the partitioning index of a given game entity.\r\n  *\r\n  * @param {GameEntity} entity - The entity to update.\r\n  * @param {Number} currentIndex - The current partition index of the entity.\r\n  * @return {Number} The new partitioning index for the given game entity.\r\n  */\n\n\n  _createClass(CellSpacePartitioning, [{\n    key: \"updateEntity\",\n    value: function updateEntity(entity) {\n      var currentIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n      var newIndex = this.getIndexForPosition(entity.position);\n\n      if (currentIndex !== newIndex) {\n        this.addEntityToPartition(entity, newIndex);\n\n        if (currentIndex !== -1) {\n          this.removeEntityFromPartition(entity, currentIndex);\n        }\n      }\n\n      return newIndex;\n    }\n    /**\r\n    * Adds an entity to a specific partition.\r\n    *\r\n    * @param {GameEntity} entity - The entity to add.\r\n    * @param {Number} index - The partition index.\r\n    * @return {CellSpacePartitioning} A reference to this spatial index.\r\n    */\n\n  }, {\n    key: \"addEntityToPartition\",\n    value: function addEntityToPartition(entity, index) {\n      var cell = this.cells[index];\n      cell.add(entity);\n      return this;\n    }\n    /**\r\n    * Removes an entity from a specific partition.\r\n    *\r\n    * @param {GameEntity} entity - The entity to remove.\r\n    * @param {Number} index - The partition index.\r\n    * @return {CellSpacePartitioning} A reference to this spatial index.\r\n    */\n\n  }, {\n    key: \"removeEntityFromPartition\",\n    value: function removeEntityFromPartition(entity, index) {\n      var cell = this.cells[index];\n      cell.remove(entity);\n      return this;\n    }\n    /**\r\n    * Computes the partition index for the given position vector.\r\n    *\r\n    * @param {Vector3} position - The given position.\r\n    * @return {Number} The partition index.\r\n    */\n\n  }, {\n    key: \"getIndexForPosition\",\n    value: function getIndexForPosition(position) {\n      clampedPosition.copy(position).clamp(this._min, this._max);\n      var indexX = Math.abs(Math.floor(this.cellsX * (clampedPosition.x + this._halfWidth) / this.width));\n      var indexY = Math.abs(Math.floor(this.cellsY * (clampedPosition.y + this._halfHeight) / this.height));\n      var indexZ = Math.abs(Math.floor(this.cellsZ * (clampedPosition.z + this._halfDepth) / this.depth)); // handle index overflow\n\n      if (indexX === this.cellsX) indexX = this.cellsX - 1;\n      if (indexY === this.cellsY) indexY = this.cellsY - 1;\n      if (indexZ === this.cellsZ) indexZ = this.cellsZ - 1; // calculate final index\n\n      return indexX * this.cellsY * this.cellsZ + indexY * this.cellsZ + indexZ;\n    }\n    /**\r\n    * Performs a query to the spatial index according the the given position and\r\n    * radius. The method approximates the query position and radius with an AABB and\r\n    * then performs an intersection test with all non-empty cells in order to determine\r\n    * relevant partitions. Stores the result in the given result array.\r\n    *\r\n    * @param {Vector3} position - The given query position.\r\n    * @param {Number} radius - The given query radius.\r\n    * @param {Array} result - The result array.\r\n    * @return {Array} The result array.\r\n    */\n\n  }, {\n    key: \"query\",\n    value: function query(position, radius, result) {\n      var cells = this.cells;\n      result.length = 0; // approximate range with an AABB which allows fast intersection test\n\n      aabb$2.min.copy(position).subScalar(radius);\n      aabb$2.max.copy(position).addScalar(radius); // test all non-empty cells for an intersection\n\n      for (var _i148 = 0, l = cells.length; _i148 < l; _i148++) {\n        var cell = cells[_i148];\n\n        if (cell.empty() === false && cell.intersects(aabb$2) === true) {\n          result.push.apply(result, _toConsumableArray(cell.entries));\n        }\n      }\n\n      return result;\n    }\n    /**\r\n    * Removes all entities from all partitions.\r\n    *\r\n    * @return {CellSpacePartitioning} A reference to this spatial index.\r\n    */\n\n  }, {\n    key: \"makeEmpty\",\n    value: function makeEmpty() {\n      var cells = this.cells;\n\n      for (var _i149 = 0, l = cells.length; _i149 < l; _i149++) {\n        cells[_i149].makeEmpty();\n      }\n\n      return this;\n    }\n    /**\r\n    * Adds a polygon to the spatial index. A polygon is approximated with an AABB.\r\n    *\r\n    * @param {Polygon} polygon - The polygon to add.\r\n    * @return {CellSpacePartitioning} A reference to this spatial index.\r\n    */\n\n  }, {\n    key: \"addPolygon\",\n    value: function addPolygon(polygon) {\n      var cells = this.cells;\n      polygon.getContour(contour);\n      aabb$2.fromPoints(contour);\n\n      for (var _i150 = 0, l = cells.length; _i150 < l; _i150++) {\n        var cell = cells[_i150];\n\n        if (cell.intersects(aabb$2) === true) {\n          cell.add(polygon);\n        }\n      }\n\n      return this;\n    }\n    /**\r\n     * Transforms this instance into a JSON object.\r\n     *\r\n     * @return {Object} The JSON object.\r\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        type: this.constructor.name,\n        cells: new Array(),\n        width: this.width,\n        height: this.height,\n        depth: this.depth,\n        cellsX: this.cellsX,\n        cellsY: this.cellsY,\n        cellsZ: this.cellsZ,\n        _halfWidth: this._halfWidth,\n        _halfHeight: this._halfHeight,\n        _halfDepth: this._halfDepth,\n        _min: this._min.toArray(new Array()),\n        _max: this._max.toArray(new Array())\n      };\n\n      for (var _i151 = 0, l = this.cells.length; _i151 < l; _i151++) {\n        json.cells.push(this.cells[_i151].toJSON());\n      }\n\n      return json;\n    }\n    /**\r\n     * Restores this instance from the given JSON object.\r\n     *\r\n     * @param {Object} json - The JSON object.\r\n     * @return {CellSpacePartitioning} A reference to this spatial index.\r\n     */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.cells.length = 0;\n      this.width = json.width;\n      this.height = json.height;\n      this.depth = json.depth;\n      this.cellsX = json.cellsX;\n      this.cellsY = json.cellsY;\n      this.cellsZ = json.cellsZ;\n      this._halfWidth = json._halfWidth;\n      this._halfHeight = json._halfHeight;\n      this._halfDepth = json._halfHeight;\n\n      this._min.fromArray(json._min);\n\n      this._max.fromArray(json._max);\n\n      for (var _i152 = 0, l = json.cells.length; _i152 < l; _i152++) {\n        this.cells.push(new Cell().fromJSON(json.cells[_i152]));\n      }\n\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {CellSpacePartitioning} A reference to this cell space portioning.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      for (var _i153 = 0, l = this.cells.length; _i153 < l; _i153++) {\n        this.cells[_i153].resolveReferences(entities);\n      }\n\n      return this;\n    }\n  }]);\n\n  return CellSpacePartitioning;\n}();\n/**\r\n* Class for representing the memory information about a single game entity.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar MemoryRecord =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new memory record.\r\n  *\r\n  * @param {GameEntity} entity - The game entity that is represented by this memory record.\r\n  */\n  function MemoryRecord() {\n    var entity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, MemoryRecord);\n\n    /**\r\n    * The game entity that is represented by this memory record.\r\n    * @type GameEntity\r\n    */\n    this.entity = entity;\n    /**\r\n    * Records the time the entity became visible. Useful in combination with a reaction time\r\n    * in order to prevent immediate actions.\r\n    * @type Number\r\n    * @default - Infinity\r\n    */\n\n    this.timeBecameVisible = -Infinity;\n    /**\r\n    * Records the time the entity was last sensed (e.g. seen or heard). Used to determine\r\n    * if a game entity can \"remember\" this record or not.\r\n    * @type Number\r\n    * @default - Infinity\r\n    */\n\n    this.timeLastSensed = -Infinity;\n    /**\r\n    * Marks the position where the opponent was last sensed.\r\n    * @type Vector3\r\n    */\n\n    this.lastSensedPosition = new Vector3();\n    /**\r\n    * Whether this game entity is visible or not.\r\n    * @type Boolean\r\n    * @default false\r\n    */\n\n    this.visible = false;\n  }\n  /**\r\n  * Transforms this instance into a JSON object.\r\n  *\r\n  * @return {Object} The JSON object.\r\n  */\n\n\n  _createClass(MemoryRecord, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.constructor.name,\n        entity: this.entity.uuid,\n        timeBecameVisible: this.timeBecameVisible.toString(),\n        timeLastSensed: this.timeLastSensed.toString(),\n        lastSensedPosition: this.lastSensedPosition.toArray(new Array()),\n        visible: this.visible\n      };\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {MemoryRecord} A reference to this memory record.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.entity = json.entity; // uuid\n\n      this.timeBecameVisible = parseFloat(json.timeBecameVisible);\n      this.timeLastSensed = parseFloat(json.timeLastSensed);\n      this.lastSensedPosition.fromArray(json.lastSensedPosition);\n      this.visible = json.visible;\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {MemoryRecord} A reference to this memory record.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      this.entity = entities.get(this.entity) || null;\n      return this;\n    }\n  }]);\n\n  return MemoryRecord;\n}();\n/**\r\n* Class for representing the memory system of a game entity. It is used for managing,\r\n* filtering, and remembering sensory input.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n*/\n\n\nvar MemorySystem =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new memory system.\r\n  *\r\n  * @param {GameEntity} owner - The game entity that owns this memory system.\r\n  */\n  function MemorySystem() {\n    var owner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, MemorySystem);\n\n    /**\r\n    * The game entity that owns this memory system.\r\n    * @type GameEntity\r\n    */\n    this.owner = owner;\n    /**\r\n    * Used to simulate memory of sensory events. It contains {@link MemoryRecord memory records}\r\n    * of all relevant game entities in the environment. The records are usually update by\r\n    * the owner of the memory system.\r\n    * @type Array\r\n    */\n\n    this.records = new Array();\n    /**\r\n    * Same as {@link MemorySystem#records} but used for fast access via the game entity.\r\n    * @type Map\r\n    */\n\n    this.recordsMap = new Map();\n    /**\r\n    * Represents the duration of the game entities short term memory in seconds.\r\n    * When a bot requests a list of all recently sensed game entities, this value\r\n    * is used to determine if the bot is able to remember a game entity or not.\r\n    * @type Number\r\n    * @default 1\r\n    */\n\n    this.memorySpan = 1;\n  }\n  /**\r\n  * Returns the memory record of the given game entity.\r\n  *\r\n  * @param {GameEntity} entity - The game entity.\r\n  * @return {MemoryRecord} The memory record for this game entity.\r\n  */\n\n\n  _createClass(MemorySystem, [{\n    key: \"getRecord\",\n    value: function getRecord(entity) {\n      return this.recordsMap.get(entity);\n    }\n    /**\r\n    * Creates a memory record for the given game entity.\r\n    *\r\n    * @param {GameEntity} entity - The game entity.\r\n    * @return {MemorySystem} A reference to this memory system.\r\n    */\n\n  }, {\n    key: \"createRecord\",\n    value: function createRecord(entity) {\n      var record = new MemoryRecord(entity);\n      this.records.push(record);\n      this.recordsMap.set(entity, record);\n      return this;\n    }\n    /**\r\n    * Deletes the memory record for the given game entity.\r\n    *\r\n    * @param {GameEntity} entity - The game entity.\r\n    * @return {MemorySystem} A reference to this memory system.\r\n    */\n\n  }, {\n    key: \"deleteRecord\",\n    value: function deleteRecord(entity) {\n      var record = this.getRecord(entity);\n      var index = this.records.indexOf(record);\n      this.records.splice(index, 1);\n      this.recordsMap.delete(entity);\n      return this;\n    }\n    /**\r\n    * Returns true if there is a memory record for the given game entity.\r\n    *\r\n    * @param {GameEntity} entity - The game entity.\r\n    * @return {Boolean} Whether the game entity has a memory record or not.\r\n    */\n\n  }, {\n    key: \"hasRecord\",\n    value: function hasRecord(entity) {\n      return this.recordsMap.has(entity);\n    }\n    /**\r\n    * Removes all memory records from the memory system.\r\n    *\r\n    * @return {MemorySystem} A reference to this memory system.\r\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.records.length = 0;\n      this.recordsMap.clear();\n      return this;\n    }\n    /**\r\n    * Determines all valid memory record and stores the result in the given array.\r\n    *\r\n    * @param {Number} currentTime - The current elapsed time.\r\n    * @param {Array} result - The result array.\r\n    * @return {Array} The result array.\r\n    */\n\n  }, {\n    key: \"getValidMemoryRecords\",\n    value: function getValidMemoryRecords(currentTime, result) {\n      var records = this.records;\n      result.length = 0;\n\n      for (var _i154 = 0, l = records.length; _i154 < l; _i154++) {\n        var record = records[_i154];\n\n        if (currentTime - record.timeLastSensed <= this.memorySpan) {\n          result.push(record);\n        }\n      }\n\n      return result;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        type: this.constructor.name,\n        owner: this.owner.uuid,\n        records: new Array(),\n        memorySpan: this.memorySpan\n      };\n      var records = this.records;\n\n      for (var _i155 = 0, l = records.length; _i155 < l; _i155++) {\n        var record = records[_i155];\n        json.records.push(record.toJSON());\n      }\n\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {MemorySystem} A reference to this memory system.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.owner = json.owner; // uuid\n\n      this.memorySpan = json.memorySpan;\n      var recordsJSON = json.records;\n\n      for (var _i156 = 0, l = recordsJSON.length; _i156 < l; _i156++) {\n        var recordJSON = recordsJSON[_i156];\n        var record = new MemoryRecord().fromJSON(recordJSON);\n        this.records.push(record);\n      }\n\n      return this;\n    }\n    /**\r\n    * Restores UUIDs with references to GameEntity objects.\r\n    *\r\n    * @param {Map} entities - Maps game entities to UUIDs.\r\n    * @return {MemorySystem} A reference to this memory system.\r\n    */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      this.owner = entities.get(this.owner) || null; // records\n\n      var records = this.records;\n\n      for (var _i157 = 0, l = records.length; _i157 < l; _i157++) {\n        var record = records[_i157];\n        record.resolveReferences(entities);\n        this.recordsMap.set(record.entity, record);\n      }\n\n      return this;\n    }\n  }]);\n\n  return MemorySystem;\n}();\n\nvar toPoint = new Vector3();\nvar direction$1 = new Vector3();\nvar ray$1 = new Ray();\nvar intersectionPoint$1 = new Vector3();\nvar worldPosition = new Vector3();\n/**\r\n * Class for representing the vision component of a game entity.\r\n *\r\n * @author {@link https://github.com/Mugen87|Mugen87}\r\n */\n\nvar Vision =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Constructs a new vision object.\r\n   *\r\n   * @param {GameEntity} owner - The owner of this vision instance.\r\n   */\n  function Vision() {\n    var owner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, Vision);\n\n    /**\r\n     * The game entity that owns this vision instance.\r\n     * @type GameEntity\r\n     */\n    this.owner = owner;\n    /**\r\n     * The field of view in radians.\r\n     * @type Number\r\n     * @default \r\n     */\n\n    this.fieldOfView = Math.PI;\n    /**\r\n     * The visual range in world units.\r\n     * @type Number\r\n     * @default Infinity\r\n     */\n\n    this.range = Infinity;\n    /**\r\n     * An array of obstacles. An obstacle is a game entity that\r\n     * implements the {@link GameEntity#lineOfSightTest} method.\r\n     * @type Array\r\n     */\n\n    this.obstacles = new Array();\n  }\n  /**\r\n   * Adds an obstacle to this vision instance.\r\n   *\r\n   * @param {GameEntity} obstacle - The obstacle to add.\r\n   * @return {Vision} A reference to this vision instance.\r\n   */\n\n\n  _createClass(Vision, [{\n    key: \"addObstacle\",\n    value: function addObstacle(obstacle) {\n      this.obstacles.push(obstacle);\n      return this;\n    }\n    /**\r\n     * Removes an obstacle from this vision instance.\r\n     *\r\n     * @param {GameEntity} obstacle - The obstacle to remove.\r\n     * @return {Vision} A reference to this vision instance.\r\n     */\n\n  }, {\n    key: \"removeObstacle\",\n    value: function removeObstacle(obstacle) {\n      var index = this.obstacles.indexOf(obstacle);\n      this.obstacles.splice(index, 1);\n      return this;\n    }\n    /**\r\n     * Performs a line of sight test in order to determine if the given point\r\n     * in 3D space is visible for the game entity.\r\n     *\r\n     * @param {Vector3} point - The point to test.\r\n     * @return {Boolean} Whether the given point is visible or not.\r\n     */\n\n  }, {\n    key: \"visible\",\n    value: function visible(point) {\n      var owner = this.owner;\n      var obstacles = this.obstacles;\n      owner.getWorldPosition(worldPosition); // check if point lies within the game entity's visual range\n\n      toPoint.subVectors(point, worldPosition);\n      var distanceToPoint = toPoint.length();\n      if (distanceToPoint > this.range) return false; // next, check if the point lies within the game entity's field of view\n\n      owner.getWorldDirection(direction$1);\n      var angle = direction$1.angleTo(toPoint);\n      if (angle > this.fieldOfView * 0.5) return false; // the point lies within the game entity's visual range and field\n      // of view. now check if obstacles block the game entity's view to the given point.\n\n      ray$1.origin.copy(worldPosition);\n      ray$1.direction.copy(toPoint).divideScalar(distanceToPoint || 1); // normalize\n\n      for (var _i158 = 0, l = obstacles.length; _i158 < l; _i158++) {\n        var obstacle = obstacles[_i158];\n\n        var _intersection = obstacle.lineOfSightTest(ray$1, intersectionPoint$1);\n\n        if (_intersection !== null) {\n          // if an intersection point is closer to the game entity than the given point,\n          // something is blocking the game entity's view\n          var squaredDistanceToIntersectionPoint = intersectionPoint$1.squaredDistanceTo(worldPosition);\n          if (squaredDistanceToIntersectionPoint <= distanceToPoint * distanceToPoint) return false;\n        }\n      }\n\n      return true;\n    }\n    /**\r\n     * Transforms this instance into a JSON object.\r\n     *\r\n     * @return {Object} The JSON object.\r\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        type: this.constructor.name,\n        owner: this.owner.uuid,\n        fieldOfView: this.fieldOfView,\n        range: this.range.toString()\n      };\n      json.obstacles = new Array();\n\n      for (var _i159 = 0, l = this.obstacles.length; _i159 < l; _i159++) {\n        var obstacle = this.obstacles[_i159];\n        json.obstacles.push(obstacle.uuid);\n      }\n\n      return json;\n    }\n    /**\r\n     * Restores this instance from the given JSON object.\r\n     *\r\n     * @param {Object} json - The JSON object.\r\n     * @return {Vision} A reference to this vision.\r\n     */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      this.owner = json.owner;\n      this.fieldOfView = json.fieldOfView;\n      this.range = parseFloat(json.range);\n\n      for (var _i160 = 0, l = json.obstacles.length; _i160 < l; _i160++) {\n        var obstacle = json.obstacles[_i160];\n        this.obstacles.push(obstacle);\n      }\n\n      return this;\n    }\n    /**\r\n     * Restores UUIDs with references to GameEntity objects.\r\n     *\r\n     * @param {Map} entities - Maps game entities to UUIDs.\r\n     * @return {Vision} A reference to this vision.\r\n     */\n\n  }, {\n    key: \"resolveReferences\",\n    value: function resolveReferences(entities) {\n      this.owner = entities.get(this.owner) || null;\n      var obstacles = this.obstacles;\n\n      for (var _i161 = 0, l = obstacles.length; _i161 < l; _i161++) {\n        obstacles[_i161] = entities.get(obstacles[_i161]);\n      }\n\n      return this;\n    }\n  }]);\n\n  return Vision;\n}();\n\nvar translation$1 = new Vector3();\nvar predictedPosition$3 = new Vector3();\nvar normalPoint = new Vector3();\nvar lineSegment$1 = new LineSegment();\nvar closestNormalPoint = new Vector3();\n/**\r\n* This steering behavior produces a force that keeps a vehicle close to its path. It is intended\r\n* to use it in combination with {@link FollowPathBehavior} in order to realize a more strict path following.\r\n*\r\n* @author {@link https://github.com/Mugen87|Mugen87}\r\n* @augments SteeringBehavior\r\n*/\n\nvar OnPathBehavior =\n/*#__PURE__*/\nfunction (_SteeringBehavior14) {\n  _inherits(OnPathBehavior, _SteeringBehavior14);\n\n  /**\r\n  * Constructs a new on path behavior.\r\n  *\r\n  * @param {Path} path - The path to stay close to.\r\n  * @param {Number} radius - Defines the width of the path. With a smaller radius, the vehicle will have to follow the path more closely.\r\n  * @param {Number} predictionFactor - Determines how far the behavior predicts the movement of the vehicle.\r\n  */\n  function OnPathBehavior() {\n    var _this33;\n\n    var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Path();\n    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;\n    var predictionFactor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n    _classCallCheck(this, OnPathBehavior);\n\n    _this33 = _possibleConstructorReturn(this, _getPrototypeOf(OnPathBehavior).call(this));\n    /**\r\n    * The path to stay close to.\r\n    * @type Path\r\n    */\n\n    _this33.path = path;\n    /**\r\n    * Defines the width of the path. With a smaller radius, the vehicle will have to follow the path more closely.\r\n    * @type Number\r\n    * @default 0.1\r\n    */\n\n    _this33.radius = radius;\n    /**\r\n    * Determines how far the behavior predicts the movement of the vehicle.\r\n    * @type Number\r\n    * @default 1\r\n    */\n\n    _this33.predictionFactor = predictionFactor; // internal behaviors\n\n    _this33._seek = new SeekBehavior();\n    return _this33;\n  }\n  /**\r\n  * Calculates the steering force for a single simulation step.\r\n  *\r\n  * @param {Vehicle} vehicle - The game entity the force is produced for.\r\n  * @param {Vector3} force - The force/result vector.\r\n  * @param {Number} delta - The time delta.\r\n  * @return {Vector3} The force/result vector.\r\n  */\n\n\n  _createClass(OnPathBehavior, [{\n    key: \"calculate\",\n    value: function calculate(vehicle, force\n    /*, delta */\n    ) {\n      var path = this.path; // predicted future position\n\n      translation$1.copy(vehicle.velocity).multiplyScalar(this.predictionFactor);\n      predictedPosition$3.addVectors(vehicle.position, translation$1); // compute closest line segment and normal point. the normal point is computed by projecting\n      // the predicted position of the vehicle on a line segment.\n\n      var minDistance = Infinity;\n      var l = path._waypoints.length; // handle looped paths differently since they have one line segment more\n\n      l = path.loop === true ? l : l - 1;\n\n      for (var _i162 = 0; _i162 < l; _i162++) {\n        lineSegment$1.from = path._waypoints[_i162]; // the last waypoint needs to be handled differently for a looped path.\n        // connect the last point with the first one in order to create the last line segment\n\n        if (path.loop === true && _i162 === l - 1) {\n          lineSegment$1.to = path._waypoints[0];\n        } else {\n          lineSegment$1.to = path._waypoints[_i162 + 1];\n        }\n\n        lineSegment$1.closestPointToPoint(predictedPosition$3, true, normalPoint);\n        var distance = predictedPosition$3.squaredDistanceTo(normalPoint);\n\n        if (distance < minDistance) {\n          minDistance = distance;\n          closestNormalPoint.copy(normalPoint);\n        }\n      } // seek towards the projected point on the closest line segment if\n      // the predicted position of the vehicle is outside the valid range.\n      // also ensure that the path length is greater than zero when performing a seek\n\n\n      if (minDistance > this.radius * this.radius && path._waypoints.length > 1) {\n        this._seek.target = closestNormalPoint;\n\n        this._seek.calculate(vehicle, force);\n      }\n\n      return force;\n    }\n    /**\r\n    * Transforms this instance into a JSON object.\r\n    *\r\n    * @return {Object} The JSON object.\r\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(OnPathBehavior.prototype), \"toJSON\", this).call(this);\n\n      json.path = this.path.toJSON();\n      json.radius = this.radius;\n      json.predictionFactor = this.predictionFactor;\n      return json;\n    }\n    /**\r\n    * Restores this instance from the given JSON object.\r\n    *\r\n    * @param {Object} json - The JSON object.\r\n    * @return {OnPathBehavior} A reference to this behavior.\r\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(OnPathBehavior.prototype), \"fromJSON\", this).call(this, json);\n\n      this.path.fromJSON(json.path);\n      this.radius = json.radius;\n      this.predictionFactor = json.predictionFactor;\n      return this;\n    }\n  }]);\n\n  return OnPathBehavior;\n}(SteeringBehavior);\n/**\r\n* Base class for representing tasks. A task is an isolated unit of work that is\r\n* processed in an asynchronous way. Tasks are managed within a {@link TaskQueue task queue}.\r\n*\r\n* @author {@link https://github.com/robp94|robp94}\r\n*/\n\n\nvar Task =\n/*#__PURE__*/\nfunction () {\n  function Task() {\n    _classCallCheck(this, Task);\n  }\n\n  _createClass(Task, [{\n    key: \"execute\",\n\n    /**\r\n    * This method represents the actual unit of work.\r\n    * Must be implemented by all concrete tasks.\r\n    */\n    value: function execute() {}\n  }]);\n\n  return Task;\n}();\n/**\r\n* This class is used for task management. Tasks are processed in an asynchronous\r\n* way when there is idle time within a single simulation step or after a defined amount\r\n* of time (deadline). The class is a wrapper around {@link https://w3.org/TR/requestidlecallback|requestidlecallback()},\r\n* a JavaScript API for cooperative scheduling of background tasks.\r\n*\r\n* @author {@link https://github.com/robp94|robp94}\r\n*/\n\n\nvar TaskQueue =\n/*#__PURE__*/\nfunction () {\n  /**\r\n  * Constructs a new task queue.\r\n  */\n  function TaskQueue() {\n    _classCallCheck(this, TaskQueue);\n\n    /**\r\n    * A list of pending tasks.\r\n    * @type Array\r\n    */\n    this.tasks = new Array();\n    /**\r\n    * Used to control the asynchronous processing.\r\n    * - timeout: After this amount of time (in ms), a scheduled task is executed even if\r\n    * doing so risks causing a negative performance impact (e.g. bad frame time).\r\n    * @type Object\r\n    */\n\n    this.options = {\n      timeout: 1000 // ms\n\n    }; //\n\n    this._active = false;\n    this._handler = runTaskQueue.bind(this);\n    this._taskHandle = 0;\n  }\n  /**\r\n  * Adds the given task to the task queue.\r\n  *\r\n  * @param {Task} task - The task to add.\r\n  * @return {TaskQueue} A reference to this task queue.\r\n  */\n\n\n  _createClass(TaskQueue, [{\n    key: \"enqueue\",\n    value: function enqueue(task) {\n      this.tasks.push(task);\n      return this;\n    }\n    /**\r\n    * Updates the internal state of the task queue. Should be called\r\n    * per simulation step.\r\n    *\r\n    * @return {TaskQueue} A reference to this task queue.\r\n    */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.tasks.length > 0) {\n        if (this._active === false) {\n          this._taskHandle = requestIdleCallback(this._handler, this.options);\n          this._active = true;\n        }\n      } else {\n        this._active = false;\n      }\n\n      return this;\n    }\n  }]);\n\n  return TaskQueue;\n}();\n/**\r\n* This function controls the processing of tasks. It schedules tasks when there\r\n* is idle time at the end of a simulation step.\r\n*\r\n* @param {Object} deadline - This object contains a function which returns\r\n* a number indicating how much time remains for task processing.\r\n*/\n\n\nfunction runTaskQueue(deadline) {\n  var tasks = this.tasks;\n\n  while (deadline.timeRemaining() > 0 && tasks.length > 0) {\n    var task = tasks[0];\n    task.execute();\n    tasks.shift();\n  }\n\n  if (tasks.length > 0) {\n    this._taskHandle = requestIdleCallback(this._handler, this.options);\n    this._active = true;\n  } else {\n    this._taskHandle = 0;\n    this._active = false;\n  }\n}\n\n\n\n//# sourceURL=webpack:///./src/js/lib/yuka.js?");

/***/ }),

/***/ "./src/js/utils/detector.js":
/*!**********************************!*\
  !*** ./src/js/utils/detector.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mr.doob / http://mrdoob.com/\r\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  canvas: !!window.CanvasRenderingContext2D,\n  webgl: function () {\n    try {\n      var canvas = document.createElement('canvas');\n      return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      return false;\n    }\n  }(),\n  workers: !!window.Worker,\n  fileapi: window.File && window.FileReader && window.FileList && window.Blob,\n  getWebGLErrorMessage: function getWebGLErrorMessage() {\n    var element = document.createElement('div');\n    element.id = 'webgl-error-message';\n    element.style.fontFamily = 'monospace';\n    element.style.fontSize = '13px';\n    element.style.fontWeight = 'normal';\n    element.style.textAlign = 'center';\n    element.style.background = '#fff';\n    element.style.color = '#000';\n    element.style.padding = '1.5em';\n    element.style.width = '400px';\n    element.style.margin = '5em auto 0';\n\n    if (!this.webgl) {\n      element.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000000\">WebGL</a>.<br />', 'Find out how to get it <a href=\"http://get.webgl.org/\" style=\"color:#000000\">here</a>.'].join('\\n') : ['Your browser does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000000\">WebGL</a>.<br/>', 'Find out how to get it <a href=\"http://get.webgl.org/\" style=\"color:#000000\">here</a>.'].join('\\n');\n    }\n\n    return element;\n  },\n  addGetWebGLMessage: function addGetWebGLMessage(parameters) {\n    var parent, id, element;\n    parameters = parameters || {};\n    parent = parameters.parent !== undefined ? parameters.parent : document.body;\n    id = parameters.id !== undefined ? parameters.id : 'oldie';\n    element = this.getWebGLErrorMessage();\n    element.id = id;\n    parent.appendChild(element);\n  }\n});\n\n//# sourceURL=webpack:///./src/js/utils/detector.js?");

/***/ }),

/***/ "./src/js/utils/helpers.js":
/*!*********************************!*\
  !*** ./src/js/utils/helpers.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Helpers; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Provides simple static functions that are used multiple times in the app\nvar Helpers =\n/*#__PURE__*/\nfunction () {\n  function Helpers() {\n    _classCallCheck(this, Helpers);\n  }\n\n  _createClass(Helpers, null, [{\n    key: \"throttle\",\n    value: function throttle(fn, threshhold, scope) {\n      threshhold || (threshhold = 250);\n      var last, deferTimer;\n      return function () {\n        var context = scope || this;\n        var now = +new Date(),\n            args = arguments;\n\n        if (last && now < last + threshhold) {\n          clearTimeout(deferTimer);\n          deferTimer = setTimeout(function () {\n            last = now;\n            fn.apply(context, args);\n          }, threshhold);\n        } else {\n          last = now;\n          fn.apply(context, args);\n        }\n      };\n    }\n  }, {\n    key: \"logProgress\",\n    value: function logProgress() {\n      return function (xhr) {\n        if (xhr.lengthComputable) {\n          var percentComplete = xhr.loaded / xhr.total * 100;\n          console.log(Math.round(percentComplete, 2) + '% downloaded');\n        }\n      };\n    }\n  }, {\n    key: \"logError\",\n    value: function logError() {\n      return function (xhr) {\n        console.error(xhr);\n      };\n    }\n  }, {\n    key: \"handleColorChange\",\n    value: function handleColorChange(color) {\n      return function (value) {\n        if (typeof value === 'string') {\n          value = value.replace('#', '0x');\n        }\n\n        color.setHex(value);\n      };\n    }\n  }, {\n    key: \"update\",\n    value: function update(mesh) {\n      this.needsUpdate(mesh.material, mesh.geometry);\n    }\n  }, {\n    key: \"needsUpdate\",\n    value: function needsUpdate(material, geometry) {\n      return function () {\n        material.shading = +material.shading; //Ensure number\n\n        material.vertexColors = +material.vertexColors; //Ensure number\n\n        material.side = +material.side; //Ensure number\n\n        material.needsUpdate = true;\n        geometry.verticesNeedUpdate = true;\n        geometry.normalsNeedUpdate = true;\n        geometry.colorsNeedUpdate = true;\n      };\n    }\n  }, {\n    key: \"updateTexture\",\n    value: function updateTexture(material, materialKey, textures) {\n      return function (key) {\n        material[materialKey] = textures[key];\n        material.needsUpdate = true;\n      };\n    }\n  }]);\n\n  return Helpers;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/utils/helpers.js?");

/***/ }),

/***/ "./src/js/utils/keyboard.js":
/*!**********************************!*\
  !*** ./src/js/utils/keyboard.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Keyboard; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar ALIAS = {\n  'left': 37,\n  'up': 38,\n  'right': 39,\n  'down': 40,\n  'space': 32,\n  'tab': 9,\n  'escape': 27\n};\n\nvar Keyboard =\n/*#__PURE__*/\nfunction () {\n  function Keyboard(domElement) {\n    var _this = this;\n\n    _classCallCheck(this, Keyboard);\n\n    this.domElement = domElement || document;\n    this.keyCodes = {}; // bind keyEvents\n\n    this.domElement.addEventListener('keydown', function (event) {\n      return _this.onKeyChange(event);\n    }, false);\n    this.domElement.addEventListener('keyup', function (event) {\n      return _this.onKeyChange(event);\n    }, false); // bind window blur\n\n    window.addEventListener('blur', function () {\n      return _this.onBlur;\n    }, false);\n  }\n\n  _createClass(Keyboard, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n\n      this.domElement.removeEventListener('keydown', function (event) {\n        return _this2.onKeyChange(event);\n      }, false);\n      this.domElement.removeEventListener('keyup', function (event) {\n        return _this2.onKeyChange(event);\n      }, false); // unbind window blur event\n\n      window.removeEventListener('blur', function () {\n        return _this2.onBlur;\n      }, false);\n    }\n  }, {\n    key: \"onBlur\",\n    value: function onBlur() {\n      for (var prop in this.keyCodes) {\n        this.keyCodes[prop] = false;\n      }\n    }\n  }, {\n    key: \"onKeyChange\",\n    value: function onKeyChange(event) {\n      // log to debug\n      //console.log('onKeyChange', event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey)\n      // update this.keyCodes\n      var keyCode = event.keyCode;\n      this.keyCodes[keyCode] = event.type === 'keydown';\n    }\n  }, {\n    key: \"pressed\",\n    value: function pressed(keyDesc) {\n      var keys = keyDesc.split('+');\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var pressed = false;\n\n        if (Object.keys(ALIAS).indexOf(key) != -1) {\n          pressed = this.keyCodes[ALIAS[key]];\n        } else {\n          pressed = this.keyCodes[key.toUpperCase().charCodeAt(0)];\n        }\n\n        if (!pressed) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"eventMatches\",\n    value: function eventMatches(event, keyDesc) {\n      var aliases = ALIAS;\n      var aliasKeys = Object.keys(aliases);\n      var keys = keyDesc.split('+'); // log to debug\n      // console.log('eventMatches', event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey)\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var pressed = false;\n\n        if (key === 'shift') {\n          pressed = event.shiftKey ? true : false;\n        } else if (key === 'ctrl') {\n          pressed = event.ctrlKey ? true : false;\n        } else if (key === 'alt') {\n          pressed = event.altKey ? true : false;\n        } else if (key === 'meta') {\n          pressed = event.metaKey ? true : false;\n        } else if (aliasKeys.indexOf(key) !== -1) {\n          pressed = event.keyCode === aliases[key];\n        } else if (event.keyCode === key.toUpperCase().charCodeAt(0)) {\n          pressed = true;\n        }\n\n        if (!pressed) return false;\n      }\n\n      return true;\n    }\n  }]);\n\n  return Keyboard;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/utils/keyboard.js?");

/***/ }),

/***/ "./src/js/utils/orbitControls.js":
/*!***************************************!*\
  !*** ./src/js/utils/orbitControls.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (THREE) {\n  var MOUSE = THREE.MOUSE;\n  if (!MOUSE) MOUSE = {\n    LEFT: 0,\n    MIDDLE: 1,\n    RIGHT: 2\n  };\n  /**\r\n   * @author qiao / https://github.com/qiao\r\n   * @author mrdoob / http://mrdoob.com\r\n   * @author alteredq / http://alteredqualia.com/\r\n   * @author WestLangley / http://github.com/WestLangley\r\n   * @author erich666 / http://erichaines.com\r\n   */\n\n  /*global THREE, console */\n\n  function OrbitConstraint(object) {\n    this.object = object; // \"target\" sets the location of focus, where the object orbits around\n    // and where it pans with respect to.\n\n    this.target = new THREE.Vector3(); // Limits to how far you can dolly in and out ( PerspectiveCamera only )\n\n    this.minDistance = 0;\n    this.maxDistance = Infinity; // Limits to how far you can zoom in and out ( OrthographicCamera only )\n\n    this.minZoom = 0;\n    this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n\n    this.minPolarAngle = 0; // radians\n\n    this.maxPolarAngle = Math.PI; // radians\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\n    this.minAzimuthAngle = -Infinity; // radians\n\n    this.maxAzimuthAngle = Infinity; // radians\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n\n    this.enableDamping = false;\n    this.dampingFactor = 0.25; ////////////\n    // internals\n\n    var scope = this;\n    var EPS = 0.000001; // Current position in spherical coordinate system.\n\n    var theta;\n    var phi; // Pending changes\n\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var panOffset = new THREE.Vector3();\n    var zoomChanged = false; // API\n\n    this.getPolarAngle = function () {\n      return phi;\n    };\n\n    this.getAzimuthalAngle = function () {\n      return theta;\n    };\n\n    this.rotateLeft = function (angle) {\n      thetaDelta -= angle;\n    };\n\n    this.rotateUp = function (angle) {\n      phiDelta -= angle;\n    }; // pass in distance in world space to move left\n\n\n    this.panLeft = function () {\n      var v = new THREE.Vector3();\n      return function panLeft(distance) {\n        var te = this.object.matrix.elements; // get X column of matrix\n\n        v.set(te[0], te[1], te[2]);\n        v.multiplyScalar(-distance);\n        panOffset.add(v);\n      };\n    }(); // pass in distance in world space to move up\n\n\n    this.panUp = function () {\n      var v = new THREE.Vector3();\n      return function panUp(distance) {\n        var te = this.object.matrix.elements; // get Y column of matrix\n\n        v.set(te[4], te[5], te[6]);\n        v.multiplyScalar(distance);\n        panOffset.add(v);\n      };\n    }(); // pass in x,y of change desired in pixel space,\n    // right and down are positive\n\n\n    this.pan = function (deltaX, deltaY, screenWidth, screenHeight) {\n      if (scope.object instanceof THREE.PerspectiveCamera) {\n        // perspective\n        var position = scope.object.position;\n        var offset = position.clone().sub(scope.target);\n        var targetDistance = offset.length(); // half of the fov is center to top of screen\n\n        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0); // we actually don't use screenWidth, since perspective camera is fixed to screen height\n\n        scope.panLeft(2 * deltaX * targetDistance / screenHeight);\n        scope.panUp(2 * deltaY * targetDistance / screenHeight);\n      } else if (scope.object instanceof THREE.OrthographicCamera) {\n        // orthographic\n        scope.panLeft(deltaX * (scope.object.right - scope.object.left) / screenWidth);\n        scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / screenHeight);\n      } else {\n        // camera neither orthographic or perspective\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n      }\n    };\n\n    this.dollyIn = function (dollyScale) {\n      if (scope.object instanceof THREE.PerspectiveCamera) {\n        scale /= dollyScale;\n      } else if (scope.object instanceof THREE.OrthographicCamera) {\n        scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale));\n        scope.object.updateProjectionMatrix();\n        zoomChanged = true;\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n      }\n    };\n\n    this.dollyOut = function (dollyScale) {\n      if (scope.object instanceof THREE.PerspectiveCamera) {\n        scale *= dollyScale;\n      } else if (scope.object instanceof THREE.OrthographicCamera) {\n        scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale));\n        scope.object.updateProjectionMatrix();\n        zoomChanged = true;\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n      }\n    };\n\n    this.update = function () {\n      var offset = new THREE.Vector3(); // so camera.up is the orbit axis\n\n      var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n      var quatInverse = quat.clone().inverse();\n      var lastPosition = new THREE.Vector3();\n      var lastQuaternion = new THREE.Quaternion();\n      return function () {\n        var position = this.object.position;\n        offset.copy(position).sub(this.target); // rotate offset to \"y-axis-is-up\" space\n\n        offset.applyQuaternion(quat); // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z); // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n        theta += thetaDelta;\n        phi += phiDelta; // restrict theta to be between desired limits\n\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta)); // restrict phi to be between desired limits\n\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi)); // restrict phi to be betwee EPS and PI-EPS\n\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n        var radius = offset.length() * scale; // restrict radius to be between desired limits\n\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius)); // move target to panned location\n\n        this.target.add(panOffset);\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta); // rotate offset back to \"camera-up-vector-is-up\" space\n\n        offset.applyQuaternion(quatInverse);\n        position.copy(this.target).add(offset);\n        this.object.lookAt(this.target);\n\n        if (this.enableDamping === true) {\n          thetaDelta *= 1 - this.dampingFactor;\n          phiDelta *= 1 - this.dampingFactor;\n        } else {\n          thetaDelta = 0;\n          phiDelta = 0;\n        }\n\n        scale = 1;\n        panOffset.set(0, 0, 0); // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (zoomChanged || lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n          lastPosition.copy(this.object.position);\n          lastQuaternion.copy(this.object.quaternion);\n          zoomChanged = false;\n          return true;\n        }\n\n        return false;\n      };\n    }();\n  }\n\n  ; // This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n  // the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n  // supported.\n  //\n  //    Orbit - left mouse / touch: one finger move\n  //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n  //    Pan - right mouse, or arrow keys / touch: three finter swipe\n\n  function OrbitControls(object, domElement) {\n    var constraint = new OrbitConstraint(object);\n    this.domElement = domElement !== undefined ? domElement : document; // API\n\n    Object.defineProperty(this, 'constraint', {\n      get: function get() {\n        return constraint;\n      }\n    });\n\n    this.getPolarAngle = function () {\n      return constraint.getPolarAngle();\n    };\n\n    this.getAzimuthalAngle = function () {\n      return constraint.getAzimuthalAngle();\n    }; // Set to false to disable this control\n\n\n    this.enabled = true; // center is old, deprecated; use \"target\" instead\n\n    this.center = this.target; // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility.\n    // Set to false to disable zooming\n\n    this.enableZoom = true;\n    this.zoomSpeed = 1.0; // Set to false to disable rotating\n\n    this.enableRotate = true;\n    this.rotateSpeed = 1.0; // Set to false to disable panning\n\n    this.enablePan = true;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n    // Set to false to disable use of the keys\n\n    this.enableKeys = true; // The four arrow keys\n\n    this.keys = {\n      LEFT: 37,\n      UP: 38,\n      RIGHT: 39,\n      BOTTOM: 40\n    }; // Mouse buttons\n\n    this.mouseButtons = {\n      ORBIT: THREE.MOUSE.LEFT,\n      ZOOM: THREE.MOUSE.MIDDLE,\n      PAN: THREE.MOUSE.RIGHT\n    }; ////////////\n    // internals\n\n    var scope = this;\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n    var STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_DOLLY: 4,\n      TOUCH_PAN: 5\n    };\n    var state = STATE.NONE; // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom; // events\n\n    var changeEvent = {\n      type: 'change'\n    };\n    var startEvent = {\n      type: 'start'\n    };\n    var endEvent = {\n      type: 'end'\n    }; // pass in x,y of change desired in pixel space,\n    // right and down are positive\n\n    function pan(deltaX, deltaY) {\n      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n      constraint.pan(deltaX, deltaY, element.clientWidth, element.clientHeight);\n    }\n\n    this.update = function () {\n      if (this.autoRotate && state === STATE.NONE) {\n        constraint.rotateLeft(getAutoRotationAngle());\n      }\n\n      if (constraint.update() === true) {\n        this.dispatchEvent(changeEvent);\n      }\n    };\n\n    this.reset = function () {\n      state = STATE.NONE;\n      this.target.copy(this.target0);\n      this.object.position.copy(this.position0);\n      this.object.zoom = this.zoom0;\n      this.object.updateProjectionMatrix();\n      this.dispatchEvent(changeEvent);\n      this.update();\n    };\n\n    function getAutoRotationAngle() {\n      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n    }\n\n    function getZoomScale() {\n      return Math.pow(0.95, scope.zoomSpeed);\n    }\n\n    function onMouseDown(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n\n      if (event.button === scope.mouseButtons.ORBIT) {\n        if (scope.enableRotate === false) return;\n        state = STATE.ROTATE;\n        rotateStart.set(event.clientX, event.clientY);\n      } else if (event.button === scope.mouseButtons.ZOOM) {\n        if (scope.enableZoom === false) return;\n        state = STATE.DOLLY;\n        dollyStart.set(event.clientX, event.clientY);\n      } else if (event.button === scope.mouseButtons.PAN) {\n        if (scope.enablePan === false) return;\n        state = STATE.PAN;\n        panStart.set(event.clientX, event.clientY);\n      }\n\n      if (state !== STATE.NONE) {\n        document.addEventListener('mousemove', onMouseMove, false);\n        document.addEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(startEvent);\n      }\n    }\n\n    function onMouseMove(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n      if (state === STATE.ROTATE) {\n        if (scope.enableRotate === false) return;\n        rotateEnd.set(event.clientX, event.clientY);\n        rotateDelta.subVectors(rotateEnd, rotateStart); // rotating across whole screen goes 360 degrees around\n\n        constraint.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed); // rotating up and down along whole screen attempts to go 360, but limited to 180\n\n        constraint.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n        rotateStart.copy(rotateEnd);\n      } else if (state === STATE.DOLLY) {\n        if (scope.enableZoom === false) return;\n        dollyEnd.set(event.clientX, event.clientY);\n        dollyDelta.subVectors(dollyEnd, dollyStart);\n\n        if (dollyDelta.y > 0) {\n          constraint.dollyIn(getZoomScale());\n        } else if (dollyDelta.y < 0) {\n          constraint.dollyOut(getZoomScale());\n        }\n\n        dollyStart.copy(dollyEnd);\n      } else if (state === STATE.PAN) {\n        if (scope.enablePan === false) return;\n        panEnd.set(event.clientX, event.clientY);\n        panDelta.subVectors(panEnd, panStart);\n        pan(panDelta.x, panDelta.y);\n        panStart.copy(panEnd);\n      }\n\n      if (state !== STATE.NONE) scope.update();\n    }\n\n    function onMouseUp()\n    /* event */\n    {\n      if (scope.enabled === false) return;\n      document.removeEventListener('mousemove', onMouseMove, false);\n      document.removeEventListener('mouseup', onMouseUp, false);\n      scope.dispatchEvent(endEvent);\n      state = STATE.NONE;\n    }\n\n    function onMouseWheel(event) {\n      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;\n      event.preventDefault();\n      event.stopPropagation();\n      var delta = 0;\n\n      if (event.wheelDelta !== undefined) {\n        // WebKit / Opera / Explorer 9\n        delta = event.wheelDelta;\n      } else if (event.detail !== undefined) {\n        // Firefox\n        delta = -event.detail;\n      }\n\n      if (delta > 0) {\n        constraint.dollyOut(getZoomScale());\n      } else if (delta < 0) {\n        constraint.dollyIn(getZoomScale());\n      }\n\n      scope.update();\n      scope.dispatchEvent(startEvent);\n      scope.dispatchEvent(endEvent);\n    }\n\n    function onKeyDown(event) {\n      if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;\n\n      switch (event.keyCode) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed);\n          scope.update();\n          break;\n\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed);\n          scope.update();\n          break;\n\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0);\n          scope.update();\n          break;\n\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0);\n          scope.update();\n          break;\n      }\n    }\n\n    function touchstart(event) {\n      if (scope.enabled === false) return;\n\n      switch (event.touches.length) {\n        case 1:\n          // one-fingered touch: rotate\n          if (scope.enableRotate === false) return;\n          state = STATE.TOUCH_ROTATE;\n          rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n          break;\n\n        case 2:\n          // two-fingered touch: dolly\n          if (scope.enableZoom === false) return;\n          state = STATE.TOUCH_DOLLY;\n          var dx = event.touches[0].pageX - event.touches[1].pageX;\n          var dy = event.touches[0].pageY - event.touches[1].pageY;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n          dollyStart.set(0, distance);\n          break;\n\n        case 3:\n          // three-fingered touch: pan\n          if (scope.enablePan === false) return;\n          state = STATE.TOUCH_PAN;\n          panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n\n      if (state !== STATE.NONE) scope.dispatchEvent(startEvent);\n    }\n\n    function touchmove(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n      event.stopPropagation();\n      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n      switch (event.touches.length) {\n        case 1:\n          // one-fingered touch: rotate\n          if (scope.enableRotate === false) return;\n          if (state !== STATE.TOUCH_ROTATE) return;\n          rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n          rotateDelta.subVectors(rotateEnd, rotateStart); // rotating across whole screen goes 360 degrees around\n\n          constraint.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed); // rotating up and down along whole screen attempts to go 360, but limited to 180\n\n          constraint.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n          rotateStart.copy(rotateEnd);\n          scope.update();\n          break;\n\n        case 2:\n          // two-fingered touch: dolly\n          if (scope.enableZoom === false) return;\n          if (state !== STATE.TOUCH_DOLLY) return;\n          var dx = event.touches[0].pageX - event.touches[1].pageX;\n          var dy = event.touches[0].pageY - event.touches[1].pageY;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n          dollyEnd.set(0, distance);\n          dollyDelta.subVectors(dollyEnd, dollyStart);\n\n          if (dollyDelta.y > 0) {\n            constraint.dollyOut(getZoomScale());\n          } else if (dollyDelta.y < 0) {\n            constraint.dollyIn(getZoomScale());\n          }\n\n          dollyStart.copy(dollyEnd);\n          scope.update();\n          break;\n\n        case 3:\n          // three-fingered touch: pan\n          if (scope.enablePan === false) return;\n          if (state !== STATE.TOUCH_PAN) return;\n          panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n          panDelta.subVectors(panEnd, panStart);\n          pan(panDelta.x, panDelta.y);\n          panStart.copy(panEnd);\n          scope.update();\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n    }\n\n    function touchend()\n    /* event */\n    {\n      if (scope.enabled === false) return;\n      scope.dispatchEvent(endEvent);\n      state = STATE.NONE;\n    }\n\n    function contextmenu(event) {\n      event.preventDefault();\n    }\n\n    this.dispose = function () {\n      this.domElement.removeEventListener('contextmenu', contextmenu, false);\n      this.domElement.removeEventListener('mousedown', onMouseDown, false);\n      this.domElement.removeEventListener('mousewheel', onMouseWheel, false);\n      this.domElement.removeEventListener('MozMousePixelScroll', onMouseWheel, false); // firefox\n\n      this.domElement.removeEventListener('touchstart', touchstart, false);\n      this.domElement.removeEventListener('touchend', touchend, false);\n      this.domElement.removeEventListener('touchmove', touchmove, false);\n      document.removeEventListener('mousemove', onMouseMove, false);\n      document.removeEventListener('mouseup', onMouseUp, false);\n      window.removeEventListener('keydown', onKeyDown, false);\n    };\n\n    this.domElement.addEventListener('contextmenu', contextmenu, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('MozMousePixelScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n    window.addEventListener('keydown', onKeyDown, false); // force an update at start\n\n    this.update();\n  }\n\n  ;\n  OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);\n  OrbitControls.prototype.constructor = OrbitControls;\n  Object.defineProperties(OrbitControls.prototype, {\n    object: {\n      get: function get() {\n        return this.constraint.object;\n      }\n    },\n    target: {\n      get: function get() {\n        return this.constraint.target;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: target is now immutable. Use target.set() instead.');\n        this.constraint.target.copy(value);\n      }\n    },\n    minDistance: {\n      get: function get() {\n        return this.constraint.minDistance;\n      },\n      set: function set(value) {\n        this.constraint.minDistance = value;\n      }\n    },\n    maxDistance: {\n      get: function get() {\n        return this.constraint.maxDistance;\n      },\n      set: function set(value) {\n        this.constraint.maxDistance = value;\n      }\n    },\n    minZoom: {\n      get: function get() {\n        return this.constraint.minZoom;\n      },\n      set: function set(value) {\n        this.constraint.minZoom = value;\n      }\n    },\n    maxZoom: {\n      get: function get() {\n        return this.constraint.maxZoom;\n      },\n      set: function set(value) {\n        this.constraint.maxZoom = value;\n      }\n    },\n    minPolarAngle: {\n      get: function get() {\n        return this.constraint.minPolarAngle;\n      },\n      set: function set(value) {\n        this.constraint.minPolarAngle = value;\n      }\n    },\n    maxPolarAngle: {\n      get: function get() {\n        return this.constraint.maxPolarAngle;\n      },\n      set: function set(value) {\n        this.constraint.maxPolarAngle = value;\n      }\n    },\n    minAzimuthAngle: {\n      get: function get() {\n        return this.constraint.minAzimuthAngle;\n      },\n      set: function set(value) {\n        this.constraint.minAzimuthAngle = value;\n      }\n    },\n    maxAzimuthAngle: {\n      get: function get() {\n        return this.constraint.maxAzimuthAngle;\n      },\n      set: function set(value) {\n        this.constraint.maxAzimuthAngle = value;\n      }\n    },\n    enableDamping: {\n      get: function get() {\n        return this.constraint.enableDamping;\n      },\n      set: function set(value) {\n        this.constraint.enableDamping = value;\n      }\n    },\n    dampingFactor: {\n      get: function get() {\n        return this.constraint.dampingFactor;\n      },\n      set: function set(value) {\n        this.constraint.dampingFactor = value;\n      }\n    },\n    // backward compatibility\n    noZoom: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n        return !this.enableZoom;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n        this.enableZoom = !value;\n      }\n    },\n    noRotate: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n        return !this.enableRotate;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n        this.enableRotate = !value;\n      }\n    },\n    noPan: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n        return !this.enablePan;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n        this.enablePan = !value;\n      }\n    },\n    noKeys: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n        return !this.enableKeys;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n        this.enableKeys = !value;\n      }\n    },\n    staticMoving: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n        return !this.constraint.enableDamping;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n        this.constraint.enableDamping = !value;\n      }\n    },\n    dynamicDampingFactor: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n        return this.constraint.dampingFactor;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n        this.constraint.dampingFactor = value;\n      }\n    }\n  });\n  return OrbitControls;\n};\n\n//# sourceURL=webpack:///./src/js/utils/orbitControls.js?");

/***/ }),

/***/ 0:
/*!*****************************!*\
  !*** multi ./src/js/app.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/js/app.js */\"./src/js/app.js\");\n\n\n//# sourceURL=webpack:///multi_./src/js/app.js?");

/***/ })

},[[0,"runtime","vendors"]]]);